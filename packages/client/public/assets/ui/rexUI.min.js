! function(t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).rexuiplugin = e() }(void 0, function() {
    function P(t) { return (P = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t })(t) }

    function X(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }

    function n(t, e) { for (var i = 0; i < e.length; i++) { var n = e[i];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } }

    function k(t, e, i) { return e && n(t.prototype, e), i && n(t, i), Object.defineProperty(t, "prototype", { writable: !1 }), t }

    function w(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && i(t, e) }

    function C(t) { return (C = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) { return t.__proto__ || Object.getPrototypeOf(t) })(t) }

    function i(t, e) { return (i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) { return t.__proto__ = e, t })(t, e) }

    function W(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }

    function T(n) { var s = function() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0 } catch (t) { return !1 } }(); return function() { var t, e = C(n); if (s) { var i = C(this).constructor;
                t = Reflect.construct(e, arguments, i) } else t = e.apply(this, arguments); return function(t, e) { if (e && ("object" == typeof e || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return W(t) }(this, t) } }

    function l(t, e) { for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = C(t));); return t }

    function O() { return (O = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(t, e, i) { var n = l(t, e); if (n) { var s = Object.getOwnPropertyDescriptor(n, e); return s.get ? s.get.call(arguments.length < 3 ? t : i) : s.value } }).apply(this, arguments) }

    function r(t, e, i, n) { return (r = "undefined" != typeof Reflect && Reflect.set ? Reflect.set : function(t, e, i, n) { var s, r, o, a, h = l(t, e); if (h) { if ((s = Object.getOwnPropertyDescriptor(h, e)).set) return s.set.call(n, i), !0; if (!s.writable) return !1 } if (s = Object.getOwnPropertyDescriptor(n, e)) { if (!s.writable) return !1;
                s.value = i, Object.defineProperty(n, e, s) } else a = i, (o = e) in (r = n) ? Object.defineProperty(r, o, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : r[o] = a; return !0 })(t, e, i, n) }

    function e(t, e, i, n, s) { if (!r(t, e, i, n || t) && s) throw new Error("failed to set property"); return i }

    function f(t, e) { return s(t) || function(t, e) { var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"]; if (null == i) return; var n, s, r = [],
                o = !0,
                a = !1; try { for (i = i.call(t); !(o = (n = i.next()).done) && (r.push(n.value), !e || r.length !== e); o = !0); } catch (t) { a = !0, s = t } finally { try { o || null == i.return || i.return() } finally { if (a) throw s } } return r }(t, e) || a(t, e) || u() }

    function S(t) { return s(t) || o(t) || a(t) || u() }

    function M(t) { return function(t) { if (Array.isArray(t)) return h(t) }(t) || o(t) || a(t) || function() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() }

    function s(t) { if (Array.isArray(t)) return t }

    function o(t) { if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t) }

    function a(t, e) { if (t) { if ("string" == typeof t) return h(t, e); var i = Object.prototype.toString.call(t).slice(8, -1); return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? h(t, e) : void 0 } }

    function h(t, e) {
        (null == e || e > t.length) && (e = t.length); for (var i = 0, n = new Array(e); i < e; i++) n[i] = t[i]; return n }

    function u() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }

    function E(t) { var e, i, n; if ("object" !== P(t) || null === t) return t; for (n in e = Array.isArray(t) ? [] : {}, t) i = t[n], e[n] = E(i); return e }

    function _() {}

    function c(t, g) { var e = function() { w(v, t); var p = T(v);

            function v(t, e, i, n, s, r, o, a, h, l) { var u;
                X(this, v), R(e) ? (e = B(l = e, "x", 0), i = B(l, "y", 0), n = B(l, "width", 1), s = B(l, "height", 1), r = B(l, "key", void 0), o = B(l, "baseFrame", void 0), a = B(l, "columns", void 0), h = B(l, "rows", void 0)) : R(n) ? (n = B(l = n, "width", 1), s = B(l, "height", 1), r = B(l, "key", void 0), o = B(l, "baseFrame", void 0), a = B(l, "columns", void 0), h = B(l, "rows", void 0)) : R(r) ? (r = B(l = r, "key", void 0), o = B(l, "baseFrame", void 0), a = B(l, "columns", void 0), h = B(l, "rows", void 0)) : R(o) ? (o = B(l = o, "baseFrame", void 0), a = B(l, "columns", void 0), h = B(l, "rows", void 0)) : Array.isArray(o) ? (l = h, h = a, a = o, o = B(l, "baseFrame", void 0)) : R(a) && (a = B(l = a, "columns", void 0), h = B(l, "rows", void 0)), (u = p.call(this, t)).type = g, u.setPosition(e, i).setSize(n, s).setOrigin(.5, .5), u.columns = {}, u.rows = {}, u.stretchMode = {}, u._tileSprite = void 0, u._image = void 0, u.setGetFrameNameCallback(B(l, "getFrameNameCallback", void 0)), u.setStretchMode(B(l, "stretchMode", 0)), u.setPreserveRatio(B(l, "preserveRatio", !0)); var c = B(l, "maxFixedPartScale", 1),
                    d = B(l, "maxFixedPartScaleX", c),
                    f = B(l, "maxFixedPartScaleY", void 0); return u.setMaxFixedPartScale(d, f), u.setTexture(r, o, a, h), u } return k(v, [{ key: "minWidth", get: function() { return this.columns.minWidth } }, { key: "minHeight", get: function() { return this.rows.minHeight } }, { key: "fixedPartScaleX", get: function() { return this.columns.scale } }, { key: "fixedPartScaleY", get: function() { return this.rows.scale } }, { key: "resize", value: function(t, e) { return this.width === t && this.height === e || (O(C(v.prototype), "resize", this).call(this, t, e), this.updateTexture()), this } }]), v }(); return Object.assign(e.prototype, x), e }

    function d(t, e, i) { return void 0 === i && (i = "image"), t[e] || (t[e] = t.scene.make[i]({ add: !1, origin: { x: 0, y: 0 } }), t.once("destroy", function() { t[e] && (t[e].destroy(), t[e] = void 0) })), t[e] } var p = function() {
            function i(t) { X(this, i), this.scene = t, this.displayList = t.sys.displayList, this.updateList = t.sys.updateList, t.events.once("destroy", this.destroy, this) } return k(i, [{ key: "destroy", value: function() { this.scene = null, this.displayList = null, this.updateList = null } }], [{ key: "register", value: function(t, e) { i.prototype[t] = e } }]), i }(),
        v = function(t, e, i) { return "__BASE" === i ? "".concat(t, ",").concat(e) : "".concat(i, "_").concat(t, ",").concat(e) },
        g = Phaser.Utils.Objects.IsPlainObject,
        y = Phaser.Utils.Objects.GetValue,
        m = function(t) { return "string" == typeof t && (t = b[t]), t },
        b = { scale: 0, repeat: 1 },
        x = { _drawImage: _, _drawTileSprite: _, setGetFrameNameCallback: function(t) { return void 0 === t && (t = v), this.getFrameNameCallback = t, this }, setTexture: function(t, e, i, n) { Array.isArray(e) && (n = i, i = e, e = void 0), void 0 === e && (e = "__BASE"), i = E(i), n = E(n), this.textureKey = t, this.baseFrameName = e, this.columns.data = i, this.columns.count = i ? i.length : 0, this.columns.stretch = 0, this.columns.minWidth = 0, this.columns.scale = 1, this.rows.data = n, this.rows.count = n ? n.length : 0, this.rows.stretch = 0, this.rows.minHeight = 0, this.rows.scale = 1; var s = this.scene.sys.textures.get(t); if (!s) return this.clear(), this; if (!i || !n) return this.clear(), this; for (var r = s.get(e), o = r.width, a = 0, h = 0, l = i.length; h < l; h++) void 0 === i[h] ? a++ : "number" == typeof i[h] ? o -= i[h] : o -= i[h].width; var u = o / a,
                    c = r.height,
                    d = 0; for (h = 0, l = n.length; h < l; h++) void 0 === n[h] ? d++ : "number" == typeof n[h] ? c -= n[h] : c -= n[h].width; for (var f, p, v, g, y, m = c / d, k = 0, b = 0, x = 0, C = n.length; x < C; x++) { void 0 === n[x] && (n[x] = m), "number" == typeof n[x] && (n[x] = { height: n[x], stretch: x % 2 }), v = (f = n[x]).height, this.rows.stretch += 0 | f.stretch, this.rows.minHeight += 0 < f.stretch ? 0 : v;
                    h = k = 0; for (var w = i.length; h < w; h++) { if (void 0 === i[h] && (i[h] = u), "number" == typeof i[h] && (i[h] = { width: i[h], stretch: h % 2 }), g = (p = i[h]).width, 0 === x && (this.columns.stretch += 0 | p.stretch, this.columns.minWidth += 0 < p.stretch ? 0 : g), 1 <= g && 1 <= v) { var S = P(y = this.getFrameNameCallback(h, x, e)); "string" !== S && "number" !== S || s.add(y, 0, k + r.cutX, b + r.cutY, g, v) }
                        k += g }
                    b += v } return this.updateTexture(), this }, updateTexture: function() { if (this.clear(), void 0 === this.textureKey) return this; var t = this.scene.sys.textures.get(this.textureKey); if (!t) return this; var e, i, n, s, r, o, a, h = this.columns.minWidth * this.maxFixedPartScaleX,
                    l = this.rows.minHeight * this.maxFixedPartScaleY,
                    u = this.width - h,
                    c = this.height - l,
                    d = 0 <= u ? this.maxFixedPartScaleX : this.width / h,
                    f = 0 <= c ? this.maxFixedPartScaleY : this.height / l; if (this.preserveRatio) { var p = Math.min(d, f); if (p < d) { var v = (d - p) * h;
                        0 <= u ? u += v : u = v, d = p } if (p < f) { var g = (f - p) * l;
                        0 <= c ? c += g : c = g, f = p } }
                this.columns.scale = d, this.rows.scale = f, e = 0 < u && 0 < this.columns.stretch ? u / this.columns.stretch : 0, i = 0 < c && 0 < this.rows.stretch ? c / this.rows.stretch : 0; for (var y = 0, m = 0, k = 0, b = this.rows.count; k < b; k++) { a = 0 === (r = this.rows.data[k]).stretch ? r.height * f : i * r.stretch; for (var x = y = 0, C = this.columns.count; x < C; x++) o = 0 === (s = this.columns.data[x]).stretch ? s.width * d : e * s.stretch, n = this.getFrameNameCallback(x, k, this.baseFrameName), t.has(n) && 0 < o && 0 < a && (0 === (0 === r.stretch && 0 === s.stretch || 0 === this.getStretchMode(x, k) ? 0 : 1) ? this._drawImage(this.textureKey, n, y, m, o, a) : this._drawTileSprite(this.textureKey, n, y, m, o, a)), y += o;
                    m += a } }, setStretchMode: function(t) { return g(t) ? (this.stretchMode.edge = m(y(t, "edge", 0)), this.stretchMode.internal = m(y(t, "internal", 0))) : (t = m(t), this.stretchMode.edge = t, this.stretchMode.internal = t), this }, getStretchMode: function(t, e) { return function(t, e) { return 0 === t || t === this.columns.count - 1 || 0 === e || e === this.rows.count - 1 }.call(this, t, e) ? this.stretchMode.edge : this.stretchMode.internal }, setPreserveRatio: function(t) { return null == t && (t = !0), this.preserveRatio = t, this }, setMaxFixedPartScale: function(t, e) { return void 0 === e && (e = t), this.maxFixedPartScaleX = t, this.maxFixedPartScaleY = e, this } },
        R = Phaser.Utils.Objects.IsPlainObject,
        B = Phaser.Utils.Objects.GetValue,
        t = { _drawImage: function(t, e, i, n, s, r) { var o = d(this, "_image", "image").setTexture(t, e).setDisplaySize(s, r);
                this.draw(o, i, n) }, _drawTileSprite: function(t, e, i, n, s, r) { var o = d(this, "_tileSprite", "tileSprite").setTexture(t, e).setSize(s, r);
                this.draw(o, i, n) } },
        I = Phaser.GameObjects.RenderTexture,
        L = function() { w(e, c(I, "rexNinePatch")); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e) }();
    Object.assign(L.prototype, t);

    function A(t) { return null == t || "" === t || 0 === t.length }

    function j(t, e, i, n) { if (void 0 === n && (n = "."), "object" === P(t)) { if (A(e)) { if (null == i) return; "object" === P(i) && (t = i) } else { "string" == typeof e && (e = e.split(n)); var s = e.pop();
                (function(t, e, i) { var n = t; if (!A(e)) { var s; "string" == typeof e && (e = e.split(".")); for (var r = 0, o = e.length; r < o; r++) { var a; if (null == n[s = e[r]] || "object" !== P(n[s])) a = r !== o - 1 || void 0 === i ? {} : i, n[s] = a;
                            n = n[s] } } return n })(t, e)[s] = i } return t } }
    p.register("ninePatch", function(t, e, i, n, s, r, o, a) { var h = new L(this.scene, t, e, i, n, s, r, o, a); return this.scene.add.existing(h), h }), j(window, "RexPlugins.UI.NinePatch", L);

    function D(t, e) { return this.texture = this.scene.sys.textures.get(t), this.frame = this.texture.get(e), this }

    function z(t, e) { if (this.width === t && this.height === e) return this;
        this.width = t, this.height = e, this.updateDisplayOrigin(); var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this }

    function F() { return this.poolManager && this.poolManager.freeMultiple(this.children.list), this.children.list.length = 0, this.lastAppendedChildren.length = 0, this.dirty = !0, this } var Y = Phaser.GameObjects.GetCalcMatrix,
        G = Phaser.Renderer.Canvas.SetTransform,
        V = { renderWebGL: function(t, e, i, n) { var s = e.getRenderList(); if (0 !== s.length) { i.addToRenderList(e); var r = t.pipelines.set(e.pipeline),
                        o = e.frame.glTexture,
                        a = r.setGameObject(e),
                        h = i.roundPixels,
                        l = Y(e, i, n),
                        u = r.calcMatrix.copyFrom(l.calc),
                        c = e._displayOriginX,
                        d = e._displayOriginY,
                        f = i.alpha * e.alpha;
                    t.pipelines.preBatch(e); for (var p = 0, v = s.length; p < v; p++) s[p].webglRender(r, u, f, c, d, o, a, h);
                    t.pipelines.postBatch(e) } }, renderCanvas: function(t, e, i, n) { var s = t.currentContext,
                    r = e.getRenderList(); if (0 !== r.length && G(t, s, e, i, n)) { i.addToRenderList(e); var o = i.roundPixels,
                        a = -e._displayOriginX,
                        h = -e._displayOriginY;
                    s.translate(a, h); for (var l = 0, u = r.length; l < u; l++) r[l].canvasRender(s, a, h, o);
                    s.restore() } } },
        U = Phaser.Utils.Array.Remove,
        H = { setTexture: D, resize: z, setSize: z, addChild: function(t) { var e;
                (this.lastAppendedChildren.length = 0, Array.isArray(t)) ? (this.children.add(t), (e = this.lastAppendedChildren).push.apply(e, M(t))) : (this.children.add(t), this.lastAppendedChildren.push(t)); return this }, removeChild: function(t) { return this.poolManager && this.poolManager.free(t), U(this.children.list, t), this.lastAppendedChildren.length = 0, this.dirty = !0, this }, removeChildren: F, clear: F, getLastAppendedChildren: function() { return this.lastAppendedChildren }, getChildren: function() { return this.children.list } };
    Object.assign(H, { setTint: function(t) { return this.tint = t, this.tintFill = !1, this }, setTintFill: function(t) { return this.tint = t, this.tintFill = !0, this }, clearTint: function() { return this.setTint(16777215), this } }); var N = function() {
            function t() { X(this, t), this.items = [] } return k(t, [{ key: "destroy", value: function() { this.clear(), this.items = void 0 } }, { key: "pop", value: function() { return 0 < this.items.length ? this.items.pop() : null } }, { key: "push", value: function(t) { return this.items.push(t), this } }, { key: "pushMultiple", value: function(t) { return this.items.push.apply(this.items, t), t.length = 0, this } }, { key: "clear", value: function() { return this.items.length = 0, this } }]), t }(),
        J = Phaser.Utils.Objects.GetValue,
        K = {},
        Z = function() {
            function e(t) { X(this, e), this.pools = J(t, "pools", K) } return k(e, [{ key: "destroy", value: function() { this.pools = void 0 } }, { key: "free", value: function(t) { if (!this.pools) return this; var e = t.type; return this.pools.hasOwnProperty(e) || (this.pools[e] = new N()), this.pools[e].push(t), t.onFree(), this } }, { key: "freeMultiple", value: function(t) { if (!this.pools) return this; for (var e = 0, i = t.length; e < i; e++) this.free(t[e]); return this } }, { key: "allocate", value: function(t) { return this.pools && this.pools.hasOwnProperty(t) ? this.pools[t].pop() : null } }]), e }(),
        q = Phaser.GameObjects.GameObject,
        $ = Phaser.Utils.Objects.IsPlainObject,
        Q = Phaser.Utils.Objects.GetValue,
        tt = Phaser.Structs.List,
        et = Phaser.Utils.Array.StableSort,
        it = function() { w(l, q); var h = T(l);

            function l(t, e, i, n, s, r) { var o;
                X(this, l), $(e) && (e = Q(r = e, "x", 0), i = Q(r, "y", 0), n = Q(r, "texture"), s = Q(r, "frame")), void 0 === e && (e = 0), void 0 === i && (i = 0), (o = h.call(this, t, "rexBlitter")).children = new tt(), o.renderList = [], o.displayListDirty = !1, o.lastAppendedChildren = []; var a = Q(r, "reuseBob", !0); return o.poolManager = a ? new Z(r) : void 0, o.setTexture(n, s).setPosition(e, i).setOrigin(0, 0).clearTint().initPipeline(), o } return k(l, [{ key: "preDestroy", value: function() { this.removeChildren(), this.children.destroy(), this.renderList.length = 0, this.poolManager && this.poolManager.destroy() } }, { key: "getRenderList", value: function() { if (this.displayListDirty) { this.renderList.length = 0; for (var t = !1, e = this.children.list, i = 0, n = e.length; i < n; i++) { var s = e[i];
                            nt(s) && (this.renderList.push(s), t = t || 0 !== s.depth) }
                        t && et(this.renderList, st), this.displayListDirty = !1 } return this.renderList } }]), l }(),
        nt = function(t) { return t.active && t.visible && 0 < t.alpha },
        st = function(t, e) { return t._depth - e._depth },
        rt = Phaser.GameObjects.Components;
    Phaser.Class.mixin(it, [rt.Alpha, rt.BlendMode, rt.ComputedSize, rt.Depth, rt.GetBounds, rt.Mask, rt.Origin, rt.Pipeline, rt.ScrollFactor, rt.Transform, rt.Visible, V, H]);

    function ot(t, e, i) { if (t && "number" != typeof t) { if (t.hasOwnProperty(e)) return t[e]; if (-1 === e.indexOf(".")) return i; for (var n = e.split("."), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break }
                r = s[n[o]], s = s[n[o]] } return r } return i }

    function at(t) { if ("object" !== P(t) || null === t) return t; if (Array.isArray(t)) t.length = 0;
        else
            for (var e in t) delete t[e]; return t } var ht = { enableData: function() { return void 0 === this.data && (this.data = {}), this }, setData: function(t, e) { if (this.enableData(), 1 === arguments.length) { var i = t; for (t in i) this.data[t] = i[t] } else this.data[t] = e; return this }, getData: function(t, e) { return this.enableData(), void 0 === t ? this.data : ot(this.data, t, e) }, incData: function(t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) + e), this }, mulData: function(t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) * e), this }, clearData: function() { return this.data && at(this.data), this } },
        lt = function() {
            function i(t, e) { X(this, i), this.type = e, this.data = void 0, this.setParent(t).reset().setActive() } return k(i, [{ key: "destroy", value: function() { this.parent && this.parent.removeChild(this) } }, { key: "setParent", value: function(t) { return this.parent = t, this } }, { key: "setDisplayListDirty", value: function(t) { return t && this.parent && (this.parent.displayListDirty = !0), this } }, { key: "active", get: function() { return this._active }, set: function(t) { this.setDisplayListDirty(this._active != t), this._active = t } }, { key: "setActive", value: function(t) { return void 0 === t && (t = !0), this.active = t, this } }, { key: "modifyPorperties", value: function() { return this } }, { key: "reset", value: function() { this.clearData() } }, { key: "onFree", value: function() { this.reset().setActive(!1).setParent() } }]), i }();
    Object.assign(lt.prototype, ht); var ut = Phaser.Math.DegToRad,
        ct = Phaser.Math.RadToDeg,
        dt = Phaser.Utils.Objects.GetValue,
        ft = function() { w(e, lt); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "visible", get: function() { return this._visible }, set: function(t) { this.setDisplayListDirty(this._visible != t), this._visible = t } }, { key: "setVisible", value: function(t) { return void 0 === t && (t = !0), this.visible = t, this } }, { key: "alpha", get: function() { return this._alpha }, set: function(t) { this.setDisplayListDirty(!!this._alpha != !!t), this._alpha = t } }, { key: "setAlpha", value: function(t) { return this.alpha = t, this } }, { key: "setX", value: function(t) { return this.x = t, this } }, { key: "setY", value: function(t) { return this.y = t, this } }, { key: "setPosition", value: function(t, e) { return this.x = t, this.y = e, this } }, { key: "setRotation", value: function(t) { return this.rotation = t, this } }, { key: "angle", get: function() { return ct(this.rotation) }, set: function(t) { this.rotation = ut(t) } }, { key: "setAngle", value: function(t) { return this.angle = t, this } }, { key: "setScaleX", value: function(t) { return this.scaleX = t, this } }, { key: "width", get: function() { return this._width }, set: function(t) { this._width = t } }, { key: "setWidth", value: function(t, e) { return void 0 === e && (e = !1), this.width = t, e && (this.scaleY = this.scaleX), this } }, { key: "setScaleY", value: function(t) { return this.scaleY = t, this } }, { key: "setScale", value: function(t, e) { return void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this } }, { key: "height", get: function() { return this._height }, set: function(t) { this._height = t } }, { key: "setHeight", value: function(t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "displayWidth", get: function() { return this._width * this.scaleX }, set: function(t) { this.scaleX = t / this._width } }, { key: "setDisplayWidth", value: function(t, e) { return void 0 === e && (e = !1), this.displayWidth = t, e && (this.scaleY = this.scaleX), this } }, { key: "displayHeight", get: function() { return this._height * this.scaleY }, set: function(t) { this.scaleY = t / this._height } }, { key: "setDisplayHeight", value: function(t, e) { return void 0 === e && (e = !1), this.displayHeight = t, e && (this.scaleX = this.scaleY), this } }, { key: "setOriginX", value: function(t) { return this.originX = t, this._displayOriginX = this.width * t, this } }, { key: "setOriginY", value: function(t) { return this.originY = t, this._displayOriginY = this.height * t, this } }, { key: "setOrigin", value: function(t, e) { return void 0 === e && (e = t), this.setOriginX(t).setOriginY(e), this } }, { key: "depth", get: function() { return this._depth }, set: function(t) { this.setDisplayListDirty(this._depth != t), this._depth = t } }, { key: "setDepth", value: function(t) { return void 0 === t && (t = 0), this.depth = t, this } }, { key: "modifyPorperties", value: function(t) { if (!t) return this;
                    t.hasOwnProperty("x") && this.setX(t.x), t.hasOwnProperty("y") && this.setY(t.y), t.hasOwnProperty("rotation") ? this.setRotation(t.rotation) : t.hasOwnProperty("angle") && this.setAngle(t.angle), t.hasOwnProperty("alpha") && this.setAlpha(t.alpha); var e = dt(t, "width", void 0),
                        i = dt(t, "height", void 0),
                        n = dt(t, "scale", void 0),
                        s = dt(t, "scaleX", n),
                        r = dt(t, "scaleY", n);
                    void 0 !== e ? void 0 === i && void 0 === r ? this.setWidth(e, !0) : this.setWidth(e) : void 0 !== s ? this.setScaleX(s) : t.hasOwnProperty("displayWidth") && this.setDisplayWidth(t.displayWidth), void 0 !== i ? void 0 === e && void 0 === s ? this.setHeight(i, !0) : this.setHeight(i) : void 0 !== r ? this.setScaleY(r) : t.hasOwnProperty("displayHeight") && this.setDisplayHeight(t.displayHeight); var o = dt(t, "origin", void 0); return void 0 !== o ? this.setOrigin(o) : (t.hasOwnProperty("originX") && this.setOriginX(t.originX), t.hasOwnProperty("originY") && this.setOriginY(t.originY)), t.hasOwnProperty("depth") && this.setDepth(t.depth), this } }, { key: "reset", value: function() { return O(C(e.prototype), "reset", this).call(this), this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0), this } }, { key: "webglRender", value: function() {} }, { key: "canvasRender", value: function() {} }]), e }(),
        pt = Phaser.GameObjects.Components.TransformMatrix,
        vt = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha,
        gt = new pt(),
        yt = Phaser.Utils.Objects.IsPlainObject,
        mt = function() { w(s, ft); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, "image")).setFrame(e), i } return k(s, [{ key: "width", get: function() { return this._width }, set: function() {} }, { key: "height", get: function() { return this._height }, set: function() {} }, { key: "setFrame", value: function(t) { return 0 < arguments.length && !yt(t) && (t = this.parent.texture.get(t)), this.frame = t, this._width = t ? t.width : 0, this._height = t ? t.height : 0, this } }, { key: "setFlipX", value: function(t) { return void 0 === t && (t = !0), this.flipX = t, this } }, { key: "setFlipY", value: function(t) { return void 0 === t && (t = !0), this.flipY = t, this } }, { key: "resetFlip", value: function() { return this.flipX = !1, this.flipY = !1, this } }, { key: "tint", get: function() { return void 0 === this._tint ? this.parent.tint : this._tint }, set: function(t) { this._tint = t } }, { key: "setTint", value: function(t) { return this.tint = t, this.tintFill = !1, this } }, { key: "setTintFill", value: function(t) { return this.tint = t, this.tintFill = !0, this } }, { key: "clearTint", value: function() { return this.setTint(16777215), this } }, { key: "resetTint", value: function() { return this.tint = void 0, this.tintFill = void 0, this } }, { key: "tintFill", get: function() { return void 0 === this._tintFill ? this.parent.tintFill : this._tintFill }, set: function(t) { this._tintFill = t } }, { key: "reset", value: function() { return O(C(s.prototype), "reset", this).call(this), this.resetFlip().resetTint().setFrame(), this } }, { key: "modifyPorperties", value: function(t) { return t && (t.hasOwnProperty("width") && (t.displayWidth = t.width, delete t.width), t.hasOwnProperty("height") && (t.displayHeight = t.height, delete t.height), t.hasOwnProperty("frame") && this.setFrame(t.frame), O(C(s.prototype), "modifyPorperties", this).call(this, t), t.hasOwnProperty("flipX") && this.setFlipX(t.flipX), t.hasOwnProperty("flipY") && this.setFlipY(t.flipY), t.hasOwnProperty("tint") && this.setTint(t.tint), t.hasOwnProperty("tintFill") && this.setTintFill(t.tintFill)), this } }]), s }(),
        kt = { webglRender: function(t, e, i, n, s, r, o, a) { var h = this._width,
                    l = this._height,
                    u = h * this.originX,
                    c = l * this.originY,
                    d = this.x - n,
                    f = this.y - s,
                    p = 1,
                    v = 1;
                this.flipX && (d += h - 2 * u, p = -1), this.flipY && (f += l - 2 * c, v = -1), gt.applyITRS(d, f, this.rotation, this.scaleX * p, this.scaleY * v), e.multiply(gt, gt); var g = -u,
                    y = -c,
                    m = g + h,
                    k = y + l,
                    b = gt.getXRound(g, y, a),
                    x = gt.getXRound(g, k, a),
                    C = gt.getXRound(m, k, a),
                    w = gt.getXRound(m, y, a),
                    S = gt.getYRound(g, y, a),
                    P = gt.getYRound(g, k, a),
                    T = gt.getYRound(m, k, a),
                    O = gt.getYRound(m, y, a),
                    M = this.frame.u0,
                    E = this.frame.v0,
                    _ = this.frame.u1,
                    R = this.frame.v1,
                    B = vt(this.tint, this.alpha * i);
                t.batchQuad(this.parent, b, S, x, P, C, T, w, O, M, E, _, R, B, B, B, B, this.tintFill, r, o) }, canvasRender: function(t, e, i, n) { t.save(); var s = this._width,
                    r = this._height,
                    o = s * this.originX,
                    a = r * this.originY,
                    h = this.x - o,
                    l = this.y - a,
                    u = 1,
                    c = 1;
                this.flipX && (h += s, u = -1), this.flipY && (l += r, c = -1), n && (h = Math.round(h), l = Math.round(l)), t.translate(h, l), t.rotate(this.rotation), t.scale(this.scaleX * u, this.scaleY * c); var d = this.frame;
                t.drawImage(d.source.image, d.cutX, d.cutY, s, r, 0, 0, s, r), t.restore() } };
    Object.assign(mt.prototype, kt);

    function bt(t, e) { "string" == typeof e && (e = { frame: e }); var i = t.poolManager ? t.poolManager.allocate("image") : null; return null === i ? i = new mt(t) : i.setParent(t).setActive(), i.modifyPorperties(e), t.addChild(i), i } var xt = { _drawImage: function(t, e, i, n, s, r) { bt(this, { frame: e, x: i, y: n, width: s, height: r }) }, _drawTileSprite: function(t, e, i, n, s, r) { var o = this.texture.get(e),
                    a = o.width,
                    h = o.height,
                    l = Math.floor(s / a),
                    u = Math.floor(r / h);
                i += (s - l * a) / 2, n += (r - u * h) / 2; for (var c = 0; c < l; c++)
                    for (var d = 0; d < u; d++) bt(this, { frame: e, x: i + c * a, y: n + d * h }) } },
        Ct = function() { w(s, c(it, "rexNinePatch2")); var t = T(s);

            function s() { return X(this, s), t.apply(this, arguments) } return k(s, [{ key: "setTexture", value: function(t, e, i, n) { return D.call(this, t, "__BASE"), this.columns && O(C(s.prototype), "setTexture", this).call(this, t, e, i, n), this } }]), s }();
    Object.assign(Ct.prototype, xt), p.register("ninePatch2", function(t, e, i, n, s, r, o, a) { var h = new Ct(this.scene, t, e, i, n, s, r, o, a); return this.scene.add.existing(h), h }), j(window, "RexPlugins.UI.NinePatch2", Ct);

    function wt(t, e, i) { var n = i.length; if (2 <= n) { var s = i[n - 2],
                r = i[n - 1]; if (t === s && e === r) return i } return i.push(t, e), i }

    function St(t, e, i, n, s, r, o, a, h) { o && s < r ? r -= 360 : !o && r < s && (r += 360); var l = It(r - s) / a;
        s = It(s); for (var u = 0; u <= a; u++) { var c = s + l * u,
                d = t + i * Math.cos(c),
                f = e + n * Math.sin(c);
            wt(d, f, h) } return h }

    function Pt(t, e, i, n, s, r) { for (var o = Lt.getTintAppendFloatAlpha(i.fillColor, i.fillAlpha * n), a = i.pathData, h = i.pathIndexes, l = 0; l < h.length; l += 3) { var u = 2 * h[l],
                c = 2 * h[l + 1],
                d = 2 * h[l + 2],
                f = a[0 + u] - s,
                p = a[1 + u] - r,
                v = a[0 + c] - s,
                g = a[1 + c] - r,
                y = a[0 + d] - s,
                m = a[1 + d] - r,
                k = e.getX(f, p),
                b = e.getY(f, p),
                x = e.getX(v, g),
                C = e.getY(v, g),
                w = e.getX(y, m),
                S = e.getY(y, m);
            t.batchTri(i, k, b, x, C, w, S, 0, 0, 1, 1, o, o, o, 2) } }

    function Tt(t, e, i, n, s) { var r = t.strokeTint,
            o = At.getTintAppendFloatAlpha(e.strokeColor, e.strokeAlpha * i);
        r.TL = o, r.TR = o, r.BL = o, r.BR = o; var a = e.pathData,
            h = a.length - 1,
            l = e.lineWidth,
            u = l / 2,
            c = a[0] - n,
            d = a[1] - s;
        e.closePath || (h -= 2); for (var f = 2; f < h; f += 2) { var p = a[f] - n,
                v = a[f + 1] - s;
            t.batchLine(c, d, p, v, u, u, l, f - 2, !!e.closePath && f === h - 1), c = p, d = v } }

    function Ot(t, e, i, n) { var s = i || e.fillColor,
            r = n || e.fillAlpha,
            o = (16711680 & s) >>> 16,
            a = (65280 & s) >>> 8,
            h = 255 & s;
        t.fillStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")" }

    function Mt(t, e, i, n) { var s = i || e.strokeColor,
            r = n || e.strokeAlpha,
            o = (16711680 & s) >>> 16,
            a = (65280 & s) >>> 8,
            h = 255 & s;
        t.strokeStyle = "rgba(" + o + "," + a + "," + h + "," + r + ")", t.lineWidth = e.lineWidth } var Et = Phaser.Utils.Objects.GetValue,
        _t = function() {
            function r(t, e, i, n, s) { X(this, r), this.cornerRadius = {}, this._width = 0, this._height = 0, this.setTo(t, e, i, n, s) } return k(r, [{ key: "setTo", value: function(t, e, i, n, s) { return this.setPosition(t, e), this.setRadius(s), this.setSize(i, n), this } }, { key: "setPosition", value: function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this } }, { key: "setRadius", value: function(t) { return void 0 === t && (t = 0), this.radius = t, this } }, { key: "setSize", value: function(t, e) { return this.width = t, this.height = e, this } }, { key: "minWidth", get: function() { var t = this.cornerRadius; return Math.max(t.tl.x + t.tr.x, t.bl.x + t.br.x) } }, { key: "minHeight", get: function() { var t = this.cornerRadius; return Math.max(t.tl.y + t.bl.y, t.tr.y + t.br.y) } }, { key: "width", get: function() { return this._width }, set: function(t) { null == t && (t = 0), this._width = Math.max(t, this.minWidth) } }, { key: "height", get: function() { return this._height }, set: function(t) { null == t && (t = 0), this._height = Math.max(t, this.minHeight) } }, { key: "radius", get: function() { var t = this.cornerRadius; return Math.max(t.tl.x, t.tl.y, t.tr.x, t.tr.y, t.bl.x, t.bl.y, t.br.x, t.br.y) }, set: function(t) { var e, i;
                    i = "number" == typeof t ? e = t : (e = Et(t, "x", 0), Et(t, "y", 0)); var n = this.cornerRadius;
                    n.tl = Rt(Et(t, "tl", void 0), e, i), n.tr = Rt(Et(t, "tr", void 0), e, i), n.bl = Rt(Et(t, "bl", void 0), e, i), n.br = Rt(Et(t, "br", void 0), e, i) } }, { key: "radiusTL", get: function() { var t = this.cornerRadius.tl; return Math.max(t.x, t.y) }, set: function(t) { Bt(this.cornerRadius.tl, t) } }, { key: "radiusTR", get: function() { var t = this.cornerRadius.tr; return Math.max(t.x, t.y) }, set: function(t) { Bt(this.cornerRadius.tr, t) } }, { key: "radiusBL", get: function() { var t = this.cornerRadius.bl; return Math.max(t.x, t.y) }, set: function(t) { Bt(this.cornerRadius.bl, t) } }, { key: "radiusBR", get: function() { var t = this.cornerRadius.br; return Math.max(t.x, t.y) }, set: function(t) { Bt(this.cornerRadius.br, t) } }]), r }(),
        Rt = function(t, e, i) { return void 0 === t ? { x: e, y: i } : "number" == typeof t ? { x: t, y: t } : t },
        Bt = function(t, e) { "number" == typeof e ? (t.x = e, t.y = e) : (t.x = Et(e, "x", 0), t.y = Et(e, "y", 0)) },
        It = Phaser.Math.DegToRad,
        Lt = Phaser.Renderer.WebGL.Utils,
        At = Phaser.Renderer.WebGL.Utils,
        jt = Phaser.GameObjects.GetCalcMatrix,
        Dt = Phaser.Renderer.Canvas.SetTransform,
        zt = { renderWebGL: function(t, e, i, n) { e.dirty && (e.updateData(), e.dirty = !1), i.addToRenderList(e); var s = t.pipelines.set(e.pipeline),
                    r = jt(e, i, n),
                    o = s.calcMatrix.copyFrom(r.calc),
                    a = e._displayOriginX,
                    h = e._displayOriginY,
                    l = i.alpha * e.alpha;
                t.pipelines.preBatch(e), e.isFilled && Pt(s, o, e, l, a, h), e.isStroked && Tt(s, e, l, a, h), t.pipelines.postBatch(e) }, renderCanvas: function(t, e, i, n) { e.dirty && (e.updateData(), e.dirty = !1), i.addToRenderList(e); var s = t.currentContext; if (Dt(t, s, e, i, n)) { var r = e._displayOriginX,
                        o = e._displayOriginY,
                        a = e.pathData,
                        h = a.length - 1,
                        l = a[0] - r,
                        u = a[1] - o;
                    s.beginPath(), s.moveTo(l, u), e.closePath || (h -= 2); for (var c = 2; c < h; c += 2) { var d = a[c] - r,
                            f = a[c + 1] - o;
                        s.lineTo(d, f) }
                    s.closePath(), e.isFilled && (Ot(s, e), s.fill()), e.isStroked && (Mt(s, e), s.stroke()), s.restore() } } },
        Ft = Phaser.GameObjects.Shape,
        Yt = Phaser.Utils.Objects.IsPlainObject,
        Xt = Phaser.Utils.Objects.GetValue,
        Wt = Phaser.Geom.Polygon.Earcut,
        Gt = function() { w(y, Ft); var g = T(y);

            function y(t, e, i, n, s, r, o, a) { var h, l, u, c; if (X(this, y), Yt(e)) { var d = e;
                    e = d.x, i = d.y, n = d.width, s = d.height, r = d.radius, o = d.color, a = d.alpha, l = d.strokeColor, u = d.strokeAlpha, c = d.strokeWidth }
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 0); var f = new _t();
                h = g.call(this, t, "rexRoundRectangleShape", f); var p = Xt(r, "radius", r);
                f.setTo(0, 0, n, s, p); var v = Xt(r, "iteration", void 0); return h.setIteration(v), h.setPosition(e, i), void 0 !== o && h.setFillStyle(o, a), void 0 !== l && (void 0 === c && (c = 2), h.setStrokeStyle(c, l, u)), h.updateDisplayOrigin(), h.dirty = !0, h } return k(y, [{ key: "updateData", value: function() { var t = this.geom,
                        e = this.pathData;
                    e.length = 0; var i, n = t.cornerRadius,
                        s = this.iteration + 1; if (i = n.br, Vt(i)) { var r = t.width - i.x,
                            o = t.height - i.y;
                        St(r, o, i.x, i.y, 0, 90, !1, s, e) } else wt(t.width, t.height, e); if (i = n.bl, Vt(i)) { r = i.x, o = t.height - i.y;
                        St(r, o, i.x, i.y, 90, 180, !1, s, e) } else wt(0, t.height, e); if (i = n.tl, Vt(i)) { r = i.x, o = i.y;
                        St(r, o, i.x, i.y, 180, 270, !1, s, e) } else wt(0, 0, e); if (i = n.tr, Vt(i)) { r = t.width - i.x, o = i.y;
                        St(r, o, i.x, i.y, 270, 360, !1, s, e) } else wt(t.width, 0, e); return e.push(e[0], e[1]), this.pathIndexes = Wt(e), this } }, { key: "width", get: function() { return this.geom.width }, set: function(t) { this.resize(t, this.height) } }, { key: "height", get: function() { return this.geom.height }, set: function(t) { this.resize(this.width, t) } }, { key: "setSize", value: function(t, e) { if (void 0 === e && (e = t), this.geom.width === t && this.geom.height === e) return this;
                    this.geom.setSize(t, e), this.updateDisplayOrigin(), this.dirty = !0; var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this } }, { key: "resize", value: function(t, e) { return this.setSize(t, e), this } }, { key: "iteration", get: function() { return this._iteration }, set: function(t) { void 0 !== this._iteration ? this._iteration !== t && (this._iteration = t, this.dirty = !0) : this._iteration = t } }, { key: "setIteration", value: function(t) { return void 0 === t && (t = 6), this.iteration = t, this } }, { key: "radius", get: function() { return this.geom.radius }, set: function(t) { this.geom.setRadius(t), this.updateDisplayOrigin(), this.dirty = !0 } }, { key: "radiusTL", get: function() { return this.geom.radiusTL }, set: function(t) { this.geom.radiusTL = t, this.dirty = !0 } }, { key: "radiusTR", get: function() { return this.geom.radiusTR }, set: function(t) { this.geom.radiusTR = t, this.dirty = !0 } }, { key: "radiusBL", get: function() { return this.geom.radiusBL }, set: function(t) { this.geom.radiusBL = t, this.dirty = !0 } }, { key: "radiusBR", get: function() { return this.geom.radiusBR }, set: function(t) { this.geom.radiusBR = t, this.dirty = !0 } }, { key: "setRadius", value: function(t) { return void 0 === t && (t = 0), this.radius = t, this } }, { key: "setRadiusTL", value: function(t) { return void 0 === t && (t = 0), this.radiusTL = t, this } }, { key: "setRadiusTR", value: function(t) { return void 0 === t && (t = 0), this.radiusTR = t, this } }, { key: "setRadiusBL", value: function(t) { return void 0 === t && (t = 0), this.radiuBL = t, this } }, { key: "setRadiusBR", value: function(t) { return void 0 === t && (t = 0), this.radiusBR = t, this } }, { key: "cornerRadius", get: function() { return this.geom.cornerRadius }, set: function(t) { this.radius = t } }, { key: "setCornerRadius", value: function(t) { return this.setRadius(t) } }]), y }(),
        Vt = function(t) { return 0 !== t.x && 0 !== t.y };
    Object.assign(Gt.prototype, zt), p.register("roundRectangle", function(t, e, i, n, s, r, o) { var a = new Gt(this.scene, t, e, i, n, s, r, o); return this.scene.add.existing(a), a }), j(window, "RexPlugins.UI.RoundRectangle", Gt);

    function Ut(t, e, i, n, s, r, o) { var a, h = t.sys.textures,
            l = t.renderer;
        void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = e.width), void 0 === o && (o = e.height); var u = (a = h.exists(i) ? h.get(i) : h.createCanvas(i, r, o)).getSourceImage();
        u.width !== r && (u.width = r), u.height !== o && (u.height = o); var c = u.getContext("2d");
        c.clearRect(0, 0, r, o), c.drawImage(e, n, s, r, o), l.gl && a && l.canvasToTexture(u, a.source[0].glTexture, !0, 0) } var Ht = Phaser.Renderer.WebGL.Utils,
        Nt = { renderWebGL: function(t, e, i, n) { if (e.dirty && (e.updateTexture(), e.dirty = !1), 0 !== e.width && 0 !== e.height) { i.addToRenderList(e); var s = e.frame,
                        r = s.width,
                        o = s.height,
                        a = Ht.getTintAppendFloatAlpha,
                        h = t.pipelines.set(e.pipeline, e),
                        l = h.setTexture2D(s.glTexture, e);
                    t.pipelines.preBatch(e), h.batchTexture(e, s.glTexture, r, o, e.x, e.y, r / e.resolution, o / e.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, r, o, a(e.tintTopLeft, i.alpha * e._alphaTL), a(e.tintTopRight, i.alpha * e._alphaTR), a(e.tintBottomLeft, i.alpha * e._alphaBL), a(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, 0, 0, i, n, !1, l), t.pipelines.postBatch(e) } }, renderCanvas: function(t, e, i, n) { e.dirty && (e.updateTexture(), e.dirty = !1), 0 !== e.width && 0 !== e.height && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, n)) } },
        Jt = Phaser.Display.Color,
        Kt = { clear: function() { return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this }, fill: function(t) { return this.context.fillStyle = t, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this }, loadFromURL: function(t, e) { var i = this,
                    n = new Image(); return n.onload = function() { i.width !== n.width || i.height !== n.height ? i.resize(n.width, n.height) : i.clear(), i.context.drawImage(n, 0, 0), i.updateTexture(), e && e(), n.onload = null, n.src = "", n.remove() }, n.src = t, this }, loadFromURLPromise: function(i) { var n = this; return new Promise(function(t, e) { n.loadFromURL(i, t) }) }, drawFrame: function(t, e, i, n, s, r) { var o = this.scene.sys.textures.getFrame(t, e); return o && (void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = o.cutWidth), void 0 === r && (r = o.cutHeight), this.context.drawImage(o.source.image, o.cutX, o.cutY, o.cutWidth, o.cutHeight, i, n, s, r), this.dirty = !0), this }, getDataURL: function(t, e) { return this.canvas.toDataURL(t, e) }, getPixel: function(t, e, i) { void 0 === i && (i = new Jt()); var n = this.context.getImageData(t, e, 1, 1); return i.setTo(n.data[0], n.data[1], n.data[2], n.data[3]), i }, setPixel: function(t, e, i, n, s, r) { if ("number" != typeof i) { var o = i;
                    i = o.red, n = o.green, s = o.blue, r = o.alpha }
                void 0 === r && (r = 0 !== i || 0 !== n || 0 !== s ? 255 : 0); var a = this.context.createImageData(1, 1); return a.data[0] = i, a.data[1] = n, a.data[2] = s, a.data[3] = r, this.context.putImageData(a, t, e), this.dirty = !0, this } },
        Zt = { updateTexture: function(t, e) { t && (e ? t.call(e, this.canvas, this.context) : t(this.canvas, this.context)), this.canvas.width === this.frame.width && this.canvas.height === this.frame.height || this.frame.setSize(this.canvas.width, this.canvas.height), this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !1; var i = this.input; return i && !i.customHitArea && (i.hitArea.width = this.width, i.hitArea.height = this.height), this }, generateTexture: function(t, e, i, n, s) { var r = this.canvas; return void 0 === n ? n = r.width : n *= this.resolution, void 0 === s ? s = r.height : s *= this.resolution, Ut(this.scene, r, t, e, i, n, s), this }, loadTexture: function(t, e) { var i = this.scene.sys.textures.getFrame(t, e); return i && (this.width !== i.cutWidth || this.height !== i.cutHeight ? this.setSize(i.cutWidth, i.cutHeight) : this.clear(), this.drawFrame(t, e), this.dirty = !0), this } },
        qt = Phaser.Display.Canvas.CanvasPool,
        $t = Phaser.GameObjects.GameObject,
        Qt = function() { w(a, $t); var o = T(a);

            function a(t, e, i, n, s) { var r; return X(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, "rexCanvas")).renderer = t.sys.game.renderer, r.resolution = 1, r._width = n, r._height = s, n = Math.max(Math.ceil(n * r.resolution), 1), s = Math.max(Math.ceil(s * r.resolution), 1), r.canvas = qt.create(W(r), n, s), r.context = r.canvas.getContext("2d"), r.dirty = !1, r.setPosition(e, i), r.setOrigin(.5, .5), r.initPipeline(), r._crop = r.resetCropObject(), r.texture = t.sys.textures.addCanvas(null, r.canvas, !0), r.frame = r.texture.get(), r.frame.source.resolution = r.resolution, r.renderer && r.renderer.gl && (r.renderer.deleteTexture(r.frame.source.glTexture), r.frame.source.glTexture = null), r.dirty = !0, t.sys.game.events.on("contextrestored", r.onContextRestored, W(r)), r } return k(a, [{ key: "onContextRestored", value: function() { this.dirty = !0 } }, { key: "preDestroy", value: function() { this.scene.sys.game.events.off("contextrestored", this.onContextRestored, this), qt.remove(this.canvas), this.texture.destroy(), this.canvas = null, this.context = null } }, { key: "width", get: function() { return this._width }, set: function(t) { this.setSize(t, this._height) } }, { key: "height", get: function() { return this._height }, set: function(t) { this.setSize(this._width, t) } }, { key: "setSize", value: function(t, e) { return this._width === t && this._height === e || (this._width = t, this._height = e, this.updateDisplayOrigin(), t = Math.max(Math.ceil(t * this.resolution), 1), e = Math.max(Math.ceil(e * this.resolution), 1), this.canvas.width = t, this.canvas.height = e, this.frame.setSize(t, e), this.dirty = !0), this } }, { key: "displayWidth", get: function() { return this.scaleX * this._width }, set: function(t) { this.scaleX = t / this._width } }, { key: "displayHeight", get: function() { return this.scaleY * this._height }, set: function(t) { this.scaleY = t / this._height } }, { key: "setDisplaySize", value: function(t, e) { return this.displayWidth = t, this.displayHeight = e, this } }, { key: "getCanvas", value: function(t) { return t || (this.dirty = !0), this.canvas } }, { key: "getContext", value: function(t) { return t || (this.dirty = !0), this.context } }, { key: "needRedraw", value: function() { return this.dirty = !0, this } }, { key: "resize", value: function(t, e) { return this.setSize(t, e), this } }]), a }(),
        te = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Qt, [te.Alpha, te.BlendMode, te.Crop, te.Depth, te.Flip, te.GetBounds, te.Mask, te.Origin, te.Pipeline, te.ScrollFactor, te.Tint, te.Transform, te.Visible, Nt, Kt, Zt]);

    function ee(t, e, i) { if (null == t) return t; switch (P(t)) {
            case "string":
                return t;
            case "number":
                return "#".concat(se(Math.floor(t).toString(16), 6, "0", 1));
            case "function":
                return t(e, i);
            case "object":
                return t.hasOwnProperty("r") ? t.hasOwnProperty("a") ? "rgba(".concat(t.r, ",").concat(t.g, ",").concat(t.b, ",").concat(t.a, ")") : "rgb(".concat(t.r, ",").concat(t.g, ",").concat(t.b, ")") : t.hasOwnProperty("h") ? t.hasOwnProperty("a") ? "hsla(".concat(t.h, ",").concat(t.s, ",").concat(t.l, ",").concat(t.a, ")") : "hsl(".concat(t.h, ",").concat(t.s, ",").concat(t.l, ")") : t;
            default:
                return t } }

    function ie(t, e, i, n, s, r, o) { var a, h, l, u, c, d = new _t(e, i, n, s, r),
            f = d.minWidth,
            p = d.minHeight,
            v = f <= n ? 1 : n / f,
            g = p <= s ? 1 : s / p,
            y = d.cornerRadius;
        t.save(), t.beginPath(), t.translate(e, i), u = n - (h = (a = y.br).x * v), c = s - (l = a.y * g), t.moveTo(n, c), 0 < h && 0 < l ? ue(t, u, c, h, l, oe, ae, o) : (t.lineTo(n, s), t.lineTo(u, s)), u = h = (a = y.bl).x * v, c = s - (l = a.y * g), t.lineTo(h, s), 0 < h && 0 < l ? ue(t, u, c, h, l, ae, he, o) : (t.lineTo(0, s), t.lineTo(0, c)), u = h = (a = y.tl).x * v, c = l = a.y * g, t.lineTo(0, c), 0 < h && 0 < l ? ue(t, u, c, h, l, he, le, o) : (t.lineTo(0, 0), t.lineTo(u, 0)), u = n - (h = (a = y.tr).x * v), c = l = a.y * g, t.lineTo(u, 0), 0 < h && 0 < l ? ue(t, u, c, h, l, le, oe, o) : (t.lineTo(n, 0), t.lineTo(n, c)), t.closePath(), t.restore() }

    function ne(t, e, i, n, s, r, o, a) { if (null != e || null != i) { var h = t.canvas.width,
                l = t.canvas.height;
            null == i && (n = 0); var u = n / 2;
            h -= n, l -= n,
                function(t, e, i, n, s, r, o, a, h, l, u, c) { if (ie(t, e, i, n, s, r, c), null != o) { var d; if (null != l)(d = u ? t.createLinearGradient(0, 0, n, 0) : t.createLinearGradient(0, 0, 0, s)).addColorStop(0, o), d.addColorStop(1, l), o = d;
                        t.fillStyle = o, t.fill() }
                    null != a && 0 < h && (t.strokeStyle = a, t.lineWidth = h, t.stroke()) }((t.canvas, t.context), u, u, h, l, s, e, i, n, r, o, a) } } var se = Phaser.Utils.String.Pad,
        re = Phaser.Math.DegToRad,
        oe = re(0),
        ae = re(90),
        he = re(180),
        le = re(270),
        ue = function(t, e, i, n, s, r, o, a) { if (null == a) t.ellipse(e, i, n, s, 0, r, o);
            else
                for (var h, l, u, c = (o - r) / (a += 1), d = 0; d <= a; d++) u = r + c * d, h = e + n * Math.cos(u), l = i + s * Math.sin(u), t.lineTo(h, l) },
        ce = Phaser.Utils.Objects.GetValue,
        de = function() { w(v, Qt); var p = T(v);

            function v(t, e, i, n, s, r, o, a, h, l, u) { var c;
                X(this, v), (c = p.call(this, t, e, i, n, s)).type = "rexRoundRectangleCanvas"; var d = ce(r, "radius", r),
                    f = ce(r, "iteration", void 0); return c.setRadius(d), c.setIteration(f), c.setFillStyle(o, l, u), c.setStrokeStyle(a, h), c } return k(v, [{ key: "radius", get: function() { return this._radius }, set: function(t) { this.dirty |= this._radius != t, this._radius = t } }, { key: "setRadius", value: function(t) { return this.radius = t, this } }, { key: "iteration", get: function() { return this._iteration }, set: function(t) { this.dirty |= this._iteration != t, this._iteration = t } }, { key: "setIteration", value: function(t) { return this.iteration = t, this } }, { key: "fillStyle", get: function() { return this._fillStyle }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty |= this._fillStyle != t, this._fillStyle = t } }, { key: "fillColor2", get: function() { return this._fillColor2 }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty |= this._fillColor2 != t, this._fillColor2 = t } }, { key: "isHorizontalGradient", get: function() { return this._isHorizontalGradient }, set: function(t) { this.dirty |= this._isHorizontalGradient != t, this._isHorizontalGradient = t } }, { key: "setFillStyle", value: function(t, e, i) { return void 0 === i && (i = !0), this.fillStyle = t, this.fillColor2 = e, this.isHorizontalGradient = i, this } }, { key: "strokeStyle", get: function() { return this._strokeStyle }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty |= this._strokeStyle != t, this._strokeStyle = t } }, { key: "lineWidth", get: function() { return this._lineWidth }, set: function(t) { this.dirty |= this._lineWidth != t, this._lineWidth = t } }, { key: "setStrokeStyle", value: function(t, e) { return this.strokeStyle = t, this.lineWidth = e, this } }, { key: "updateTexture", value: function() { return this.clear(),
                        function() { ne(this, this.fillStyle, this.strokeStyle, this.lineWidth, this.radius, this.fillColor2, this.isHorizontalGradient, this.iteration) }.call(this), O(C(v.prototype), "updateTexture", this).call(this), this } }]), v }();
    p.register("roundRectangleCanvas", function(t, e, i, n, s, r, o, a, h, l) { var u = new de(this.scene, t, e, i, n, s, r, o, a, h, l); return this.scene.add.existing(u), u }), j(window, "RexPlugins.UI.RoundRectangleCanvas", de); var fe = Phaser.Renderer.WebGL.Utils,
        pe = { renderWebGL: function(t, e, i, n) { if (0 !== e.width && 0 !== e.height) { i.addToRenderList(e); var s = e.frame,
                        r = s.width,
                        o = s.height,
                        a = fe.getTintAppendFloatAlpha,
                        h = t.pipelines.set(e.pipeline, e),
                        l = h.setTexture2D(s.glTexture, e);
                    t.pipelines.preBatch(e), h.batchTexture(e, s.glTexture, r, o, e.x, e.y, r / e.style.resolution, o / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, r, o, a(e.tintTopLeft, i.alpha * e._alphaTL), a(e.tintTopRight, i.alpha * e._alphaTR), a(e.tintBottomLeft, i.alpha * e._alphaBL), a(e.tintBottomRight, i.alpha * e._alphaBR), e.tintFill, 0, 0, i, n, !1, l), t.pipelines.postBatch(e) } }, renderCanvas: function(t, e, i, n) { 0 !== e.width && 0 !== e.height && (i.addToRenderList(e), t.batchSprite(e, e.frame, i, n)) } },
        ve = Phaser.Display.Canvas.CanvasPool,
        ge = Phaser.GameObjects.GameObject,
        ye = function() { w(e, ge); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "setStyle", value: function(t) { return this.style.setStyle(t) } }, { key: "setFont", value: function(t) { return this.style.setFont(t) } }, { key: "setFontFamily", value: function(t) { return this.style.setFontFamily(t) } }, { key: "setFontSize", value: function(t) { return this.style.setFontSize(t) } }, { key: "setFontStyle", value: function(t) { return this.style.setFontStyle(t) } }, { key: "setTestString", value: function(t) { return this.style.setTestString(t) } }, { key: "setFixedSize", value: function(t, e) { return this.style.setFixedSize(t, e) } }, { key: "setBackgroundColor", value: function(t, e, i) { return this.style.setBackgroundColor(t, e, i) } }, { key: "setBackgroundStrokeColor", value: function(t, e) { return this.style.setBackgroundStrokeColor(t, e) } }, { key: "setBackgroundCornerRadius", value: function(t, e) { return this.style.setBackgroundCornerRadius(t, e) } }, { key: "setFill", value: function(t) { return this.style.setFill(t) } }, { key: "setColor", value: function(t) { return this.style.setColor(t) } }, { key: "setStroke", value: function(t, e) { return this.style.setStroke(t, e) } }, { key: "setShadow", value: function(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r) } }, { key: "setShadowOffset", value: function(t, e) { return this.style.setShadowOffset(t, e) } }, { key: "setShadowColor", value: function(t) { return this.style.setShadowColor(t) } }, { key: "setShadowBlur", value: function(t) { return this.style.setShadowBlur(t) } }, { key: "setShadowStroke", value: function(t) { return this.style.setShadowStroke(t) } }, { key: "setShadowFill", value: function(t) { return this.style.setShadowFill(t) } }, { key: "setWrapMode", value: function(t) { return this.style.setWrapMode(t) } }, { key: "setWrapWidth", value: function(t) { return this.style.setWrapWidth(t) } }, { key: "setWordWrapWidth", value: function(t) { return this.style.setWrapWidth(t) } }, { key: "setAlign", value: function(t) { return this.style.setHAlign(t) } }, { key: "setHAlign", value: function(t) { return this.style.setHAlign(t) } }, { key: "setVAlign", value: function(t) { return this.style.setVAlign(t) } }, { key: "setLineSpacing", value: function(t) { return this.style.setLineSpacing(t) } }, { key: "lineSpacing", get: function() { return this.style.lineSpacing }, set: function(t) { this.setLineSpacing(t) } }, { key: "setXOffset", value: function(t) { return this.style.setXOffset(t) } }, { key: "setMaxLines", value: function(t) { return this.style.setMaxLines(t) } }, { key: "setResolution", value: function(t) { return this.style.setResolution(t) } }, { key: "getTextMetrics", value: function() { return this.style.getTextMetrics() } }, { key: "setTextMetrics", value: function(t, e) { return this.style.setTextMetrics(t, e) } }, { key: "measureTextMargins", value: function(t, e) { return function(t, e, i) { void 0 === i && (i = {}); var n = ve.create(this),
                            s = n.getContext("2d");
                        t.syncFont(n, s); var r = s.measureText(e),
                            o = Math.ceil(r.width * t.baselineX),
                            a = o,
                            h = 2 * a; if (a = a * t.baselineY | 0, n.width = o, n.height = h, s.fillStyle = "#f00", s.fillRect(0, 0, o, h), s.font = t._font, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText(t.testString, 0, a), (i.left = 0) === o || 0 == h || !s.getImageData(0, 0, o, h)) return ve.remove(n), i; for (var l = s.getImageData(0, 0, o, h).data, u = !1, c = 0; c < o; c++) { for (var d = 0; d < h; d++) { if (255 !== l[4 * (d * o + c)]) { i.left = c, u = !0; break } } if (u) break } return ve.remove(n), i }(this.style, t, e) } }]), e }(),
        me = Phaser.GameObjects.Components;
    Phaser.Class.mixin(ye, [me.Alpha, me.BlendMode, me.ComputedSize, me.Crop, me.Depth, me.Flip, me.GetBounds, me.Mask, me.Origin, me.Pipeline, me.ScrollFactor, me.Tint, me.Transform, me.Visible, pe]);

    function ke(t) { var e = we.create(this),
            i = e.getContext("2d");
        t.syncFont(e, i); var n = i.measureText(t.testString); if ("actualBoundingBoxAscent" in n) { var s = n.actualBoundingBoxAscent,
                r = n.actualBoundingBoxDescent,
                o = { ascent: s, descent: r, fontSize: s + r }; return we.remove(e), o } var a = Math.ceil(n.width * t.baselineX),
            h = a,
            l = 2 * h; if (h = h * t.baselineY | 0, e.width = a, e.height = l, i.fillStyle = "#f00", i.fillRect(0, 0, a, l), i.font = t._font, i.textBaseline = "alphabetic", i.fillStyle = "#000", i.fillText(t.testString, 0, h), o = { ascent: 0, descent: 0, fontSize: 0 }, !i.getImageData(0, 0, a, l)) return o.ascent = h, o.descent = h + 6, o.fontSize = o.ascent + o.descent, we.remove(e), o; var u, c, d = i.getImageData(0, 0, a, l).data,
            f = d.length,
            p = 4 * a,
            v = 0,
            g = !1; for (u = 0; u < h; u++) { for (c = 0; c < p; c += 4)
                if (255 !== d[v + c]) { g = !0; break }
            if (g) break;
            v += p } for (o.ascent = h - u, v = f - p, g = !1, u = l; h < u; u--) { for (c = 0; c < p; c += 4)
                if (255 !== d[v + c]) { g = !0; break }
            if (g) break;
            v -= p } return o.descent = u - h, o.fontSize = o.ascent + o.descent, we.remove(e), o }

    function be(t, e) { var i = Array.isArray(t); if (void 0 === e ? e = i ? [] : {} : at(e), i) { e.length = t.length; for (var n = 0, s = t.length; n < s; n++) e[n] = t[n] } else
            for (var r in t) e[r] = t[r]; return e }

    function xe(t, e, i, n, s, r) { n <= 0 && (i = ei); var o = []; if (!t || !t.length) return o; for (var a, h, l, u = i === ei, c = i === ii, d = t.split(si), f = 0, p = d.length; f < p; f++)
            if (a = d[f], l = f === p - 1 ? $e : Qe, u) { var v = e(a);
                o.push(r.getLine(a, v, l)) } else { var g, y, m, k, b; if (h = 0 === f ? n - s : n, a.length <= 100)
                    if ((v = e(a)) <= h) { o.push(r.getLine(a, v, l)); continue }
                c ? (y = "" === (g = a.split(" "))[g.length - 1]) && --g.length : g = a; for (var x, C = "", w = 0, S = c ? e(" ") : void 0, P = 0, T = g.length; P < T; P++)
                    if (k = e(m = g[P]), b = P === T - 1, !c || b && !y || (m += " ", k += S), c && n < k) { "" !== C ? o.push(r.getLine(C, w, ti)) : 0 === P && 0 < s && o.push(r.getLine("", 0, ti)), o.push.apply(o, M(xe(m, e, ni, n, 0, r))); var O = o.pop();
                        C = O.text, w = O.width, r.freeLine(O), " " === C && (C = "", w = 0) } else h < (x = w + k) ? (o.push(r.getLine(C, w, ti)), C = m, w = k, h = n) : (C += m, w = x), b && o.push(r.getLine(C, w, l)) }
        return o } var Ce = { backgroundColor: ["backgroundColor", null, ee], backgroundColor2: ["backgroundColor2", null, ee], backgroundHorizontalGradient: ["backgroundHorizontalGradient", !0, null], backgroundStrokeColor: ["backgroundStrokeColor", null, ee], backgroundStrokeLineWidth: ["backgroundStrokeLineWidth", 2, null], backgroundCornerRadius: ["backgroundCornerRadius", 0, null], backgroundCornerIteration: ["backgroundCornerIteration", null, null], fontFamily: ["fontFamily", "Courier", null], fontSize: ["fontSize", "16px", null], fontStyle: ["fontStyle", "", null], color: ["color", "#fff", ee], stroke: ["stroke", "#fff", ee], strokeThickness: ["strokeThickness", 0, null], shadowOffsetX: ["shadow.offsetX", 0, null], shadowOffsetY: ["shadow.offsetY", 0, null], shadowColor: ["shadow.color", "#000", ee], shadowBlur: ["shadow.blur", 0, null], shadowStroke: ["shadow.stroke", !1, null], shadowFill: ["shadow.fill", !1, null], underlineColor: ["underline.color", "#000", ee], underlineThickness: ["underline.thickness", 0, null], underlineOffset: ["underline.offset", 0, null], halign: ["halign", "left", null], valign: ["valign", "top", null], maxLines: ["maxLines", 0, null], fixedWidth: ["fixedWidth", 0, null], fixedHeight: ["fixedHeight", 0, null], resolution: ["resolution", 0, null], lineSpacing: ["lineSpacing", 0, null], xOffset: ["xOffset", 0, null], rtl: ["rtl", !1, null], testString: ["testString", "|MÃ‰qgy", null], baselineX: ["baselineX", 1.2, null], baselineY: ["baselineY", 1.4, null], wrapMode: ["wrap.mode", 0, null], wrapWidth: ["wrap.width", 0, null], wrapCallback: ["wrap.callback", null], wrapCallbackScope: ["wrap.callbackScope", null] },
        we = Phaser.Display.Canvas.CanvasPool,
        Se = 0,
        Pe = 1,
        Te = 2,
        Oe = 0,
        Me = 1,
        Ee = 2,
        _e = /(?:\r\n|\r|\n)/,
        Re = Phaser.Utils.Objects.GetAdvancedValue,
        Be = Phaser.Utils.Objects.GetValue,
        Ie = function() {
            function n(t, e, i) { X(this, n), this.parent = t, void 0 === i && (i = Ce), this.propertyMap = i, this.backgroundColor, this.backgroundColor2, this.backgroundHorizontalGradient, this.backgroundStrokeColor, this.backgroundStrokeLineWidth, this.backgroundCornerRadius, this.backgroundCornerIteration, this.fontFamily, this.fontSize, this.fontStyle, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.underlineColor, this.underlineThickness, this.underlineOffset, this.halign, this.valign, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.lineSpacing, this.xOffset, this.rtl, this.testString, this.baselineX, this.baselineY, this.wrapMode, this.wrapWidth, this.wrapCallback, this.wrapCallbackScope, this._font, this.setStyle(e, !1, !0) } return k(n, [{ key: "isWrapFitMode", get: function() { return 0 < this.fixedWidth && this.wrapMode !== Oe && 0 === this.wrapWidth } }, { key: "setStyle", value: function(t, e, i) { if (void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty("wrap")) { var n = t.wrap; if (n.hasOwnProperty("mode")) { var s = n.mode; "string" == typeof s && (n.mode = Le[s]) } else n.hasOwnProperty("width") && (n.mode = 1) }
                    t && t.rtl && i && !t.hasOwnProperty("halign") && (t.halign = "right"), t && t.hasOwnProperty("fontSize") && "number" == typeof t.fontSize && (t.fontSize = t.fontSize.toString() + "px"); var r = this.propertyMap; for (var o in r) { var a = r[o],
                            h = a[0],
                            l = i ? a[1] : this[o],
                            u = a[2]; if ("wrapCallback" === o || "wrapCallbackScope" === o) this[o] = Be(t, h, l);
                        else { var c = Re(t, h, l);
                            u && (c = u(c)), this[o] = c } } var d = Be(t, "font", null);
                    this._font = null === d ? this.fontStyle + " " + this.fontSize + " " + this.fontFamily : d; var f = Be(t, "fill", null);
                    null !== f && (this.color = ee(f)); var p = Be(t, "metrics", !1); return p ? this.metrics = { ascent: Be(p, "ascent", 0), descent: Be(p, "descent", 0), fontSize: Be(p, "fontSize", 0) } : !e && this.metrics || (this.metrics = ke(this)), e ? this.parent.updateText() : this.parent } }, { key: "syncFont", value: function(t, e) { e.font = this._font } }, { key: "syncStyle", value: function(t, e) { e.textBaseline = "alphabetic", e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = "round", e.lineJoin = "round" } }, { key: "syncShadow", value: function(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0) } }, { key: "update", value: function(t) { return t && (this._font = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim(), this.metrics = ke(this)), this.parent.updateText(t) } }, { key: "buildFont", value: function() { var t = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim(); return t !== this._font && (this._font = t), this } }, { key: "setFont", value: function(t) { return "string" == typeof t ? (this.fontFamily = t, this.fontSize = "", this.fontStyle = "") : (this.fontFamily = Be(t, "fontFamily", "Courier"), this.fontSize = Be(t, "fontSize", "16px"), this.fontStyle = Be(t, "fontStyle", "")), this.update(!0) } }, { key: "setFontFamily", value: function(t) { return this.fontFamily = t, this.update(!0) } }, { key: "setFontStyle", value: function(t) { return this.fontStyle = t, this.update(!0) } }, { key: "setFontSize", value: function(t) { return "number" == typeof t && (t = t.toString() + "px"), this.fontSize = t, this.update(!0) } }, { key: "setTestString", value: function(t) { return this.testString = t, this.update(!0) } }, { key: "setFixedSize", value: function(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(this.isWrapFitMode) } }, { key: "setResolution", value: function(t) { return this.resolution = t, this.update(!1) } }, { key: "setLineSpacing", value: function(t) { return this.lineSpacing = t, this.update(!1) } }, { key: "setXOffset", value: function(t) { return this.xOffset = t, this.update(!1) } }, { key: "setBackgroundColor", value: function(t, e, i) { return void 0 === i && (i = !0), this.backgroundColor = ee(t, this.parent.canvas, this.parent.context), this.backgroundColor2 = ee(e, this.parent.canvas, this.parent.context), this.backgroundHorizontalGradient = i, this.update(!1) } }, { key: "setBackgroundStrokeColor", value: function(t, e) { return this.backgroundStrokeColor = ee(t, this.parent.canvas, this.parent.context), this.backgroundStrokeLineWidth = e, this.update(!1) } }, { key: "setBackgroundCornerRadius", value: function(t, e) { return this.backgroundCornerRadius = t, this.backgroundCornerIteration = e, this.update(!1) } }, { key: "setFill", value: function(t) { return this.color = ee(t, this.parent.canvas, this.parent.context), this.update(!1) } }, { key: "setColor", value: function(t) { return this.color = ee(t, this.parent.canvas, this.parent.context), this.update(!1) } }, { key: "setStroke", value: function(t, e) { return void 0 === t ? this.strokeThickness = 0 : (void 0 === e && (e = this.strokeThickness), this.stroke = ee(t, this.parent.canvas, this.parent.context), this.strokeThickness = e), this.update(!0) } }, { key: "setShadow", value: function(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "#000"), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = ee(i, this.parent.canvas, this.parent.context), this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1) } }, { key: "setShadowOffset", value: function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1) } }, { key: "setShadowColor", value: function(t) { return void 0 === t && (t = "#000"), this.shadowColor = ee(t, this.parent.canvas, this.parent.context), this.update(!1) } }, { key: "setShadowBlur", value: function(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1) } }, { key: "setShadowStroke", value: function(t) { return this.shadowStroke = t, this.update(!1) } }, { key: "setShadowFill", value: function(t) { return this.shadowFill = t, this.update(!1) } }, { key: "setUnderline", value: function(t, e, i) { return void 0 === t && (t = "#000"), void 0 === e && (e = 0), void 0 === i && (i = 0), this.underlineColor = ee(t, this.parent.canvas, this.parent.context), this.underlineThickness = e, this.underlineOffset = i, this.update(!1) } }, { key: "setUnderlineColor", value: function(t) { return void 0 === t && (t = "#000"), this.underlineColor = ee(t, this.parent.canvas, this.parent.context), this.update(!1) } }, { key: "setUnderlineThickness", value: function(t) { return void 0 === t && (t = 0), this.underlineThickness = t, this.update(!1) } }, { key: "setUnderlineOffset", value: function(t) { return void 0 === t && (t = 0), this.underlineOffset = t, this.update(!1) } }, { key: "setWrapMode", value: function(t) { return "string" == typeof t && (t = Le[t.toLowerCase()] || 0), this.wrapMode = t, this.update(!0) } }, { key: "setWrapWidth", value: function(t) { return this.wrapWidth = t, this.update(!1) } }, { key: "setAlign", value: function(t, e) { return void 0 === t && (t = "left"), void 0 === e && (e = "top"), this.halign = t, this.valign = e, this.update(!1) } }, { key: "setHAlign", value: function(t) { return void 0 === t && (t = "left"), this.halign = t, this.update(!1) } }, { key: "setVAlign", value: function(t) { return void 0 === t && (t = "top"), this.valign = t, this.update(!1) } }, { key: "setMaxLines", value: function(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1) } }, { key: "getTextMetrics", value: function() { var t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize } } }, { key: "setTextMetrics", value: function(t, e) { return this.metrics.ascent = t.ascent, this.metrics.descent = t.descent, this.metrics.fontSize = t.fontSize, e && ("string" == typeof e ? (this.fontFamily = e, this.fontSize = "", this.fontStyle = "") : (this.fontFamily = Be(e, "fontFamily", this.fontFamily), this.fontSize = Be(e, "fontSize", this.fontSize), this.fontStyle = Be(e, "fontStyle", this.fontStyle))), this.parent.updateText(!0) } }, { key: "lineHeight", get: function() { return this.metrics.fontSize + this.strokeThickness + this.lineSpacing } }, { key: "toJSON", value: function() { var t = {},
                        e = this.propertyMap; for (var i in e) t[i] = this[i]; return t.metrics = this.getTextMetrics(), t } }, { key: "destroy", value: function() { this.parent = void 0 } }]), n }(),
        Le = { none: Oe, word: Me, char: Ee, character: Ee },
        Ae = { draw: function(t, e, i, n) { var s = this.penManager;
                this.hitAreaManager.clear(); var r = this.context;
                r.save(); var o = this.defaultStyle;
                this.clear(), ne(this, o.backgroundColor, o.backgroundStrokeColor, o.backgroundStrokeLineWidth, o.backgroundCornerRadius, o.backgroundColor2, o.backgroundHorizontalGradient, o.backgroundCornerIteration), t += this.startXOffset, e += this.startYOffset; var a, h, l, u, c, d, f = o.halign,
                    p = o.valign,
                    v = o.lineHeight,
                    g = s.lines,
                    y = g.length,
                    m = o.maxLines;
                u = (l = 0 < m && m < y ? (h = m, "center" === p ? Math.floor((y - h) / 2) : "bottom" === p ? y - h : 0) : (h = y, 0)) + h; var k = this.rtl,
                    b = k ? this.parent.width : void 0;
                d = "center" === p ? Math.max((n - h * v) / 2, 0) : "bottom" === p ? Math.max(n - h * v - 2, 0) : 0, d += e; for (var x = l; x < u; x++)
                    if (0 !== (a = s.getLineWidth(x))) { for (var C = g[x], w = C.length, S = f, P = 0; P < w; P++) { var T = C[P].prop.align; if (void 0 !== T) { S = T; break } }
                        c = "center" === S ? (i - a) / 2 : "right" === S ? k ? 0 : i - a : k ? i - a : 0, c += t; for (P = 0; P < w; P++) this.drawPen(C[P], c, d, b) }
                r.restore() }, drawPen: function(t, e, i, n) { e += t.x, i += t.y + (t.prop.y || 0), void 0 !== n && (e = n - e); var s = this.canvas,
                    r = this.context;
                r.save(); var o = this.parser.propToContextStyle(this.defaultStyle, t.prop);
                o.buildFont(), o.syncFont(s, r), o.syncStyle(s, r), 0 < o.underlineThickness && 0 < t.width && this.drawUnderline(e, i, t.width, o), t.isTextPen && this.drawText(e, i, t.text, o), t.isImagePen && this.drawImage(e, i, t.prop.img, o), r.restore(), t.hasAreaMarker && 0 < t.width && this.hitAreaManager.add(t.prop.area, e, i - this.startYOffset, t.width, this.defaultStyle.lineHeight) }, clear: function() { var t = this.canvas;
                this.context.clearRect(0, 0, t.width, t.height) }, drawUnderline: function(t, e, i, n) { e += n.underlineOffset - n.underlineThickness / 2, this.autoRound && (t = Math.round(t), e = Math.round(e)); var s = this.context,
                    r = s.lineCap;
                s.lineCap = "butt", s.strokeStyle = n.underlineColor, s.lineWidth = n.underlineThickness, s.beginPath(), s.moveTo(t, e), s.lineTo(t + i, e), s.stroke(), s.lineCap = r }, drawText: function(t, e, i, n) { this.autoRound && (t = Math.round(t), e = Math.round(e)); var s = this.context;
                n.stroke && "none" !== n.stroke && 0 < n.strokeThickness && (n.syncShadow(s, n.shadowStroke), s.strokeText(i, t, e)), n.color && "none" !== n.color && (n.syncShadow(s, n.shadowFill), s.fillText(i, t, e)) }, drawImage: function(t, e, i) { e -= this.startYOffset, this.parent.imageManager.draw(i, this.context, t, e, this.autoRound) } },
        je = Phaser.Utils.Objects.GetValue,
        De = Se,
        ze = Pe,
        Fe = function() {
            function e(t) { X(this, e), this.prop = {}, this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function(t) { this.text = je(t, "text", ""), this.x = je(t, "x", 0), this.y = je(t, "y", 0), this.width = je(t, "width", 0); var e = je(t, "prop", null);
                    null === e && (e = {}), this.prop = e, this.newLineMode = je(t, "newLineMode", 0), this.startIndex = je(t, "startIndex", 0) } }, { key: "plainText", get: function() { var t = this.text; return this.newLineMode === ze && (t += "\n"), t } }, { key: "wrapText", get: function() { var t = this.text; return this.newLineMode !== De && (t += "\n"), t } }, { key: "rawTextLength", get: function() { var t = this.text.length; return this.newLineMode === ze && (t += 1), t } }, { key: "endIndex", get: function() { return this.startIndex + this.rawTextLength } }, { key: "lastX", get: function() { return this.x + this.width } }, { key: "isTextPen", get: function() { return "" !== this.text } }, { key: "isImagePen", get: function() { return !!this.prop.img } }, { key: "hasAreaMarker", get: function() { return !!this.prop.area } }]), e }(),
        Ye = Phaser.Utils.Objects.GetFastValue,
        Xe = Se,
        We = Te,
        Ge = function() {
            function a(t) { X(this, a), this.pens = [], this.lines = [], this.maxLinesWidth = void 0, this.pensPool = t.pensPool, this.linesPool = t.linesPool, this.tagToText = Ye(t, "tagToText", _), this.tagToTextScope = Ye(t, "tagToTextScope", void 0) } return k(a, [{ key: "destroy", value: function() { this.clear(), this.tagToText = void 0, this.tagToTextScope = void 0 } }, { key: "clear", value: function() { for (var t = 0, e = this.lines.length; t < e; t++) this.lines[t].length = 0;
                    this.pensPool.pushMultiple(this.pens), this.linesPool.pushMultiple(this.lines), this.maxLinesWidth = void 0 } }, { key: "addTextPen", value: function(t, e, i, n, s, r) { var o = this.pensPool.pop(); return null == o && (o = new Fe()), Ve.text = t, Ve.x = e, Ve.y = i, Ve.width = n, Ve.prop = s, Ve.newLineMode = r, o.resetFromJSON(Ve), this.addPen(o), this } }, { key: "addImagePen", value: function(t, e, i, n) { return this.addTextPen("", t, e, i, n, Xe), this } }, { key: "addNewLinePen", value: function() { var t = this.lastPen,
                        e = t ? t.lastX : 0,
                        i = t ? t.y : 0,
                        n = t ? be(t.prop) : null; return this.addTextPen("", e, i, 0, n, We), this } }, { key: "addPen", value: function(t) { var e = this.lastPen;
                    t.startIndex = null == e ? 0 : e.endIndex, this.pens.push(t); var i = this.lastLine;
                    null == i && (i = this.linesPool.pop() || [], this.lines.push(i)), i.push(t), t.newLineMode !== Xe && (i = this.linesPool.pop() || [], this.lines.push(i)), this.maxLinesWidth = void 0 } }, { key: "clone", value: function(t) { null == t && (t = new a()), t.clear(); for (var e = 0, i = this.lines.length; e < i; e++)
                        for (var n = this.lines[e], s = 0, r = n.length; s < r; s++) { var o = n[s];
                            t.addPen(o.text, o.x, o.y, o.width, be(o.prop), o.newLineMode) }
                    return t } }, { key: "lastPen", get: function() { return this.pens[this.pens.length - 1] } }, { key: "lastLine", get: function() { return this.lines[this.lines.length - 1] } }, { key: "getLineStartIndex", value: function(t) { if (t >= this.lines.length) return this.getLineEndIndex(t); var e = this.lines[t]; return e && e[0] ? e[0].startIndex : 0 } }, { key: "getLineEndIndex", value: function(t) { t >= this.lines.length && (t = this.lines.length - 1); var e, i, n = !1; for (e = t; 0 <= e && !(n = null != (i = this.lines[e]) && 0 < i.length); e--); return n ? i[i.length - 1].endIndex : 0 } }, { key: "getLineWidth", value: function(t) { var e = this.lines[t]; if (!e) return 0; var i = e[e.length - 1]; return null == i ? 0 : i.lastX } }, { key: "getMaxLineWidth", value: function() { if (void 0 !== this.maxLinesWidth) return this.maxLinesWidth; for (var t, e = 0, i = 0, n = this.lines.length; i < n; i++) e < (t = this.getLineWidth(i)) && (e = t); return this.maxLinesWidth = e } }, { key: "getLineWidths", value: function() { for (var t = [], e = 0, i = this.lines.length; e < i; e++) t.push(this.getLineWidth(e)); return t } }, { key: "linesCount", get: function() { return this.lines.length } }, { key: "plainText", get: function() { for (var t = "", e = this.pens, i = 0, n = e.length; i < n; i++) t += e[i].plainText; return t } }, { key: "rawTextLength", get: function() { for (var t = 0, e = this.pens, i = 0, n = this.pens.length; i < n; i++) t += e[i].rawTextLength; return t } }, { key: "getSliceTagText", value: function(t, e, i) { if (void 0 === t && (t = 0), void 0 === e) { var n = this.lastPen; if (null == n) return "";
                        e = n.endIndex }
                    void 0 === i && (i = !1); for (var s, r, o, a, h, l, u = "", c = 0, d = this.pens.length; c < d && ((a = (s = this.pens[c]).endIndex) <= t || (s = this.pens[c], r = i ? s.wrapText : s.plainText, h = s.prop, t <= (o = s.startIndex) && a <= e || (r = r.substring(t - o, e - o)), this.tagToTextScope ? u += this.tagToText.call(this.tagToTextScope, r, h, l) : u += this.tagToText(r, h, l), l = h, !(e <= a))); c++); return u } }, { key: "length", get: function() { return this.lines.length }, set: function() { this.clear() } }]), a }(),
        Ve = {},
        Ue = Phaser.Geom.Rectangle,
        He = new N(),
        Ne = function() {
            function t() { X(this, t), this.hitAreas = [] } return k(t, [{ key: "destroy", value: function() { this.clear() } }, { key: "clear", value: function() { return He.pushMultiple(this.hitAreas), this } }, { key: "add", value: function(t, e, i, n, s) { var r = He.pop(); return null === r ? r = new Ue(e, i, n, s) : r.setTo(e, i, n, s), r.key = t, this.hitAreas.push(r), this } }, { key: "getFirst", value: function(t, e) { for (var i = 0, n = this.hitAreas.length; i < n; i++) { var s = this.hitAreas[i]; if (s.contains(t, e)) return s } return null } }, { key: "drawBounds", value: function(t, e, i) { void 0 === e && (e = 16777215), i && t.save().scaleCanvas(i.scaleX, i.scaleY).rotateCanvas(i.rotation).translateCanvas(i.x, i.y); for (var n = 0, s = this.hitAreas.length; n < s; n++) { var r = this.hitAreas[n];
                        t.lineStyle(1, e).strokeRect(r.x, r.y, r.width, r.height) } return i && t.restore(), this } }]), t }(),
        Je = function(t, e, i, n) { var s = this.hitAreaManager.getFirst(e, i);
            null !== s && qe.call(this, "areadown", s.key, t, e, i, n) },
        Ke = function(t, e, i, n) { var s = this.hitAreaManager.getFirst(e, i);
            null !== s && qe.call(this, "areaup", s.key, t, e, i, n) },
        Ze = function(t, e, i, n) { if (null !== e) { var s = this.hitAreaManager.getFirst(e, i),
                    r = s ? s.key : null;
                this.lastHitAreaKey !== r && (null !== this.lastHitAreaKey && qe.call(this, "areaout", this.lastHitAreaKey, t, e, i, n), null !== r && qe.call(this, "areaover", r, t, e, i, n), this.lastHitAreaKey = r) } else null !== this.lastHitAreaKey && (qe.call(this, "areaout", this.lastHitAreaKey, t, e, i, n), this.lastHitAreaKey = null) },
        qe = function(t, e, i, n, s, r) { this.parent.emit("".concat(t, "-").concat(e), i, n, s, r), this.parent.emit(t, e, i, n, s, r) },
        $e = Se,
        Qe = Pe,
        ti = Te,
        ei = Oe,
        ii = Me,
        ni = Ee,
        si = _e,
        ri = Phaser.Utils.Objects.GetValue,
        oi = Oe,
        ai = Se,
        hi = function() {
            function i(t) { X(this, i), this.parent = t.parent, this.context = ri(t, "context", null), this.canvas = this.context.canvas, this.parser = ri(t, "parser", null), this.defaultStyle = ri(t, "style", null), this.autoRound = !0, this.pensPool = t.pensPool, this.linesPool = t.linesPool, this.wrapTextLinesPool = t.wrapTextLinesPool, this.penManager = this.newPenManager(), this._tmpPenManager = null, this.hitAreaManager = new Ne(), this.lastHitAreaKey = null; var e = this.context;
                this.getTextWidth = function(t) { return e.measureText(t).width } } return k(i, [{ key: "destroy", value: function() { this.context = void 0, this.canvas = void 0, this.parser = void 0, this.defaultStyle = void 0, this.penManager && (this.penManager.destroy(), this.penManager = void 0), this._tmpPenManager && (this._tmpPenManager.destroy(), this._tmpPenManager = void 0), this.hitAreaManager && (this.hitAreaManager.destroy(), this.hitAreaManager = void 0), this.pensPool = void 0, this.linesPool = void 0, this.wrapTextLinesPool = void 0 } }, { key: "updatePenManager", value: function(t, e, i, n, s) { if (void 0 === s && (s = this.penManager), s.clear(), "" === t) return s; var r = this.parent.style; if (r.isWrapFitMode) { var o = this.parent.padding;
                        i = r.fixedWidth - o.left - o.right }

                    function a(t) { return p.measureText(t).width } for (var h, l, u, c, d, f = this.canvas, p = this.context, v = 0, g = 0, y = r.wrapCallback, m = r.wrapCallbackScope, k = !0, b = this.parser.splitText(t), x = this.wrapTextLinesPool, C = 0, w = b.length; C < w; C++)
                        if (h = (c = this.parser.tagTextToProp(b[C], l)).plainText, (l = c.prop).img) { var S = this.imageManager.getOuterWidth(l.img);
                            0 < i && e !== oi && i < v + S && (s.addNewLinePen(), g += n, v = 0), s.addImagePen(v, g, S, be(l)), v += S } else if ("" !== h) { if (p.save(), (u = this.parser.propToContextStyle(this.defaultStyle, l)).buildFont(), u.syncFont(f, p), u.syncStyle(f, p), y) { "string" == typeof(d = y.call(m, h, a, i, v)) && (d = d.split("\n")); for (var P = 0, T = d.length; P < T; P++) "string" == typeof(O = d[P]) ? d[P] = x.getLine(O, a(O), P < T - 1 ? 2 : 0) : k = !1 } else d = xe(h, a, e, i, v, x); var O; for (P = 0, T = d.length; P < T; P++) O = d[P], s.addTextPen(O.text, v, g, O.width, be(l), O.newLineMode), O.newLineMode !== ai ? (v = 0, g += n) : v += O.width;
                        k && x.freeLines(d), d = null, p.restore() } for (C = 0, w = this.lines.length; C < w; C++) { var M = this.lines[C],
                            E = M[M.length - 1];
                        E && (E.width += this.parser.getStrokeThinkness(this.defaultStyle, E.prop)) } return s } }, { key: "startXOffset", get: function() { var t = this.defaultStyle; return t.strokeThickness / 2 + t.xOffset } }, { key: "startYOffset", get: function() { var t = this.defaultStyle; return t.strokeThickness / 2 + t.metrics.ascent } }, { key: "lines", get: function() { return this.penManager.lines } }, { key: "desplayLinesCount", get: function() { var t = this.penManager.linesCount,
                        e = this.defaultStyle.maxLines; return 0 < e && e < t && (t = e), t } }, { key: "linesWidth", get: function() { return Math.ceil(this.penManager.getMaxLineWidth()) } }, { key: "linesHeight", get: function() { var t = this.desplayLinesCount,
                        e = this.defaultStyle.lineHeight * t; return 0 < t && (e -= this.defaultStyle.lineSpacing), e } }, { key: "imageManager", get: function() { return this.parent.imageManager } }, { key: "rtl", get: function() { return this.parent.style.rtl } }, { key: "newPenManager", value: function() { return new Ge({ pensPool: this.pensPool, linesPool: this.linesPool, tagToText: this.parser.propToTagText, tagToTextScope: this.parser }) } }, { key: "tmpPenManager", get: function() { return null === this._tmpPenManager && (this._tmpPenManager = this.newPenManager()), this._tmpPenManager } }, { key: "getPlainText", value: function(t, e, i) { var n; if (null == t) n = this.penManager.plainText;
                    else { var s = this.parser.splitText(t, 1);
                        n = ""; for (var r = 0, o = s.length; r < o; r++) n += s[r] } return null == e && null == i || (null == e && (e = 0), null == i && (i = n.length), n = n.substring(e, i)), n } }, { key: "getPenManager", value: function(t, e) { if (void 0 === t) return this.copyPenManager(e, this.penManager);
                    void 0 === e && (e = this.newPenManager()); var i = this.defaultStyle; return this.updatePenManager(t, i.wrapMode, i.wrapWidth, i.lineHeight, e), e } }, { key: "getText", value: function(t, e, i, n) { if (null == t) return this.penManager.getSliceTagText(e, i, n); var s = this.tmpPenManager,
                        r = this.defaultStyle; return this.updatePenManager(t, r.wrapMode, r.wrapWidth, r.lineHeight, s), s.getSliceTagText(e, i, n) } }, { key: "copyPenManager", value: function(t, e) { return void 0 === e && (e = this.penManager), e.copy(t) } }, { key: "getTextWidth", value: function(t) { return void 0 === t && (t = this.penManager), t.getMaxLineWidth() } }, { key: "getLastPen", value: function(t) { return void 0 === t && (t = this.penManager), t.lastPen } }]), i }(),
        li = { setInteractive: function() { this.parent.on("pointerdown", Je, this).on("pointerup", Ke, this).on("pointermove", Ze, this).on("pointerover", Ze, this).on("pointerout", function(t, e) { Ze.call(this, t, null, null, e) }, this) } };
    Object.assign(hi.prototype, Ae, li);

    function ui(t, e) { void 0 === e && (e = { key: t }), e.hasOwnProperty("key") || (e.key = t); var i = e.key,
            n = e.frame,
            s = e.width,
            r = e.height; if (void 0 === s || void 0 === r) { var o = this.textureManager.getFrame(i, n),
                a = o ? o.cutWidth : 0,
                h = o ? o.cutHeight : 0;
            void 0 === s && void 0 === r ? (s = a, r = h) : void 0 === s ? s = a * (r / h) : void 0 === r && (r = h * (s / a)) }
        this.images[t] = { key: i, frame: n, width: s, height: r, y: di(e, "y", 0), left: di(e, "left", 0), right: di(e, "right", 0) } } var ci = function() { w(e, N); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "freeLine", value: function(t) { if (t) return this.push(t), this } }, { key: "freeLines", value: function(t) { if (t) return this.pushMultiple(t), this } }, { key: "getLine", value: function(t, e, i) { var n = this.pop(); return null === n && (n = {}), n.text = t, n.width = e, n.newLineMode = i, n } }]), e }(),
        di = Phaser.Utils.Objects.GetValue,
        fi = function() {
            function e(t) { X(this, e), this.textureManager = t.sys.textures, this.images = {} } return k(e, [{ key: "destroy", value: function() { this.textureManager = void 0, this.images = void 0 } }, { key: "add", value: function(t, e) { if ("string" == typeof t) ui.call(this, t, e);
                    else if (Array.isArray(t))
                        for (var i = 0, n = (s = t).length; i < n; i++) ui.call(this, s[i]);
                    else { var s = t; for (var t in s) ui.call(this, t, s[t]) } return this } }, { key: "has", value: function(t) { return this.images.hasOwnProperty(t) } }, { key: "remove", value: function(t) { return this.has(t) && delete this.images[t], this } }, { key: "get", value: function(t) { return this.has(t) || this.textureManager.exists(t) && this.add(t), this.images[t] } }, { key: "getOuterWidth", value: function(t) { var e = this.get(t); return e ? e.width + e.left + e.right : 0 } }, { key: "getFrame", value: function(t) { var e = this.get(t); return e ? this.textureManager.getFrame(e.key, e.frame) : void 0 } }, { key: "hasTexture", value: function(t) { return !!this.getFrame(t) } }]), e }(),
        pi = { draw: function(t, e, i, n, s) { var r = this.get(t);
                i += r.left, n += r.y, s && (i = Math.round(i), n = Math.round(n)); var o = this.textureManager.getFrame(r.key, r.frame);
                e.drawImage(o.source.image, o.cutX, o.cutY, o.cutWidth, o.cutHeight, i, n, r.width, r.height) } };
    Object.assign(fi.prototype, pi);

    function vi(t, e) { return void 0 === e ? "\\[".concat(t, "\\]") : "\\[".concat(t, "=(").concat(e, ")\\]") }

    function gi(t) { return "\\[/".concat(t, "\\]") } var yi = Phaser.Utils.Objects.IsPlainObject,
        mi = Phaser.DOM.AddToDOM,
        ki = Phaser.Display.Canvas.CanvasPool,
        bi = Phaser.GameObjects.GameObject,
        xi = Phaser.Utils.Objects.GetValue,
        Ci = Phaser.DOM.RemoveFromDOM,
        wi = _e,
        Si = null,
        Pi = null,
        Ti = null,
        Oi = function() { w(v, ye); var p = T(v);

            function v(t, e, i, n, s, r, o) { var a; if (X(this, v), yi(e)) { var h = e;
                    e = xi(h, "x", 0), i = xi(h, "y", 0), n = xi(h, "text", ""), s = xi(h, "style") } if (void 0 === e && (e = 0), void 0 === i && (i = 0), (a = p.call(this, t, r)).renderer = t.sys.game.renderer, a.setPosition(e, i), a.setOrigin(0, 0), a.initPipeline(), a.canvas = ki.create(W(a)), a.context = a.canvas.getContext("2d"), a._imageManager = void 0, s) { if (s.hasOwnProperty("align")) { var l = s.align;
                        delete s.align, s.halign = l }
                    s.hasOwnProperty("stroke") && !s.hasOwnProperty("strokeThickness") && (s.strokeThickness = 1) }
                a.style = new Ie(W(a), s); var u, c, d, f = xi(s, "images", void 0); return f && a.addImage(f), a.autoRound = !0, a._text = void 0, a.padding = { left: 0, right: 0, top: 0, bottom: 0 }, a.width = 1, a.height = 1, a.dirty = !1, 0 === a.style.resolution && (a.style.resolution = 1), a._crop = a.resetCropObject(), a.texture = t.sys.textures.addCanvas(null, a.canvas, !0), a.frame = a.texture.get(), a.frame.source.resolution = a.style.resolution, a.renderer.gl && (a.renderer.deleteTexture(a.frame.source.glTexture), a.frame.source.glTexture = null), d = xi(s, "sharedPool", !0) ? (Si || (Si = {}, Pi = new N(), Ti = new ci(), a.scene.game.events.once("destroy", function() { Ti = Pi = Si = null })), Si.hasOwnProperty(r) || (Si[r] = new N()), u = Si[r], c = Pi, Ti) : (u = new N(), c = new N(), new ci()), a.canvasText = new hi({ parent: W(a), context: a.context, parser: o, style: a.style, pensPool: u, linesPool: c, wrapTextLinesPool: d }), a.parser = o, a.initRTL(), s && s.padding && a.setPadding(s.padding), a.setText(n), t.sys.game.events.on("contextrestored", a.onContextRestored, W(a)), a } return k(v, [{ key: "onContextRestored", value: function() { this.dirty = !0 } }, { key: "preDestroy", value: function() { this.style.rtl && Ci(this.canvas), this.scene.sys.game.events.off("contextrestored", this.onContextRestored, this), this.canvasText.destroy(), this.canvasText = void 0, this._imageManager && (this._imageManager.destroy(), this._imageManager = void 0), ki.remove(this.canvas), this.texture.destroy() } }, { key: "text", get: function() { return this._text }, set: function(t) { this.setText(t) } }, { key: "initRTL", value: function() { this.style.rtl && (this.canvas.dir = "rtl", this.context.direction = "rtl", this.canvas.style.display = "none", mi(this.canvas, this.scene.sys.canvas), this.originX = 1) } }, { key: "setText", value: function(t) { return (t = null == t ? "" : Array.isArray(t) ? t.join("\n") : t.toString()) === this._text || (this._text = t, this.updateText()), this } }, { key: "appendText", value: function(t) { return null == t || (Array.isArray(t) && (t = t.join("\n")), this.setText(this.text + t.toString())), this } }, { key: "setPadding", value: function(t, e, i, n) { if ("object" === P(t)) { var s = t,
                            r = xi(s, "x", null);
                        i = null !== r ? t = r : (t = xi(s, "left", 0), xi(s, "right", t)); var o = xi(s, "y", null);
                        n = null !== o ? e = o : (e = xi(s, "top", 0), xi(s, "bottom", e)) } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(!1) } }, { key: "updateText", value: function(t) { void 0 === t && (t = !0); var e = this.canvasText,
                        i = this.style;
                    t && e.updatePenManager(this._text, i.wrapMode, i.wrapWidth, i.lineHeight); var n, s, r = this.padding,
                        o = Math.ceil(e.linesWidth);
                    0 === i.fixedWidth ? (this.width = o + r.left + r.right, n = o) : (this.width = i.fixedWidth, (n = this.width - r.left - r.right) < o && (n = o)), 0 === i.fixedHeight ? (this.height = e.linesHeight + r.top + r.bottom, s = e.linesHeight) : (this.height = i.fixedHeight, (s = this.height - r.top - r.bottom) < e.linesHeight && (s = e.linesHeight)); var a = this.width,
                        h = this.height;
                    this.updateDisplayOrigin(); var l = i.resolution;
                    a *= l, h *= l, a = Math.max(Math.ceil(a), 1), h = Math.max(Math.ceil(h), 1); var u = this.canvas,
                        c = this.context;
                    u.width !== a || u.height !== h ? (u.width = a, u.height = h, this.frame.setSize(a, h)) : c.clearRect(0, 0, a, h), c.save(), c.scale(l, l); var d = this.style.rtl ? r.right : r.left,
                        f = r.top;
                    e.draw(d, f, n, s), c.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(u, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; var p = this.input; return p && !p.customHitArea && (p.hitArea.width = this.width, p.hitArea.height = this.height), this } }, { key: "toJSON", value: function() { var t = Components.ToJSON(this),
                        e = { autoRound: this.autoRound, text: this._text, style: this.style.toJSON(), resolution: this.resolution, padding: { left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom } }; return t.data = e, t } }, { key: "setInteractive", value: function(t, e, i) { var n = !!this.input; return bi.prototype.setInteractive.call(this, t, e, i), n || this.canvasText.setInteractive(), this } }, { key: "getWrappedText", value: function(t, e, i) { return (t = this.canvasText.getText(t, e, i, !0)).split(wi) } }, { key: "getPlainText", value: function(t, e, i) { return this.canvasText.getPlainText(t, e, i) } }, { key: "getText", value: function(t, e, i, n) { return void 0 === n && (n = !1), this.canvasText.getText(t, e, i, n) } }, { key: "getSubString", value: function(t, e, i) { return this.getText(t, e, i) } }, { key: "copyPenManager", value: function(t) { return this.canvasText.copyPenManager(t) } }, { key: "getPenManager", value: function(t, e) { return this.canvasText.getPenManager(t, e) } }, { key: "setSize", value: function(t, e) { return this.setFixedSize(t, e) } }, { key: "resize", value: function(t, e) { return this.setFixedSize(t, e) } }, { key: "imageManager", get: function() { return this._imageManager || (this._imageManager = new fi(this.scene)), this._imageManager } }, { key: "addImage", value: function(t, e) { return this.imageManager.add(t, e), this } }, { key: "drawAreaBounds", value: function(t, e) { return this.canvasText.hitAreaManager.drawBounds(t, e, this), this } }, { key: "generateTexture", value: function(t, e, i, n, s) { var r = this.canvas; return void 0 === n ? n = r.width : n *= this.resolution, void 0 === s ? s = r.height : s *= this.resolution, Ut(this.scene, r, t, e, i, n, s), this } }]), v }(),
        Mi = "[-.0-9]+",
        Ei = "[a-z]+|#[0-9abcdef]+",
        _i = "[^\\]]+",
        Ri = vi("esc"),
        Bi = gi("esc"),
        Ii = vi("raw"),
        Li = gi("raw"),
        Ai = vi("b"),
        ji = gi("b"),
        Di = vi("i"),
        zi = gi("i"),
        Fi = vi("weight", Mi),
        Yi = gi("weight"),
        Xi = vi("size", Mi),
        Wi = gi("size"),
        Gi = vi("color", Ei),
        Vi = gi("color"),
        Ui = vi("u"),
        Hi = vi("u", Ei),
        Ni = gi("u"),
        Ji = vi("shadow"),
        Ki = gi("shadow"),
        Zi = "stroke",
        qi = vi(Zi),
        $i = vi(Zi, Ei),
        Qi = gi(Zi),
        tn = vi("y", Mi),
        en = gi("y"),
        nn = vi("img", _i),
        sn = gi("img"),
        rn = vi("area", _i),
        on = gi("area"),
        an = vi("align", _i),
        hn = gi("align"),
        ln = new RegExp(Ri, "i"),
        un = new RegExp(Bi, "i"),
        cn = new RegExp(Ii, "i"),
        dn = new RegExp(Li, "i"),
        fn = new RegExp(Ai, "i"),
        pn = new RegExp(ji, "i"),
        vn = new RegExp(Di, "i"),
        gn = new RegExp(zi, "i"),
        yn = new RegExp(Fi, "i"),
        mn = new RegExp(Yi, "i"),
        kn = new RegExp(Xi, "i"),
        bn = new RegExp(Wi, "i"),
        xn = new RegExp(Gi, "i"),
        Cn = new RegExp(Vi, "i"),
        wn = new RegExp(Ui, "i"),
        Sn = new RegExp(Hi, "i"),
        Pn = new RegExp(Ni, "i"),
        Tn = new RegExp(Ji, "i"),
        On = new RegExp(Ki, "i"),
        Mn = new RegExp(qi, "i"),
        En = new RegExp($i, "i"),
        _n = new RegExp(Qi, "i"),
        Rn = new RegExp(tn, "i"),
        Bn = new RegExp(en, "i"),
        In = new RegExp(nn, "i"),
        Ln = new RegExp(sn, "i"),
        An = new RegExp(rn, "i"),
        jn = new RegExp(on, "i"),
        Dn = new RegExp(an, "i"),
        zn = new RegExp(hn, "i"),
        Fn = new RegExp([Ii, Li, Ri, Bi, Ai, ji, Di, zi, Fi, Yi, Xi, Wi, Gi, Vi, Ui, Hi, Ni, Ji, Ki, qi, $i, Qi, tn, en, nn, sn, rn, on, an, hn].join("|"), "ig"),
        Yn = { plainText: null, prevProp: null },
        Xn = function(t, e, i, n) { return !0 === e ? t[i] = n : t.hasOwnProperty(i) && delete t[i], t },
        Wn = function(t) { var e = t.b,
                i = t.weight,
                n = t.i; return e || i || n ? n ? e ? "bold italic" : i ? "".concat(i, " italic") : "italic" : e ? "bold" : i.toString() : "" },
        Gn = new Ie(),
        Vn = {},
        Un = function() {
            function t() { X(this, t) } return k(t, [{ key: "getStrokeThinkness", value: function(t, e) { return e.hasOwnProperty("stroke") ? t.strokeThickness : 0 } }]), t }(),
        Hn = { splitText: function(t, e) { for (var i = [], n = 0, s = !1, r = !1;;) { var o = Fn.exec(t); if (!o) break; var a = o[0]; if (r) { if (!un.test(a)) continue;
                        r = !1 } else if (s) { if (!dn.test(a)) continue;
                        s = !1 } else ln.test(a) ? r = !0 : cn.test(a) && (s = !0); var h = Fn.lastIndex,
                        l = h - a.length; if (n < l) { var u = t.substring(n, l);
                        i.push(u) }
                    void 0 === e && i.push(a), n = h } var c = t.length; return n < c && i.push(t.substring(n, c)), i }, tagTextToProp: function(t, e) { null == e && (e = {}); var i = ""; if (e.img && Xn(e, !1, "img"), e.esc) un.test(t) ? Xn(e, !1, "esc") : i = t;
                else if (e.raw) dn.test(t) ? Xn(e, !1, "raw") : i = t;
                else if (ln.test(t)) Xn(e, !0, "esc", !0);
                else if (un.test(t)) Xn(e, !1, "esc");
                else if (cn.test(t)) Xn(e, !0, "raw", !0);
                else if (dn.test(t)) Xn(e, !1, "raw");
                else if (fn.test(t)) Xn(e, !0, "b", !0);
                else if (pn.test(t)) Xn(e, !1, "b");
                else if (vn.test(t)) Xn(e, !0, "i", !0);
                else if (gn.test(t)) Xn(e, !1, "i");
                else if (yn.test(t)) { var n = t.match(yn);
                    Xn(e, !0, "weight", n[1]) } else if (mn.test(t)) Xn(e, !1, "weight");
                else if (kn.test(t)) { n = t.match(kn);
                    Xn(e, !0, "size", "".concat(n[1], "px")) } else if (bn.test(t)) Xn(e, !1, "size");
                else if (xn.test(t)) { n = t.match(xn);
                    Xn(e, !0, "color", n[1]) } else if (Cn.test(t)) Xn(e, !1, "color");
                else if (wn.test(t)) Xn(e, !0, "u", !0);
                else if (Sn.test(t)) { n = t.match(Sn);
                    Xn(e, !0, "u", n[1]) } else if (Pn.test(t)) Xn(e, !1, "u");
                else if (Tn.test(t)) Xn(e, !0, "shadow", !0);
                else if (On.test(t)) Xn(e, !1, "shadow");
                else if (Mn.test(t)) Xn(e, !0, "stroke", !0);
                else if (En.test(t)) { n = t.match(En);
                    Xn(e, !0, "stroke", n[1]) } else if (_n.test(t)) Xn(e, !1, "stroke");
                else if (Rn.test(t)) { n = t.match(Rn);
                    Xn(e, !0, "y", parseFloat(n[1])) } else if (Bn.test(t)) Xn(e, !1, "y");
                else if (In.test(t)) { n = t.match(In);
                    Xn(e, !0, "img", n[1]) } else if (Ln.test(t)) Xn(e, !1, "img");
                else if (An.test(t)) { n = t.match(An);
                    Xn(e, !0, "area", n[1]) } else if (jn.test(t)) Xn(e, !1, "area");
                else if (Dn.test(t)) { n = t.match(Dn);
                    Xn(e, !0, "align", n[1]) } else zn.test(t) ? Xn(e, !1, "align") : i = t; var s = Yn; return s.plainText = i, s.prop = e, s }, propToContextStyle: function(t, e) { var i = Gn; if (e.hasOwnProperty("img")) i.image = e.img;
                else { if (i.image = null, e.hasOwnProperty("family") ? i.fontFamily = e.family : i.fontFamily = t.fontFamily, e.hasOwnProperty("size")) { var n = e.size; "number" == typeof n && (n = "".concat(n, "px")), i.fontSize = n } else i.fontSize = t.fontSize;
                    i.fontStyle = Wn(e), e.hasOwnProperty("color") ? i.color = e.color : i.color = t.color, e.hasOwnProperty("stroke") ? (!0 === e.stroke ? i.stroke = t.stroke : i.stroke = e.stroke, i.strokeThickness = t.strokeThickness) : (i.stroke = t.stroke, i.strokeThickness = 0) } return e.hasOwnProperty("shadow") ? (!0 === e.shadow ? i.shadowColor = t.shadowColor : i.shadowColor = e.shadow, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0) : (i.shadowColor = "#000", i.shadowOffsetX = 0, i.shadowOffsetY = 0, i.shadowBlur = 0, i.shadowStroke = !1, i.shadowFill = !1), e.hasOwnProperty("u") ? (!0 === e.u ? i.underlineColor = t.underlineColor : i.underlineColor = e.u, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset) : (i.underlineColor = "#000", i.underlineThickness = 0, i.underlineOffset = 0), i }, propToTagText: function(t, e, i) { null == i && (i = Vn); var n = []; for (var s in i) e.hasOwnProperty(s) || n.push("[/".concat(s, "]")); for (var s in e) { var r = e[s]; if (i[s] !== r) switch (s) {
                        case "size":
                            n.push("[size=".concat(r.replace("px", ""), "]")); break;
                        case "color":
                        case "weight":
                        case "stroke":
                        case "y":
                        case "img":
                        case "area":
                        case "align":
                            n.push("[".concat(s, "=").concat(r, "]")); break;
                        case "u":
                            !0 === r ? n.push("[u]") : n.push("[u=".concat(r, "]")); break;
                        default:
                            n.push("[".concat(s, "]")) } } return n.push(t), n.join("") } };
    Object.assign(Un.prototype, Hn); var Nn = function() { w(a, Oi); var o = T(a);

        function a(t, e, i, n, s) { X(this, a); var r = new Un(s); return o.call(this, t, e, i, n, s, "rexBBCodeText", r) } return k(a) }();
    p.register("BBCodeText", function(t, e, i, n) { var s = new Nn(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), j(window, "RexPlugins.UI.BBCodeText", Nn); var Jn = { plainText: null, prevProp: null },
        Kn = new Ie(),
        Zn = function() {
            function e(t) { X(this, e), void 0 === t && (t = {}), this.tags = t } return k(e, [{ key: "addTag", value: function(t, e) { this.tags[t] = e } }, { key: "getTag", value: function(t) { return this.tags[t] } }, { key: "splitText", value: function(t, e) { for (var i = [], n = 0;;) { var s = Qn.exec(t); if (!s) break; var r = s[0],
                            o = Qn.lastIndex - r.length; if (n < o && i.push(t.substring(n, o)), void 0 === e) i.push(r);
                        else if (1 === e)
                            if (ts.test(r)) { var a = r.match(es);
                                i.push(a[2]) } else if (is.test(r)) { a = r.match(ns);
                            i.push(a[2]) }
                        n = Qn.lastIndex } var h = t.length; return n < h && i.push(t.substring(n, h)), i } }, { key: "tagTextToProp", value: function(t) { var e, i; if (ts.test(t)) { if (null != (r = t.match(es))) { var n = r[1],
                                s = this.tags;
                            (i = s.hasOwnProperty(n) ? s[n] : {})._class = n, e = r[2] } } else if (is.test(t)) { var r; if (null != (r = t.match(ns))) { var o = r[1];
                            (i = qn(o))._style = o, e = r[2] } }
                    null == e && (e = t), null == i && (i = {}); var a = Jn; return a.plainText = e, a.prop = i, a } }, { key: "propToContextStyle", value: function(t, e) { var i = Kn; if (e.hasOwnProperty("img")) i.image = e.img;
                    else { if (i.image = null, e.hasOwnProperty("family") || e.hasOwnProperty("fontFamily") || e.hasOwnProperty("font-family")) { var n = e.hasOwnProperty("family") ? e.family : e.hasOwnProperty("fontFamily") ? e.fontFamily : e["font-family"];
                            i.fontFamily = n } else i.fontFamily = t.fontFamily; if (e.hasOwnProperty("size") || e.hasOwnProperty("fontSize") || e.hasOwnProperty("font-size")) { var s = e.hasOwnProperty("size") ? e.size : e.hasOwnProperty("fontSize") ? e.fontSize : e["font-size"]; "number" == typeof s && (s = "".concat(s, "px")), i.fontSize = s } else i.fontSize = t.fontSize; if (e.hasOwnProperty("style") || e.hasOwnProperty("fontStyle") || e.hasOwnProperty("font-style")) { var r = e.hasOwnProperty("style") ? e.style : e.hasOwnProperty("fontStyle") ? e.fontStyle : e["font-style"];
                            i.fontStyle = r } else i.fontStyle = t.fontStyle; if (e.hasOwnProperty("color") || e.hasOwnProperty("font-color")) { var o = e.hasOwnProperty("color") ? e.color : e["font-color"];
                            i.color = o } else i.color = t.color; if (e.hasOwnProperty("stroke")) { var a = e.stroke;
                            i.stroke = a.hasOwnProperty("color") ? a.color : t.stroke, i.strokeThickness = a.hasOwnProperty("thickness") ? a.thickness : t.strokeThickness } else i.stroke = t.stroke, i.strokeThickness = t.strokeThickness } if (e.hasOwnProperty("shadow")) { var h = e.shadow;
                        i.shadowColor = h.hasOwnProperty("color") ? h.color : t.shadowColor, i.shadowOffsetX = h.hasOwnProperty("offsetX") ? h.offsetX : t.shadowOffsetX, i.shadowOffsetY = h.hasOwnProperty("offsetY") ? h.offsetY : t.shadowOffsetY, i.shadowBlur = h.hasOwnProperty("blur") ? h.blur : t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0 } else i.shadowColor = t.shadowColor, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = t.shadowStroke, i.shadowFill = t.shadowFill; if (e.hasOwnProperty("u") || e.hasOwnProperty("underline")) { var l = e.hasOwnProperty("u") ? e.u : e.underline;
                        i.underlineColor = l.hasOwnProperty("color") ? l.color : t.underlineColor, i.underlineThickness = l.hasOwnProperty("thickness") ? l.thickness : t.underlineThickness, i.underlineOffset = l.hasOwnProperty("offset") ? l.offset : t.underlineOffset } else i.underlineColor = t.underlineColor, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset; return i } }, { key: "getStrokeThinkness", value: function(t, e) { var i; if (e.hasOwnProperty("stroke")) { var n = e.stroke;
                        i = n.hasOwnProperty("thickness") ? n.thickness : t.strokeThickness } else i = t.strokeThickness; return i } }, { key: "propToTagText", value: function(t, e) { return e.hasOwnProperty("_class") ? "" === t && this.isTextTag(e._class) ? "" : "<class='".concat(e._class, "'>").concat(t, "</class>") : e.hasOwnProperty("_style") ? "<style='".concat(e._style, "'>").concat(t, "</style>") : t } }, { key: "destroy", value: function() { this.tags = void 0 } }, { key: "isTextTag", value: function(t) { var e = this.tags[t]; return !!e && null == e.img } }]), e }(),
        qn = function(t) { for (var e, i, n, s = {}, r = 0, o = (t = t.split(";")).length; r < o; r++)
                if (i = (e = t[r].split(":"))[0], n = e[1], !$n(i) && !$n(n)) { switch (i) {
                        case "stroke":
                            var a = n.split(" ");
                            n = {}, 1 <= (l = a.length) && (n.color = a[0]), 2 <= l && (n.thickness = parseInt(a[1].replace("px", ""))); break;
                        case "shadow":
                            var h = n.split(" ");
                            n = {}, 1 <= (l = h.length) && (n.color = h[0]), 2 <= l && (n.offsetX = parseInt(h[1].replace("px", ""))), 3 <= l && (n.offsetY = parseInt(h[2].replace("px", ""))), 4 <= l && (n.blur = parseInt(h[3].replace("px", ""))); break;
                        case "u":
                        case "underline":
                            var l, u = n.split(" ");
                            n = {}, 1 <= (l = u.length) && (n.color = u[0]), 2 <= l && (n.thickness = parseInt(u[1].replace("px", ""))), 3 <= l && (n.offset = parseInt(u[2].replace("px", ""))); break;
                        case "y":
                            n = parseFloat(n) }
                    s[i] = n }
            return s },
        $n = function(t) { return 0 === (t = t.replace(ss, "")).length },
        Qn = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g,
        ts = /<\s*class=/i,
        es = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/,
        is = /<\s*style=/i,
        ns = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/,
        ss = /^\s+|\s+$/,
        rs = Phaser.Utils.Objects.GetValue,
        os = function() { w(h, Oi); var a = T(h);

            function h(t, e, i, n, s) { X(this, h); var r = rs(s, "tags", void 0),
                    o = new Zn(r); return a.call(this, t, e, i, n, s, "rexTagText", o) } return k(h, [{ key: "addTag", value: function(t, e) { return this.parser.addTag(t, e), this.updateText(!0) } }, { key: "addTags", value: function(t) { for (var e in t) this.parser.addTag(e, t[e]); return this.updateText(!0) } }, { key: "getTag", value: function(t) { return this.parser.getTag(t) } }, { key: "preDestroy", value: function() { O(C(h.prototype), "preDestroy", this).call(this), this.parser.destroy(), this.parser = void 0 } }]), h }();
    p.register("tagText", function(t, e, i, n) { var s = new os(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), j(window, "RexPlugins.UI.TagText", os);

    function as(t) { return t instanceof us }

    function hs(t) { return null == t || "object" !== P(t) ? null : as(t) ? t : t.scene && as(t.scene) ? t.scene : t.parent && t.parent.scene && as(t.parent.scene) ? t.parent.scene : void 0 } var ls = { setEventEmitter: function(t, e) { return void 0 === e && (e = Phaser.Events.EventEmitter), this._privateEE = !0 === t || void 0 === t, this._eventEmitter = this._privateEE ? new e() : t, this }, destroyEventEmitter: function() { return this._eventEmitter && this._privateEE && this._eventEmitter.shutdown(), this }, getEventEmitter: function() { return this._eventEmitter }, on: function() { return this._eventEmitter && this._eventEmitter.on.apply(this._eventEmitter, arguments), this }, once: function() { return this._eventEmitter && this._eventEmitter.once.apply(this._eventEmitter, arguments), this }, off: function() { return this._eventEmitter && this._eventEmitter.off.apply(this._eventEmitter, arguments), this }, emit: function(t) { return this._eventEmitter && t && this._eventEmitter.emit.apply(this._eventEmitter, arguments), this }, addListener: function() { return this._eventEmitter && this._eventEmitter.addListener.apply(this._eventEmitter, arguments), this }, removeListener: function() { return this._eventEmitter && this._eventEmitter.removeListener.apply(this._eventEmitter, arguments), this }, removeAllListeners: function() { return this._eventEmitter && this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments), this }, listenerCount: function() { return this._eventEmitter ? this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments) : 0 }, listeners: function() { return this._eventEmitter ? this._eventEmitter.listeners.apply(this._eventEmitter, arguments) : [] }, eventNames: function() { return this._eventEmitter ? this._eventEmitter.eventNames.apply(this._eventEmitter, arguments) : [] } },
        us = Phaser.Scene,
        cs = Phaser.Utils.Objects.GetValue,
        ds = function() {
            function i(t, e) { X(this, i), this.parent = t, this.scene = hs(t), this.isShutdown = !1, this.setEventEmitter(cs(e, "eventEmitter", !0)), this.parent && this.parent === this.scene ? this.scene.sys.events.once("shutdown", this.onSceneDestroy, this) : this.parent && this.parent.once && this.parent.once("destroy", this.onParentDestroy, this) } return k(i, [{ key: "shutdown", value: function() { this.isShutdown || (this.parent && this.parent === this.scene ? this.scene.sys.events.off("shutdown", this.onSceneDestroy, this) : this.parent && this.parent.once && this.parent.off("destroy", this.onParentDestroy, this), this.destroyEventEmitter(), this.parent = void 0, this.scene = void 0, this.isShutdown = !0) } }, { key: "destroy", value: function(t) { this.shutdown(t) } }, { key: "onSceneDestroy", value: function() { this.destroy(!0) } }, { key: "onParentDestroy", value: function(t, e) { this.destroy(e) } }]), i }();
    Object.assign(ds.prototype, ls);

    function fs(t, e, i) { if ("string" == typeof i) t.hasOwnProperty(i) && (e[i] = t[i]);
        else { var n = i; if (Array.isArray(n))
                for (var s = 0, r = n.length; s < r; s++) fs(t, e, n[s]);
            else
                for (var i in n) fs(t, e, i) } }

    function ps(t, e, i, n) { if (e) return !(i && !i(t, e)) && (!!ks(t, e) && !(n && !n(t, e))); for (var s = t.scene.input.manager, r = s.pointersTotal, o = s.pointers, a = 0; a < r; a++)
            if (e = o[a], (!i || i(t, e)) && ks(t, e) && (!n || n(t, e))) return !0;
        return !1 }

    function vs(t, e, i) { var n, s; for (var r in void 0 === i && (i = {}), t) n = t[r], void 0 !== (s = xs(e, r, n[1])) && (i[n[0]] = s); return i }

    function gs(t) { t.addEventListener("touchstart", Cs, !1), t.addEventListener("touchmove", Cs, !1), t.addEventListener("touchend", Cs, !1), t.addEventListener("mousedown", Cs, !1), t.addEventListener("mouseup", Cs, !1), t.addEventListener("mousemove", Cs, !1) } var ys = { maxLength: ["maxLength", void 0], minLength: ["minLength", void 0], readOnly: ["readOnly", !1] },
        ms = { direction: ["direction", void 0] },
        ks = function(t, e) { for (var i = t.scene, n = i.input.cameras.getCamerasBelowPointer(e), s = i.input.manager, r = [t], o = 0, a = n.length; o < a; o++)
                if (0 < s.hitTest(e, r, n[o]).length) return !0;
            return !1 },
        bs = void 0,
        xs = Phaser.Utils.Objects.GetValue,
        Cs = function(t) { t.stopPropagation() },
        ws = Phaser.Utils.Objects.GetValue,
        Ss = { open: function() { return this.isOpened || ((t = this) !== bs && (void 0 !== bs && bs.close(), bs = t), this.isOpened = !0, this.node || (this.node = function(t) { var e, i = ws(t, "inputType", void 0);
                    void 0 === i && (i = ws(t, "type", "text")), "textarea" === i ? (e = document.createElement("textarea")).style.resize = "none" : (e = document.createElement("input")).type = i; var n = ws(t, "style", void 0),
                        s = e.style; return vs(ms, n, s), s.position = "absolute", s.opacity = 0, s.pointerEvents = "none", s.zIndex = 0, s.transform = "scale(0)", vs(ys, t, e), gs(e), document.body.appendChild(e), e }(this.nodeConfig)), this.setFocus(), this.initText(), this.enterCloseEnable && this.scene.input.keyboard.once("keydown-ENTER", this.close, this), this.scene.sys.events.on("postupdate", this.updateText, this), this.scene.input.on("pointerdown", this.onClickOutside, this), this.onOpenCallback && this.onOpenCallback(this.parent, this), this.emit("open", this)), this; var t }, close: function() { return this.isOpened && (this === bs && (bs = void 0), this.setBlur(), this.isOpened = !1, this.updateText(), this.scene.sys.events.off("postupdate", this.updateText, this), this.scene.input.off("pointerdown", this.onClickOutside, this), this.onCloseCallback && this.onCloseCallback(this.parent, this), (t = this.node) && document.body.removeChild(t), this.node = void 0, this.emit("close", this)), this; var t } },
        Ps = Phaser.Utils.Objects.GetValue,
        Ts = function() { w(a, ds); var o = T(a);

            function a(t, e) { var i;
                X(this, a), i = o.call(this, t); var n = Ps(e, "inputType", void 0);
                void 0 === n && (n = Ps(e, "type", "text")), i.setEnterCloseEnable(Ps(e, "enterClose", "textarea" !== n)); var s = Ps(e, "onOpen", void 0);
                s = s || Ps(e, "onFocus", void 0), i.onOpenCallback = s; var r = Ps(e, "onClose", void 0); return r = r || Ps(e, "onBlur", void 0), i.onCloseCallback = r, i.onUpdateCallback = Ps(e, "onUpdate", void 0), i.isOpened = !1, t.on("pointerdown", function() { this.open() }, W(i)).setInteractive(), i.nodeConfig = function(t) { void 0 === t && (t = {}); var e = {}; return fs(t, e, "inputType"), fs(t, e, "type"), fs(t, e, "style"), fs(t, e, ms), fs(t, e, ys), e }(e), i.node = void 0, i } return k(a, [{ key: "destroy", value: function() { this.close(), O(C(a.prototype), "destroy", this).call(this) } }, { key: "onClickOutside", value: function(t) { ps(this.parent, t) || this.close() } }, { key: "setEnterCloseEnable", value: function(t) { return void 0 === t && (t = !0), this.enterCloseEnable = t, this } }, { key: "initText", value: function() {} }, { key: "updateText", value: function() {} }, { key: "text", get: function() { return this.node ? this.node.value : "" }, set: function(t) { this.node && (this.node.value = t) } }, { key: "setText", value: function(t) { return this.text = t, this } }, { key: "maxLength", get: function() { return this.node ? this.node.maxLength : 0 }, set: function(t) { this.node && (this.node.maxLength = t) } }, { key: "setMaxLength", value: function(t) { return this.maxLength = t, this } }, { key: "minLength", get: function() { return this.node ? this.node.minLength : 0 }, set: function(t) { this.node && (this.node.minLength = t) } }, { key: "setMinLength", value: function(t) { return this.minLength = t, this } }, { key: "placeholder", get: function() { return this.node.placeholder }, set: function(t) { this.node && (this.node.placeholder = t) } }, { key: "setPlaceholder", value: function(t) { return this.placeholder = t, this } }, { key: "selectText", value: function(t, e) { return this.node && (void 0 === t ? this.node.select() : this.node.setSelectionRange(t, e)), this } }, { key: "selectAll", value: function() { return this.selectText(), this } }, { key: "selectionStart", get: function() { return this.node ? this.node.selectionStart : 0 } }, { key: "selectionEnd", get: function() { return this.node ? this.node.selectionEnd : 0 } }, { key: "selectedText", get: function() { if (!this.node) return ""; var t = this.node; return t.value.substring(t.selectionStart, t.selectionEnd) } }, { key: "cursorPosition", get: function() { return this.node ? this.node.selectionStart : 0 }, set: function(t) { this.node && this.node.setSelectionRange(t, t) } }, { key: "setCursorPosition", value: function(t) { return void 0 === t ? t = this.text.length : t < 0 && (t = this.text.length + t), this.cursorPosition = t, this } }, { key: "tooltip", get: function() { return this.node ? this.node.title : "" }, set: function(t) { if (!this.node) return this;
                    this.node.title = t } }, { key: "setTooltip", value: function(t) { return this.tooltip = t, this } }, { key: "setTextChangedCallback", value: function(t) { return this.onTextChanged = t, this } }, { key: "readOnly", get: function() { return !!this.node && this.node.readOnly }, set: function(t) { this.node && (this.node.readOnly = t) } }, { key: "setReadOnly", value: function(t) { return void 0 === t && (t = !0), this.readOnly = t, this } }, { key: "spellCheck", get: function() { return this.node ? this.node.spellcheck : "" }, set: function(t) { this.node && (this.node.spellcheck = t) } }, { key: "setSpellCheck", value: function(t) { return this.spellCheck = t, this } }, { key: "fontColor", get: function() { if (this.node) return this.node.style.color }, set: function(t) { this.node && (this.node.style.color = t) } }, { key: "setFontColor", value: function(t) { return this.fontColor = t, this } }, { key: "setStyle", value: function(t, e) { return this.node && (this.node.style[t] = e), this } }, { key: "getStyle", value: function(t) { if (this.node) return this.node.style[t] } }, { key: "scrollToBottom", value: function() { return this.node && (this.node.scrollTop = this.node.scrollHeight), this } }, { key: "setEnabled", value: function(t) { return this.node && (void 0 === t && (t = !0), this.node.disabled = !t), this } }, { key: "setBlur", value: function() { return this.node && this.node.blur(), this } }, { key: "setFocus", value: function() { return this.node && this.node.focus(), this } }, { key: "isFocused", get: function() { return this.isOpened } }]), a }();
    Object.assign(Ts.prototype, Ss);

    function Os(t, e, i) { t = t.replace(" ", ""); var n = i.previousText; if (t === n) return t; if (isNaN(t)) { t = n; var s = i.cursorPosition - 1;
            i.setText(t), i.setCursorPosition(s) } else i.previousText = t; return t }

    function Ms(t) { return t instanceof _s }

    function Es(t) { return (Ms(e = t) ? e : Ms(e.game) ? e.game : as(e) ? e.sys.game : as(e.scene) ? e.scene.sys.game : void 0).loop.delta; var e } var _s = Phaser.Game,
        Rs = Phaser.Utils.Objects.GetValue,
        Bs = Phaser.Math.Wrap,
        Is = function() { w(s, Ts); var n = T(s);

            function s(t, e) { var i; return X(this, s), void 0 === e && (e = {}), "number" === e.onUpdate && (e.onUpdate = Os), (i = n.call(this, t, e)).setCursor(Rs(e, "cursor", "|")), i.setCursorFlashDuration(Rs(e, "cursorFlashDuration", 1e3)), i.cursorFlashTimer = 0, i } return k(s, [{ key: "initText", value: function() { return this.cursorFlashTimer = 0, this.prevCursorPosition = void 0, this.setText(this.parent.text), this.setCursorPosition(), this } }, { key: "updateText", value: function() { var t = this.text; if (this.onUpdateCallback) { var e = this.onUpdateCallback(t, this.parent, this);
                        null != e && (t = e) } if (this.isOpened && this.hasCursor) { var i = this.cursorPosition;
                        t = t.substring(0, i) + this.cursor + t.substring(i), this.prevCursorPosition !== i && (this.prevCursorPosition = i) } return this.parent.setText(t), this } }, { key: "setCursor", value: function(t) { return this._cursor = t, this.hasCursor = t && "" !== t, t } }, { key: "setCursorFlashDuration", value: function(t) { return this.cursorFlashDuration = t, this } }, { key: "cursor", get: function() { if (!this._isFocused) return this._cursor; var t;
                    t = this.cursorFlashTimer < this.cursorFlashDuration / 2 ? this._cursor : " "; var e = this.cursorFlashTimer + Es(this.scene); return this.cursorFlashTimer = Bs(e, 0, this.cursorFlashDuration), t } }]), s }();
    p.register("hiddenEdit", function(t, e) { return new Is(t, e) }), j(window, "RexPlugins.UI.HiddenEdit", Is); var Ls = Phaser.GameObjects.Zone,
        As = Phaser.Utils.Array.Add,
        js = Phaser.Utils.Array.Remove,
        Ds = function() { w(a, Ls); var o = T(a);

            function a(t, e, i, n, s) { var r; return X(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, e, i, n, s)).children = [], r } return k(a, [{ key: "destroy", value: function(t) { if (this.scene) { if (t)
                            for (var e, i = this.children.length - 1; 0 <= i; i--)(e = this.children[i]).parentContainer || e.displayList || e.destroy(t);
                        this.clear(!t), O(C(a.prototype), "destroy", this).call(this, t) } } }, { key: "contains", value: function(t) { return -1 !== this.children.indexOf(t) } }, { key: "add", value: function(t) { var e = this; return As(this.children, t, 0, function(t) { t.once("destroy", e.onChildDestroy, e) }, this), this } }, { key: "remove", value: function(t, e) { var i = this; return js(this.children, t, function(t) { t.off("destroy", i.onChildDestroy, i), e && t.destroy() }), this } }, { key: "onChildDestroy", value: function(t) { this.remove(t, !1) } }, { key: "clear", value: function(t) { for (var e, i = 0, n = this.children.length; i < n; i++)(e = this.children[i]).off("destroy", this.onChildDestroy, this), t && e.destroy(); return this.children.length = 0, this } }]), a }(),
        zs = Phaser.GameObjects.Components;
    Phaser.Class.mixin(Ds, [zs.Alpha, zs.Flip]);

    function Fs(t, e) { var i; if (void 0 === e) t.hasOwnProperty("rexContainer") && (i = t.rexContainer.parent);
        else
            for (i = Fs(t); i && i.name !== e;) i = Fs(i); return i }

    function Ys(t) { for (var e = Fs(t); e;) e = Fs(t = e); return t }

    function Xs(e) { if (!e.hasOwnProperty("rexContainer")) { var t = { parent: null, self: null, layer: null, x: 0, y: 0, syncPosition: !0, rotation: 0, syncRotation: !0, scaleX: 0, scaleY: 0, syncScale: !0, alpha: 0, syncAlpha: !0, visible: !0, active: !0 };
            Object.defineProperty(t, "angle", { get: function() { return nr(this.rotation) }, set: function(t) { this.rotation = ir(t) } }), Object.defineProperty(t, "displayWidth", { get: function() { return e.width * this.scaleX }, set: function(t) { this.scaleX = t / e.width } }), Object.defineProperty(t, "displayHeight", { get: function() { return e.height * this.scaleY }, set: function(t) { this.scaleY = t / e.height } }), e.rexContainer = t } return e.rexContainer }

    function Ws(t, e) { this.setParent(t); var i = Xs(t); return ar(i, e), this.resetChildState(t).updateChildVisible(t).updateChildActive(t).updateChildScrollFactor(t).updateChildMask(t), or.call(this, t), this.addToRenderLayer(t), this }

    function Gs(t, e) { this.setParent(t); var i = Xs(t); return ar(i, e), i.x = t.x, i.y = t.y, i.rotation = t.rotation, i.scaleX = t.scaleX, i.scaleY = t.scaleY, i.alpha = t.alpha, i.visible = t.visible, i.active = t.active, this.updateChildPosition(t).updateChildAlpha(t).updateChildVisible(t).updateChildActive(t).updateChildScrollFactor(t).updateChildMask(t), or.call(this, t), this.addToRenderLayer(t), this }

    function Vs(t, e) { return t === e ? 1 : t / e }

    function Us(t, e) { if (0 === t.length) return t;
        void 0 === e && (e = !1); var i = t[0].scene.sys.displayList; return i.depthSort(), e ? t.sort(function(t, e) { return i.getIndex(e) - i.getIndex(t) }) : t.sort(function(t, e) { return i.getIndex(t) - i.getIndex(e) }), t }

    function Hs(t, e) { for (var i = [t]; 0 < i.length;) { var n = i.shift();!e(n) && n.isRexContainerLite && i.push.apply(i, M(n.children)) } }

    function Ns(t) { for (var e = [], i = 0, n = t.length; i < n; i++) { var s = t[i];
            s.hasOwnProperty("rexContainer") && e.push(s.rexContainer) } return e }

    function Js(t, e, i) { if (i.parent) { var n = i.parent,
                s = i.self; switch (e) {
                case "x":
                case "y":
                    n.updateChildPosition(s); break;
                case "angle":
                case "rotation":
                    n.updateChildRotation(s); break;
                case "scaleX":
                case "scaleY":
                case "displayWidth":
                case "displayHeight":
                    n.updateChildScale(s); break;
                case "alpha":
                    n.updateChildAlpha(s); break;
                default:
                    n.updateChildPosition(s), n.updateChildRotation(s), n.updateChildScale(s), n.updateChildAlpha(s) } } else t.remove() }

    function Ks(t) { this._setParentContainerFlag = !0; var e = this.getAllChildren([this]); return Us(e), t.add(e), this._setParentContainerFlag = !1, this }

    function Zs(t) { return void 0 !== t.displayWidth ? t.displayWidth : t.width }

    function qs(t) { return void 0 !== t.displayHeight ? t.displayHeight : t.height }

    function $s(t, e) { if (void 0 === e ? e = new _r() : !0 === e && (void 0 === Ir && (Ir = new _r()), e = Ir), t.getBounds) return t.getBounds(e); var i, n, s, r, o, a, h, l; if (t.parentContainer) { var u = t.parentContainer.getBoundsTransformMatrix();
            Lr(t, e), u.transformPoint(e.x, e.y, e), i = e.x, n = e.y, Ar(t, e), u.transformPoint(e.x, e.y, e), s = e.x, r = e.y, jr(t, e), u.transformPoint(e.x, e.y, e), o = e.x, a = e.y, Dr(t, e), u.transformPoint(e.x, e.y, e), h = e.x, l = e.y } else Lr(t, e), i = e.x, n = e.y, Ar(t, e), s = e.x, r = e.y, jr(t, e), o = e.x, a = e.y, Dr(t, e), h = e.x, l = e.y; return e.x = Math.min(i, s, o, h), e.y = Math.min(n, r, a, l), e.width = Math.max(i, s, o, h) - e.x, e.height = Math.max(n, r, a, l) - e.y, e }

    function Qs(t) { if (t) { var e, i, n = t.gameObjects,
                s = t.renderTexture,
                r = Wr(t, "x", void 0),
                o = Wr(t, "y", void 0),
                a = Wr(t, "width", void 0),
                h = Wr(t, "height", void 0),
                l = Wr(t, "originX", 0),
                u = Wr(t, "originY", 0),
                c = Wr(t, "padding", 0); if (void 0 === a || void 0 === h || void 0 === r || void 0 === o) { var d = function(t, e) { var i;
                    void 0 === e ? e = new Yr() : !0 === e && (void 0 === er && (er = new Yr()), e = er), e.setTo(0, 0, 0, 0); for (var n = !0, s = 0, r = t.length; s < r; s++)
                        if ((i = t[s]).getBounds) { var o = $s(i, !0);
                            n ? (e.setTo(o.x, o.y, o.width, o.height), n = !1) : Xr(o, e, e) }
                    return e }(n, !0);
                u = l = void 0 !== r && void 0 !== o ? (a = 2 * Math.max(r - d.left, d.right - r), h = 2 * Math.max(o - d.top, d.bottom - o), .5) : (r = d.x, o = d.y, a = d.width, h = d.height, 0), e = d.x, i = d.y } else e = r + (0 - l) * a, i = o + (0 - u) * h;
            e -= c, i -= c, a += 2 * c, h += 2 * c; var f = !s; if (f) s = n[0].scene.add.renderTexture(0, 0, a, h);
            s.setPosition(r, o), s.width === a && s.height === h || s.setSize(a, h), s.setOrigin(l, u), s.camera.setScroll(e, i), n = Us(be(n)), s.draw(n); var p = t.saveTexture; return p && s.saveTexture(p), f && p && s.destroy(), s } }

    function tr(t, e, i) { var n, s;
        (t.getBounds || void 0 !== t.width && void 0 !== t.height) && ("number" == typeof i ? n = i : (n = Vr(i, "color"), s = Vr(i, "lineWidth")), void 0 === n && (n = 16777215), void 0 === s && (s = 1), Ur[0] = Lr(t, Ur[0]), Ur[1] = Ar(t, Ur[1]), Ur[2] = Dr(t, Ur[2]), Ur[3] = jr(t, Ur[3]), e.lineStyle(s, n).strokePoints(Ur, !0, !0)) } var er, ir = Phaser.Math.DegToRad,
        nr = Phaser.Math.RadToDeg,
        sr = { setParent: function(t, e) { void 0 === e && (e = this); var i = Xs(t); return e ? (i.parent = e, i.self = t) : (i.parent = null, i.self = null), this }, getParent: function(t, e) { return "string" == typeof t && (e = t, t = void 0), void 0 === t && (t = this), Fs(t, e) }, getTopmostParent: function(t) { return void 0 === t && (t = this), Ys(t) } },
        rr = Phaser.Utils.Objects.GetValue,
        or = Ds.prototype.add,
        ar = function(t, e) { t.syncPosition = rr(e, "syncPosition", !0), t.syncRotation = rr(e, "syncRotation", !0), t.syncScale = rr(e, "syncScale", !0), t.syncAlpha = rr(e, "syncAlpha", !0) },
        hr = { add: function(t) { return Array.isArray(t) ? this.addMultiple(t) : Ws.call(this, t), this }, pin: function(t, e) { return Array.isArray(t) ? this.addMultiple(t, e) : Ws.call(this, t, e), this }, addMultiple: function(t) { for (var e = 0, i = t.length; e < i; e++) Ws.call(this, t[e]); return this }, addLocal: function(t) { return Array.isArray(t) ? this.addMultiple(t) : Gs.call(this, t), this }, pinLocal: function(t, e) { return Array.isArray(t) ? this.addMultiple(t, e) : Gs.call(this, t, e), this }, addLocalMultiple: function(t) { for (var e = 0, i = t.length; e < i; e++) Gs.call(this, t[e]); return this } },
        lr = Ds.prototype.remove,
        ur = Ds.prototype.clear,
        cr = { remove: function(t, e) { return Fs(t) !== this || (this.setParent(t, null), e || this.removeFromRenderLayer(t), lr.call(this, t, e)), this }, unpin: function(t, e) { return Fs(t) !== this || (this.setParent(t, null), e || this.removeFromRenderLayer(t), lr.call(this, t, e)), this }, clear: function(t) { for (var e = this.children, i = 0, n = e.length; i < n; i++) { var s = e[i];
                    this.setParent(s, null), t || this.removeFromRenderLayer(s) } return ur.call(this, t), this } },
        dr = { getLocalState: function(t) { return Xs(t) }, resetChildState: function(t) { return this.resetChildPositionState(t).resetChildVisibleState(t).resetChildAlphaState(t).resetChildActiveState(t), this }, resetChildrenState: function(t) { for (var e = 0, i = t.length; e < i; e++) this.resetChildState(t[e]); return this }, syncProperties: function() { return this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask(), this } },
        fr = Phaser.Math.RotateAround,
        pr = { worldToLocal: function(t) { return t.x -= this.x, t.y -= this.y, fr(t, 0, 0, -this.rotation), t.x /= this.scaleX, t.y /= this.scaleY, t }, localToWorld: function(t) { return t.x *= this.scaleX, t.y *= this.scaleY, fr(t, 0, 0, this.rotation), t.x += this.x, t.y += this.y, t } },
        vr = { updateChildPosition: function(t) { t.isRexContainerLite && (t.syncChildrenEnable = !1); var e = Xs(t),
                    i = e.parent; return e.syncPosition && (t.x = e.x, t.y = e.y, i.localToWorld(t)), e.syncRotation && (t.rotation = e.rotation + i.rotation), e.syncScale && (t.scaleX = e.scaleX * i.scaleX, t.scaleY = e.scaleY * i.scaleY), t.isRexContainerLite && (t.syncChildrenEnable = !0, t.syncPosition()), this }, syncPosition: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildPosition, this), this }, resetChildPositionState: function(t) { var e = Xs(t),
                    i = e.parent; return e.x = t.x, e.y = t.y, i.worldToLocal(e), e.scaleX = Vs(t.scaleX, i.scaleX), e.scaleY = Vs(t.scaleY, i.scaleY), e.rotation = t.rotation - i.rotation, this }, setChildPosition: function(t, e, i) { return t.x = e, t.y = i, this.resetChildPositionState(t), this }, setChildLocalPosition: function(t, e, i) { var n = Xs(t); return n.x = e, n.y = i, this.updateChildPosition(t), this }, resetLocalPositionState: function() { var t = Xs(this).parent; return t && t.resetChildPositionState(this), this } },
        gr = Phaser.Math.DegToRad,
        yr = { updateChildRotation: function(t) { var e = Xs(t),
                    i = e.parent; return e.syncRotation && (t.rotation = i.rotation + e.rotation), this }, syncRotation: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildRotation, this), this }, resetChildRotationState: function(t) { var e = Xs(t),
                    i = e.parent; return e.rotation = t.rotation - i.rotation, this }, setChildRotation: function(t, e) { return t.rotation = e, this.resetChildRotationState(t), this }, setChildAngle: function(t, e) { return t.angle = e, this.resetChildRotationState(t), this }, setChildLocalRotation: function(t, e) { return Xs(t).rotation = e, this.updateChildRotation(t), this }, setChildLocalAngle: function(t, e) { return Xs(t).rotation = gr(e), this.updateChildRotation(t), this }, resetLocalRotationState: function() { var t = Xs(this).parent; return t && t.resetChildRotationState(this), this } },
        mr = { updateChildScale: function(t) { var e = Xs(t),
                    i = e.parent; return e.syncScale && (t.scaleX = i.scaleX * e.scaleX, t.scaleY = i.scaleY * e.scaleY), this }, syncScale: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildScale, this), this }, resetChildScaleState: function(t) { var e = Xs(t),
                    i = e.parent; return e.scaleX = Vs(t.scaleX, i.scaleX), e.scaleY = Vs(t.scaleY, i.scaleY), this }, setChildScale: function(t, e, i) { return void 0 === i && (i = e), t.scaleX = e, t.scaleY = i, this.resetChildScaleState(t), this }, setChildLocalScale: function(t, e, i) { void 0 === i && (i = e); var n = Xs(t); return n.scaleX = e, n.scaleY = i, this.updateChildScale(t), this }, setChildDisplaySize: function(t, e, i) { return t.setDisplaySize(e, i), this.resetChildScaleState(t), this }, resetLocalScaleState: function() { var t = Xs(this).parent; return t && t.resetChildScaleState(this), this } },
        kr = { updateChildVisible: function(t) { var e = Xs(t),
                    i = e.parent,
                    n = !e.hasOwnProperty("maskVisible") || e.maskVisible; return t.visible = i.visible && e.visible && n, this }, syncVisible: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildVisible, this), this }, resetChildVisibleState: function(t) { var e = Xs(t); return e.hasOwnProperty("maskVisible") && delete e.maskVisible, e.visible = t.visible, this }, setChildVisible: function(t, e) { return this.setChildLocalVisible(t, e), this }, setChildLocalVisible: function(t, e) { return void 0 === e && (e = !0), Xs(t).visible = e, this.updateChildVisible(t), this }, setChildMaskVisible: function(t, e) { return void 0 === e && (e = !0), Xs(t).maskVisible = e, this.updateChildVisible(t), this }, resetLocalVisibleState: function() { var t = Xs(this).parent; return t && t.resetChildVisibleState(this), this } },
        br = { updateChildAlpha: function(t) { var e = Xs(t),
                    i = e.parent; return e.syncAlpha && (t.alpha = i.alpha * e.alpha), this }, syncAlpha: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildAlpha, this), this }, resetChildAlphaState: function(t) { var e = Xs(t),
                    i = e.parent; return e.alpha = Vs(t.alpha, i.alpha), this }, setChildAlpha: function(t, e) { return t.alpha = e, this.resetChildAlphaState(t), this }, setChildLocalAlpha: function(t, e) { return Xs(t).alpha = e, this.updateChildAlpha(t), this }, resetLocalAlphaState: function() { var t = Xs(this).parent; return t && t.resetChildAlphaState(this), this } },
        xr = { updateChildActive: function(t) { var e = Xs(t),
                    i = e.parent; return t.active = i.active && e.active, this }, syncActive: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildActive, this), this }, resetChildActiveState: function(t) { return Xs(t).active = t.active, this }, setChildActive: function(t, e) { return t.active = e, this.resetChildActiveState(t), this }, setChildLocalActive: function(t, e) { return void 0 === e && (e = !0), Xs(t).active = e, this.updateChildActive(t), this }, resetLocalActiveState: function() { var t = Xs(this).parent; return t && t.resetChildActiveState(this), this } },
        Cr = { updateChildScrollFactor: function(t) { var e = Xs(t).parent; return t.setScrollFactor(e.scrollFactorX, e.scrollFactorY), this }, syncScrollFactor: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildScrollFactor, this), this } },
        wr = { updateChildMask: function(t) { return null == this.mask || (this.mask.hasOwnProperty("geometryMask") ? this.mask.geometryMask : this.mask.bitmapMask) !== t && (t.mask = this.mask), this }, syncMask: function() { return this.syncChildrenEnable && this.children.forEach(this.updateChildMask, this), this }, setMask: function(t) { return this.mask = t, this }, clearMask: function(t) { return void 0 === t && (t = !1), this._mask = null, this.children.forEach(function(t) { t.clearMask(!1) }), t && this.mask && this.mask.destroy(), this } },
        Sr = { setDepth: function(t, e) { if (this.depth = t, !e && this.children)
                    for (var i = this.getAllChildren(), n = 0, s = i.length; n < s; n++) i[n].depth = t; return this }, swapDepth: function(t) { var e = this.depth,
                    i = t.depth; return this.setDepth(i), t.setDepth(e), this }, incDepth: function(t) { if (this.depth += t, this.children)
                    for (var e = this.getAllChildren(), i = 0, n = e.length; i < n; i++) e[i].depth += t; return this }, bringToTop: function() { var t = this.displayList,
                    e = this.getAllChildren([this]);
                Us(e, !1); for (var i = 0, n = e.length; i < n; i++) { var s = e[i];
                    t.exists(s) && t.bringToTop(s) } return this }, moveDepthBelow: function(t) { var e = this.displayList; if (t.displayList !== e) return this; var i = this.getAllChildren([this]);
                Us(i, !1); for (var n = 0, s = i.length; n < s; n++) { var r = i[n]; if (e.exists(r)) { e.moveBelow(t, r); break } } return this }, moveDepthAbove: function(t) { var e = this.displayList; if (t.displayList !== e) return this; var i = this.getAllChildren([this]);
                Us(i, !0); for (var n = 0, s = i.length; n < s; n++) { var r = i[n]; if (e.exists(r)) { e.moveAbove(t, r); break } } return this } },
        Pr = Phaser.Utils.Array,
        Tr = { getChildren: function(t) { if (t)
                    for (var e = 0, i = this.children.length; e < i; e++) t.push(this.children[e]);
                else t = this.children; return t }, getAllChildren: function(e) { void 0 === e && (e = []); var i = this; return Hs(i, function(t) { t !== i && e.push(t) }), e }, getAllVisibleChildren: function(e) { void 0 === e && (e = []); var i = this; return Hs(i, function(t) { if (t !== i) return !t.visible || void e.push(t) }), e }, bfs: function(t, e) { return void 0 === e && (e = this), Hs(e, t), this }, dfs: function(t, e) { return void 0 === e && (e = this),
                    function t(e, i) { if (!i(e) && e.isRexContainerLite)
                            for (var n = e.children, s = 0, r = n.length; s < r; s++) t(n[s], i) }(e, t), this }, contains: function(t) { var e = Fs(t); return !!e && (e === this || this.contains(e)) }, getByName: function(t, e) { if (e) { for (var i, n, s = [this]; s.length;)
                        for (var r = 0, o = (i = s.shift()).children.length; r < o; r++) { if ((n = i.children[r]).name === t) return n;
                            n.isRexContainerLite && s.push(n) }
                    return null } return Pr.GetFirst(this.children, "name", t) }, getRandom: function(t, e) { return Pr.GetRandom(this.children, t, e) }, getFirst: function(t, e, i, n) { return Pr.GetFirstElement(this.children, t, e, i, n) }, getAll: function(t, e, i, n) { return Pr.GetAll(this.children, t, e, i, n) }, count: function(t, e, i, n) { return Pr.CountAllMatching(this.children, t, e, i, n) }, swap: function(t, e) { return Pr.Swap(this.children, t, e), this }, setAll: function(t, e, i, n) { return Pr.SetAll(this.children, t, e, i, n), this } },
        Or = { tweenChild: function(t) { var e = t.targets;
                Array.isArray(e) || (e = [e]); var i = this.scene || function(t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e].scene; if (n) return n } return null }(e); if (i) { t.targets = Ns(e); var n = i.tweens.add(t); return n.on("update", Js), n } }, tweenSelf: function(t) { return t.targets = [this], this.tweenChild(t) }, createTweenChildConfig: function(t) { var e = t.targets;
                e && (Array.isArray(e) || (e = [e]), t.targets = Ns(e)); var i = t.onUpdate; return t.onUpdate = function(t, e) { i && i(t, e), Js(t, void 0, e) }, t }, tween: function(t) { var e = this.scene; return t.targets || (t.targets = this), e.tweens.add(t) }, timelineChild: function(t) { var e = t.targets;
                e && (Array.isArray(e) || (e = [e]), t.targets = Ns(e)); for (var i = t.tweens, n = 0, s = i.length; n < s; n++) i[n] = this.createTweenChildConfig(i[n]); return this.scene.tweens.timeline(t) } },
        Mr = { addToLayer: Ks, addToContainer: Ks, removeFromContainer: function() { if (!this.parentContainer) return this;
                this._setParentContainerFlag = !0; var t = this.getAllChildren([this]); return Us(t), t.reverse(), this.parentContainer.remove(t), this._setParentContainerFlag = !1, this } },
        Er = { enableLayer: function() { if (this.layer) return this; var t = this.scene.add.layer(); return this.moveDepthBelow(t), this.addToLayer(t), this.layer = t, this }, getLayer: function() { return this.layer || this.enableLayer(), this.layer }, getRenderLayer: function() { if (this.layer) return this.layer; for (var t = this.getParent(); t;) { var e = t.layer; if (e) return e;
                    t = t.getParent() } return null }, addToRenderLayer: function(t) { if (!t.displayList) return this; var e = this.getRenderLayer(); return e && (t.isRexContainerLite ? t.addToLayer(e) : e.add(t), Xs(t).layer = e), this }, removeFromRenderLayer: function(t) { var e = Xs(t),
                    i = e.layer; return i && (i.remove(t), e.layer = null), this } },
        _r = Phaser.Geom.Rectangle,
        Rr = Phaser.Math.Vector2,
        Br = Phaser.Math.RotateAround,
        Ir = void 0,
        Lr = function(t, e, i) { return void 0 === e ? e = new Rr() : !0 === e && (void 0 === zr && (zr = new Rr()), e = zr), t.getTopLeft ? t.getTopLeft(e) : (e.x = t.x - Zs(t) * t.originX, e.y = t.y - qs(t) * t.originY, Fr(t, e, i)) },
        Ar = function(t, e, i) { return void 0 === e ? e = new Rr() : !0 === e && (void 0 === zr && (zr = new Rr()), e = zr), t.getTopRight ? t.getTopRight(e) : (e.x = t.x - Zs(t) * t.originX + Zs(t), e.y = t.y - qs(t) * t.originY, Fr(t, e, i)) },
        jr = function(t, e, i) { return void 0 === e ? e = new Rr() : !0 === e && (void 0 === zr && (zr = new Rr()), e = zr), t.getBottomLeft ? t.getBottomLeft(e) : (e.x = t.x - Zs(t) * t.originX, e.y = t.y - qs(t) * t.originY + qs(t), Fr(t, e, i)) },
        Dr = function(t, e, i) { return void 0 === e ? e = new Rr() : !0 === e && (void 0 === zr && (zr = new Rr()), e = zr), t.getBottomRight ? t.getBottomRight(e) : (e.x = t.x - Zs(t) * t.originX + Zs(t), e.y = t.y - qs(t) * t.originY + qs(t), Fr(t, e, i)) },
        zr = void 0,
        Fr = function(t, e, i) { void 0 === i && (i = !1), 0 !== t.rotation && Br(e, t.x, t.y, t.rotation), i && t.parentContainer && t.parentContainer.getBoundsTransformMatrix().transformPoint(e.x, e.y, e); return e },
        Yr = Phaser.Geom.Rectangle,
        Xr = Phaser.Geom.Rectangle.Union,
        Wr = Phaser.Utils.Objects.GetValue,
        Gr = { snapshot: function(t) { var e = this.scaleX,
                    i = this.scaleY,
                    n = 1 === e && 1 === i;
                n || this.setScale(1), void 0 === t && (t = {}), t.gameObjects = this.getAllVisibleChildren(), t.x = this.x, t.y = this.y, t.originX = this.originX, t.originY = this.originY; var s = Qs(t),
                    r = !!s.scene; return n || (this.setScale(e, i), r && s.setScale(e, i)), r ? s : this } },
        Vr = Phaser.Utils.Objects.GetValue,
        Ur = [void 0, void 0, void 0, void 0],
        Hr = Phaser.Utils.Objects.GetValue,
        Nr = Phaser.Math.RotateAround,
        Jr = { changeOrigin: function(t, e) { this.syncChildrenEnable = !1,
                    function(t, e, i) { void 0 === i && (i = e); var n = { x: (e - t.originX) * t.displayWidth, y: (i - t.originY) * t.displayHeight };
                        Nr(n, 0, 0, t.rotation), t.originX = e, t.originY = i, t.x = t.x + n.x, t.y = t.y + n.y }(this, t, e), this.syncChildrenEnable = !0; for (var i = this.getAllChildren(), n = 0, s = i.length; n < s; n++) this.resetChildPositionState(i[n]); return this }, drawBounds: function(t, e) { for (var i = Hr(e, "drawContainer", !0), n = this.getAllVisibleChildren([this]), s = 0, r = n.length; s < r; s++) { var o = n[s];!i && o.isRexContainerLite || tr(o, t, e) } return this } };
    Object.assign(Jr, sr, hr, cr, dr, pr, vr, yr, mr, kr, br, xr, Cr, wr, Sr, Tr, Or, Mr, Er, Gr); var Kr = function() { w(h, Ds); var a = T(h);

        function h(t, e, i, n, s, r) { var o; return X(this, h), Array.isArray(n) && (r = n, s = n = void 0), (o = a.call(this, t, e, i, n, s)).type = "rexContainerLite", o.isRexContainerLite = !0, o.syncChildrenEnable = !0, o._active = !0, o._mask = null, o._scrollFactorX = 1, o._scrollFactorY = 1, o.layer = void 0, r && o.add(r), o } return k(h, [{ key: "destroy", value: function(t) { this.scene && (this.syncChildrenEnable = !1, O(C(h.prototype), "destroy", this).call(this, t), this.layer && (this.layer.list.length = 0, this.layer.destroy())) } }, { key: "resize", value: function(t, e) { return this.setSize(t, e), this } }, { key: "x", get: function() { return this._x }, set: function(t) { this._x !== t && (this._x = t, this.syncPosition()) } }, { key: "y", get: function() { return this._y }, set: function(t) { this._y !== t && (this._y = t, this.syncPosition()) } }, { key: "rotation", get: function() { return O(C(h.prototype), "rotation", this) }, set: function(t) { this.rotation !== t && (e(C(h.prototype), "rotation", t, this, !0), this.syncPosition()) } }, { key: "scaleX", get: function() { return O(C(h.prototype), "scaleX", this) }, set: function(t) { this.scaleX !== t && (e(C(h.prototype), "scaleX", t, this, !0), this.syncPosition()) } }, { key: "scaleY", get: function() { return O(C(h.prototype), "scaleY", this) }, set: function(t) { this.scaleY !== t && (e(C(h.prototype), "scaleY", t, this, !0), this.syncPosition()) } }, { key: "scale", get: function() { return O(C(h.prototype), "scale", this) }, set: function(t) { this.scale !== t && (e(C(h.prototype), "scale", t, this, !0), this.syncPosition()) } }, { key: "visible", get: function() { return O(C(h.prototype), "visible", this) }, set: function(t) { O(C(h.prototype), "visible", this) !== t && (e(C(h.prototype), "visible", t, this, !0), this.syncVisible()) } }, { key: "alpha", get: function() { return O(C(h.prototype), "alpha", this) }, set: function(t) { O(C(h.prototype), "alpha", this) !== t && (e(C(h.prototype), "alpha", t, this, !0), this.syncAlpha()) } }, { key: "active", get: function() { return this._active }, set: function(t) { this._active !== t && (this._active = t, this.syncActive()) } }, { key: "mask", get: function() { return this._mask }, set: function(t) { this._mask !== t && (this._mask = t, this.syncMask()) } }, { key: "scrollFactorX", get: function() { return this._scrollFactorX }, set: function(t) { this._scrollFactorX !== t && (this._scrollFactorX = t, this.syncScrollFactor()) } }, { key: "scrollFactorY", get: function() { return this._scrollFactorY }, set: function(t) { this._scrollFactorY !== t && (this._scrollFactorY = t, this.syncScrollFactor()) } }, { key: "list", get: function() { return this.children } }, { key: "parentContainer", get: function() { return this._parentContainer }, set: function(t) {!this._parentContainer && !t || this.setParentContainerFlag ? this._parentContainer = t : this._parentContainer && !t ? (this.removeFromContainer(), this._parentContainer = t) : t ? (this._parentContainer = t, this.addToContainer(t)) : this._parentContainer = t } }, { key: "setParentContainerFlag", get: function() { if (this._setParentContainerFlag) return !0; var t = Fs(this); return !!t && t.setParentContainerFlag } }], [{ key: "GetParent", value: function(t) { return Fs(t) } }]), h }();
    Object.assign(Kr.prototype, Jr), p.register("container", function(t, e, i, n, s) { var r = new Kr(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.Container", Kr), p.register("canvas", function(t, e, i, n) { var s = new Qt(this.scene, t, e, i, n); return this.scene.add.existing(s), s }), j(window, "RexPlugins.UI.Canvas", Qt); var Zr = Phaser.Utils.Objects.GetValue,
        qr = function() { w(h, Qt); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), (o = a.call(this, t, e, i)).type = "rexCircleMaskImage", o.setTexture(n, s, r), o } return k(h, [{ key: "setTexture", value: function(t, e, i) { "object" === P(e) && (i = e, e = void 0), "string" == typeof i && (i = { maskType: i }); var n = Zr(i, "maskType", 0),
                        s = Zr(i, "backgroundColor", void 0); if (void 0 === n ? n = 0 : "string" == typeof n && (n = $r[n]), this._textureKey = t, this._frameName = e, null === n) return this.loadTexture(t, e), this.dirty = !0, this; var r = null != s;
                    r || this.loadTexture(t, e); var o = this.canvas,
                        a = this.context,
                        h = o.width,
                        l = o.height; switch (a.save(), a.globalCompositeOperation = r ? "source-over" : "destination-in", a.beginPath(), n) {
                        case 2:
                            var u = Zr(i, "radius", 0),
                                c = Zr(i, "iteration", void 0);
                            ie(a, 0, 0, h, l, u, c); break;
                        default:
                            var d = Math.floor(h / 2),
                                f = Math.floor(l / 2);
                            0 === n ? a.arc(d, f, Math.min(d, f), 0, 2 * Math.PI) : a.ellipse(d, f, d, f, 0, 0, 2 * Math.PI) } return r && (a.fillStyle = s), a.fill(), a.restore(), r && (a.save(), a.globalCompositeOperation = "destination-atop", this.loadTexture(t, e), a.restore()), this.dirty = !0, this } }, { key: "resize", value: function(t, e) { return this.setDisplaySize(t, e), this } }]), h }(),
        $r = { circle: 0, ellipse: 1, roundRectangle: 2 };
    p.register("circleMaskImage", function(t, e, i, n, s) { var r = new qr(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.CircleMaskImage", qr); var Qr = Phaser.Utils.Objects.GetValue,
        to = function() { w(h, Qt); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), (o = a.call(this, t, e, i)).type = "rexAlphaMaskImage", o.maskFrame = null, o.setTexture(n, s, r), o } return k(h, [{ key: "setTexture", value: function(t, e, i) { "object" === P(e) && (i = e, e = void 0), "string" == typeof i && (i = { mask: { key: i } }); var n = Qr(i, "mask.key"),
                        s = Qr(i, "mask.frame"),
                        r = Qr(i, "mask.invertAlpha", !1),
                        o = Qr(i, "mask.scale"),
                        a = Qr(i, "backgroundColor"); if (n) { this._maskKey = n, this._maskFrame = s, this._maskScale = o; var h = n ? this.scene.sys.textures.get(n) : null;
                        this.maskFrame = h ? h.get(s) : null }
                    this._textureKey = t, this._frameName = e; var l = this.maskFrame; if (null === l) return this.loadTexture(t, e), this.dirty = !0, this; var u = null != a;
                    this.loadTexture(t, e); var c, d, f = this.canvas,
                        p = this.context,
                        v = f.width,
                        g = f.height;
                    p.save(), p.globalCompositeOperation = r ? "destination-out" : "destination-in", d = null != this._maskScale ? (c = l.cutWidth * this._maskScale, l.cutHeight * this._maskScale) : (c = v, g); var y = (v - c) / 2,
                        m = (g - d) / 2; return this.drawFrame(this._maskKey, this._maskFrame, y, m, c, d), p.restore(), u && (p.save(), p.globalCompositeOperation = "destination-over", p.fillStyle = a, p.fillRect(0, 0, v, g), p.restore()), this.dirty = !0, this } }, { key: "resize", value: function(t, e) { return this.setDisplaySize(t, e), this } }]), h }();
    p.register("alphaMaskImage", function(t, e, i, n, s) { var r = new to(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.AlphaMaskImage", to);

    function eo(t, e) { return void 0 === e ? t : t[e] }

    function io(t, e, i) { void 0 === t && (t = {}), void 0 === e && (e = 0); var n = P(e); return "string" === n ? t[e] = i : "number" === n ? (t.left = e, t.right = e, t.top = e, t.bottom = e) : (t.left = no(e, "left", 0), t.right = no(e, "right", 0), t.top = no(e, "top", 0), t.bottom = no(e, "bottom", 0)), t } var no = Phaser.Utils.Objects.GetValue,
        so = function() {
            function i(t, e) { X(this, i), this.setParent(t), this.type = e, this.renderable = !1, this.reset().setActive() } return k(i, [{ key: "destroy", value: function() { this.parent.removeChild(this) } }, { key: "setParent", value: function(t) { return this.parent = t, this } }, { key: "scene", get: function() { return this.parent.scene } }, { key: "canvas", get: function() { return this.parent ? this.parent.canvas : null } }, { key: "context", get: function() { return this.parent ? this.parent.context : null } }, { key: "setDirty", value: function(t) { return t && this.parent && (this.parent.dirty = !0), this } }, { key: "active", get: function() { return this._active }, set: function(t) { this.setDirty(this._active != t), this._active = t } }, { key: "setActive", value: function(t) { return void 0 === t && (t = !0), this.active = t, this } }, { key: "modifyPorperties", value: function() { return this } }, { key: "onFree", value: function() { this.reset().setParent() } }, { key: "reset", value: function() { return this } }, { key: "render", value: function() {} }, { key: "contains", value: function() { return !1 } }]), i }();
    Object.assign(so.prototype, ht); var ro, oo, ao = { renderContent: function() {}, render: function() { if (!this.willRender) return this; var t = this.context; if (t.save(), t.globalAlpha = this.alpha, this.toLocalPosition) { var e = this.drawX,
                        i = this.drawY;
                    this.autoRound && (e = Math.round(e), i = Math.round(i)), t.translate(e, i), t.scale(this.scaleX, this.scaleY), t.rotate(this.rotation) } return this.drawBelowCallback && this.drawBelowCallback(this), this.renderContent(), this.drawAboveCallback && this.drawAboveCallback(this), t.restore(), this } },
        ho = Phaser.Math.RotateAround,
        lo = Phaser.Geom.Rectangle,
        uo = function(t) { void 0 === oo && (oo = new lo()); var e = t.drawTLX,
                i = t.drawTLY; return oo.setTo(e, i, t.drawTRX - e, t.drawBLY - i), oo },
        co = { contains: function(t, e) { if (0 === this.width || 0 === this.height) return !1; var i, n, s, r, o = (i = t, n = e, s = this, void 0 === (r = !0) ? r = {} : !0 === r && (void 0 === ro && (ro = {}), r = ro), r.x = (i - s.drawX) / s.scaleX, r.y = (n - s.drawY) / s.scaleY, 0 !== s.rotation && ho(r, 0, 0, -s.rotation), r); return uo(this).contains(o.x, o.y) } };
    Object.assign(co, ao); var fo = Phaser.Math.DegToRad,
        po = Phaser.Math.RadToDeg,
        vo = Phaser.Utils.Objects.GetValue,
        go = function() { w(s, so); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).renderable = !0, i.toLocalPosition = !0, i.originX = 0, i.offsetX = 0, i.offsetY = 0, i } return k(s, [{ key: "visible", get: function() { return this._visible }, set: function(t) { this.setDirty(this._visible != t), this._visible = t } }, { key: "setVisible", value: function(t) { return void 0 === t && (t = !0), this.visible = t, this } }, { key: "alpha", get: function() { return this._alpha }, set: function(t) { this.setDirty(this._alpha != t), this._alpha = t } }, { key: "setAlpha", value: function(t) { return this.alpha = t, this } }, { key: "x", get: function() { return this._x }, set: function(t) { this.setDirty(this._x != t), this._x = t } }, { key: "setX", value: function(t) { return this.x = t, this } }, { key: "y", get: function() { return this._y }, set: function(t) { this.setDirty(this._y != t), this._y = t } }, { key: "setY", value: function(t) { return this.y = t, this } }, { key: "setPosition", value: function(t, e) { return this.x = t, this.y = e, this } }, { key: "setInitialPosition", value: function(t, e) { return this.x0 = t, this.y0 = e, this } }, { key: "rotation", get: function() { return this._rotation }, set: function(t) { this.setDirty(this._rotation != t), this._rotation = t } }, { key: "setRotation", value: function(t) { return this.rotation = t, this } }, { key: "angle", get: function() { return po(this._rotation) }, set: function(t) { this.rotation = fo(t) } }, { key: "setAngle", value: function(t) { return this.angle = t, this } }, { key: "scaleX", get: function() { return this._scaleX }, set: function(t) { this.setDirty(this._scaleX !== t), this._scaleX = t } }, { key: "setScaleX", value: function(t) { return this.scaleX = t, this } }, { key: "width", get: function() { return 0 }, set: function() {} }, { key: "setWidth", value: function(t, e) { return void 0 === e && (e = !1), this.width = t, e && (this.scaleY = this.scaleX), this } }, { key: "leftSpace", get: function() { return this._leftSpace }, set: function(t) { this.setDirty(this._leftSpace !== t), this._leftSpace = t } }, { key: "setLeftSpace", value: function(t) { return this.leftSpace = t, this } }, { key: "rightSpace", get: function() { return this._rightSpace }, set: function(t) { this.setDirty(this._rightSpace !== t), this._rightSpace = t } }, { key: "setRightSpace", value: function(t) { return this.rightSpace = t, this } }, { key: "outerWidth", get: function() { return this.width + this.leftSpace + this.rightSpace } }, { key: "scaleY", get: function() { return this._scaleY }, set: function(t) { this.setDirty(this._scaleY !== t), this._scaleY = t } }, { key: "setScaleY", value: function(t) { return this.scaleY = t, this } }, { key: "height", get: function() { return 0 }, set: function() {} }, { key: "setHeight", value: function(t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "setScale", value: function(t, e) { return void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this } }, { key: "setOrigin", value: function(t) { return this.originX = t, this } }, { key: "setAlign", value: function(t) { return this.align = t, this } }, { key: "modifyPorperties", value: function(t) { if (!t) return this;
                    t.hasOwnProperty("x") && this.setX(t.x), t.hasOwnProperty("y") && this.setY(t.y), t.hasOwnProperty("rotation") ? this.setRotation(t.rotation) : t.hasOwnProperty("angle") && this.setAngle(t.angle), t.hasOwnProperty("alpha") && this.setAlpha(t.alpha); var e = vo(t, "width", void 0),
                        i = vo(t, "height", void 0),
                        n = vo(t, "scaleX", void 0),
                        s = vo(t, "scaleY", void 0); return void 0 !== e ? void 0 === i && void 0 === s ? this.setWidth(e, !0) : this.setWidth(e) : void 0 !== n && this.setScaleX(n), void 0 !== i ? void 0 === e && void 0 === n ? this.setHeight(i, !0) : this.setHeight(i) : void 0 !== s && this.setScaleY(s), t.hasOwnProperty("leftSpace") && this.setLeftSpace(t.leftSpace), t.hasOwnProperty("rightSpace") && this.setRightSpace(t.rightSpace), t.hasOwnProperty("align") && this.setAlign(t.align), this } }, { key: "setDrawBelowCallback", value: function(t) { return this.drawBelowCallback = t, this } }, { key: "setDrawAboveCallback", value: function(t) { return this.drawAboveCallback = t, this } }, { key: "reset", value: function() { return this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback(), this } }, { key: "willRender", get: function() { return this.visible && 0 < this.alpha } }, { key: "drawX", get: function() { return this.x + this.leftSpace + this.offsetX - this.originX * this.width } }, { key: "drawY", get: function() { return this.y + this.offsetY } }, { key: "drawTLX", get: function() { return 0 } }, { key: "drawTLY", get: function() { return 0 } }, { key: "drawBLX", get: function() { return 0 } }, { key: "drawBLY", get: function() { return 0 } }, { key: "drawTRX", get: function() { return 0 } }, { key: "drawTRY", get: function() { return 0 } }, { key: "drawBRX", get: function() { return 0 } }, { key: "drawBRY", get: function() { return 0 } }, { key: "drawCenterX", get: function() { return (this.drawTRX + this.drawTLX) / 2 } }, { key: "drawCenterY", get: function() { return (this.drawBLY + this.drawTLY) / 2 } }]), s }();
    Object.assign(go.prototype, co);

    function yo(t, e, i) { return e.hasOwnProperty(t) ? e[t] : i[t] }

    function mo(t, e) { var i, n, s, r = Array.isArray(t); return void 0 === e || e === this.children.length ? r ? (i = this.children).push.apply(i, M(t)) : this.children.push(t) : r ? (n = this.children).splice.apply(n, [e, 0].concat(M(t))) : this.children.splice(e, 0, t), this.lastAppendedChildren.length = 0, r ? (s = this.lastAppendedChildren).push.apply(s, M(t)) : this.lastAppendedChildren.push(t), this }

    function ko(t) { return t.type === Yo && "\n" === t.text }

    function bo(t) { return t.type === Yo }

    function xo(t, e) { var i = this.createCharChildren(t, e); return this.addChild(i), this }

    function Co(t, e, i) { var n = this.createImageChild(t, e, i); return this.addChild(n), this }

    function wo(t) { var e = this.createSpaceChild(t); return this.addChild(e), this }

    function So(t, e, i, n) { var s = this.createCommandChild(t, e, i, n); return this.addChild(s), this }

    function Po(t, e, i, n) { void 0 === n && (n = { word: [], width: 0 }), n.word.length = 0; for (var s = t.length, r = e, o = n.word, a = 0; r < s;) { var h = t[r]; if (h.renderable) { if (h.type !== Yo || " " === h.text || "\n" === h.text) { r === e && (o.push(h), a += h.outerWidth); break } if (o.push(h), a += h.outerWidth, r++, i) break } else o.push(h), r++ } return n.width = a, n }

    function To(t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e]; if (void 0 !== n.align) return n.align } }

    function Oo(t, e, i) { if (0 !== e || 0 !== i)
            for (var n = 0, s = t.length; n < s; n++) { var r = t[n];
                r.renderable && (r.x += e, r.y += i) } }

    function Mo(t) { var e = No(t, "start", 0);
        io(this.wrapPadding, No(t, "padding", 0)); var i, n = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom,
            s = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right,
            r = No(t, "lineHeight", void 0); if (void 0 === r) i = No(t, "maxLines", 0), r = 0 < this.fixedHeight ? (o = this.fixedHeight - n) / i : 0;
        else if (0 < this.fixedHeight) { if (void 0 === (i = No(t, "maxLines", void 0))) { var o = this.fixedHeight - n;
                i = Math.floor(o / r) } } else i = No(t, "maxLines", 0); var a = 0 === i,
            h = No(t, "wrapWidth", void 0);
        void 0 === h && (h = 0 < this.fixedWidth ? this.fixedWidth - s : 1 / 0); for (var l = No(t, "letterSpacing", 0), u = No(t, "hAlign", 0), c = No(t, "vAlign", 0), d = No(t, "charWrap", !1), f = { start: e, isLastPage: !1, padding: this.wrapPadding, lineHeight: r, maxLines: i, wrapWidth: h, letterSpacing: l, hAlign: u, vAlign: c, charWrap: d, children: [], lines: [], maxLineWidth: 0, linesHeight: 0 }, p = this.children, v = 0, g = p.length; v < g; v++) p[v].setActive(!1);
        h += l; for (var y, m = this.padding.left + this.wrapPadding.left, k = m, b = this.padding.top + this.wrapPadding.top + r, x = h, C = e, w = p.length, S = f.children, P = f.lines, T = [], O = 0, M = 0; C < w;) { var E = (y = Po(p, C, d, y)).word,
                _ = E.length,
                R = y.width + _ * l;
            C += _; var B = ko(E[0]); if (x < R || B) { if (B) { var I = E[0];
                    I.setActive().setPosition(k, b), S.push(I), T.push(I) } if (k = m, b += r, x = h, P.push({ children: T, width: O }), M = Math.max(M, O), O = 0, T = [], !a && P.length === i) break; if (B) continue }
            x -= R, O += R; for (v = 0, g = E.length; v < g; v++) {
                (j = E[v]).setActive(), S.push(j), T.push(j), j.renderable && (j.setPosition(k, b), k += j.outerWidth + l) } }
        0 < T.length && (P.push({ children: T, width: O }), M = Math.max(M, O)), f.start += S.length, f.isLastPage = f.start === w, f.maxLineWidth = M, f.linesHeight = P.length * r; var L = 0 < this.fixedWidth ? this.fixedWidth : f.maxLineWidth + s,
            A = 0 < this.fixedHeight ? this.fixedHeight : f.linesHeight + n; for (! function(t, e, i) { var n, s, r = t.hAlign,
                    o = t.vAlign,
                    a = t.linesHeight; switch (o) {
                    case 1:
                    case "center":
                        s = (i - a) / 2; break;
                    case 2:
                    case "bottom":
                        s = i - a; break;
                    default:
                        s = 0 } for (var h = t.lines, l = 0, u = h.length; l < u; l++) { var c = h[l],
                        d = c.width,
                        f = c.children,
                        p = To(f); switch (void 0 === p && (p = r), p) {
                        case 1:
                        case "center":
                            n = (e - d) / 2; break;
                        case 2:
                        case "right":
                            n = e - d; break;
                        default:
                            n = 0 }
                    Oo(f, n, s) } }(f, L - s, o = A - n), this.setSize(L, A), v = 0, g = S.length; v < g; v++) { var j;
            (j = S[v]).renderable && (j.x0 = j.x, j.y0 = j.y) } return f }

    function Eo(t) { var e = Ko(t, "start", 0);
        io(this.wrapPadding, Ko(t, "padding", 0)); var i, n = this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom,
            s = this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right,
            r = Ko(t, "lineWidth", void 0); if (void 0 === r) i = Ko(t, "maxLines", 0), r = 0 < this.fixedWidth ? (o = this.fixedWidth - s) / i : 0;
        else if (0 < this.fixedWidth) { if (void 0 === (i = Ko(t, "maxLines", void 0))) { var o = this.fixedWidth - s;
                i = Math.floor(o / r) + 1 } } else i = Ko(t, "maxLines", 0); var a = 0 === i,
            h = Ko(t, "fixedChildHeight", void 0); if (void 0 === h) { var l = Ko(t, "charPerLine", void 0); if (void 0 !== l) { var u = this.fixedHeight - n;
                h = Math.floor(u / l) } } var c = Ko(t, "wrapHeight", void 0);
        void 0 === c && (c = 0 < this.fixedHeight ? this.fixedHeight - n : 1 / 0); for (var d = Ko(t, "letterSpacing", 0), f = Ko(t, "rtl", !0), p = Ko(t, "hAlign", f ? 2 : 0), v = Ko(t, "vAlign", 0), g = { start: e, isLastPage: !1, padding: this.wrapPadding, lineWidth: r, maxLines: i, fixedChildHeight: h, wrapHeight: c, letterSpacing: d, hAlign: p, vAlign: v, rtl: f, children: [], lines: [], maxLineHeight: 0, linesWidth: 0 }, y = this.children, m = 0, k = y.length; m < k; m++) y[m].setActive(!1);
        c += d; for (var b = this.padding.left + this.wrapPadding.left, x = this.padding.top + this.wrapPadding.top, C = b, w = x, S = c, P = e, T = y.length, O = g.children, M = g.lines, E = [], _ = 0, R = 0; P < T;) { var B = y[P]; if (P++, D.renderable) { var I = (void 0 !== h ? h : B.height) + d,
                    L = ko(B); if (S < I || L) { if (L && (B.setActive().setPosition(C, w).setOrigin(.5), O.push(B), E.push(B)), C = b, w = x, S = c, M.push({ children: E, height: _ }), R = Math.max(R, _), _ = 0, E = [], !a && M.length === i) break; if (L) continue }
                S -= I, _ += I, B.setActive().setPosition(C, w).setOrigin(.5), O.push(B), E.push(B), w += I } else B.setActive(), O.push(B), E.push(B) }
        0 < E.length && (M.push({ children: E, height: _ }), R = Math.max(R, _)), g.start += O.length, g.isLastPage = g.start === T, g.maxLineHeight = R, g.linesWidth = M.length * r; var A = 0 < this.fixedWidth ? this.fixedWidth : g.linesWidth + s,
            j = 0 < this.fixedHeight ? this.fixedHeight : g.maxLineHeight + n; for (! function(t, e, i) { var n, s, r = t.hAlign,
                    o = t.vAlign,
                    a = t.rtl,
                    h = t.lines,
                    l = t.lineWidth,
                    u = t.linesWidth; switch (r) {
                    case 1:
                    case "center":
                        n = (e - u) / 2; break;
                    case 2:
                    case "right":
                        n = e - u; break;
                    default:
                        n = 0 }
                a && (n += l); for (var c = 0, d = h.length; c < d; c++) { var f = h[a ? d - c - 1 : c],
                        p = f.children,
                        v = f.height,
                        g = To(p); switch (void 0 === g && (g = o), g) {
                        case 1:
                        case "center":
                            s = (i - v) / 2; break;
                        case 2:
                        case "bottom":
                            s = i - v; break;
                        default:
                            s = 0 }
                    Oo(p, n, s), n += l } }(g, o = A - s, u = j - n), this.setSize(A, j), m = 0, k = O.length; m < k; m++) { var D = O[m];
            D.renderable && (D.x0 = D.x, D.y0 = D.y) } return g }

    function _o(t, e) { return i = t.drawCenterX, n = t.drawCenterY, s = t, void 0 === (r = e) ? r = {} : !0 === r && (void 0 === Bo && (Bo = {}), r = Bo), r.x = i, r.y = n, 0 !== s.rotation && $o(r, 0, 0, s.rotation), r.x = r.x * s.scaleX + s.drawX, r.y = r.y * s.scaleY + s.drawY, r; var i, n, s, r }

    function Ro(t, e, i) { for (var n = 0, s = (t = t).length; n < s; n++) { var r = t[n]; if (r.active && r.renderable && r.contains(e, i)) return r } return null } var Bo, Io = Phaser.Utils.Objects.GetValue,
        Lo = function() { w(s, go); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, "background")).setColor(Io(e, "color", null), Io(e, "color2", null), Io(e, "horizontalGradient", !0)), i.setStroke(Io(e, "stroke", null), Io(e, "strokeThickness", 2)), i.setCornerRadius(Io(e, "cornerRadius", 0), Io(e, "cornerIteration", null)), i } return k(s, [{ key: "color", get: function() { return this._color }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._color != t), this._color = t } }, { key: "color2", get: function() { return this._color2 }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._color2 != t), this._color2 = t } }, { key: "horizontalGradient", get: function() { return this._horizontalGradient }, set: function(t) { this.setDirty(this._horizontalGradient != t), this._horizontalGradient = t } }, { key: "setColor", value: function(t, e, i) { return void 0 === i && (i = !0), this.color = t, this.color2 = e, this.horizontalGradient = i, this } }, { key: "stroke", get: function() { return this._stroke }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._stroke != t), this._stroke = t } }, { key: "strokeThickness", get: function() { return this._strokeThickness }, set: function(t) { this.setDirty(this._strokeThickness != t), this._strokeThickness = t } }, { key: "setStroke", value: function(t, e) { return null != t && void 0 === e && (e = 2), this.stroke = t, this.strokeThickness = e, this } }, { key: "cornerRadius", get: function() { return this._cornerRadius }, set: function(t) { this.setDirty(this._cornerRadius != t), this._cornerRadius = t } }, { key: "cornerIteration", get: function() { return this._cornerIteration }, set: function(t) { this.setDirty(this._cornerIteration != t), this._cornerIteration = t } }, { key: "modifyPorperties", value: function(t) { O(C(s.prototype), "modifyPorperties", this).call(this, t), t.hasOwnProperty("color") && this.setColor(t.color, Io(t, "color2", null), Io(t, "horizontalGradient", !0)), t.hasOwnProperty("stroke") && this.setStroke(t.stroke, Io(t, "strokeThickness", 2)), t.hasOwnProperty("cornerRadius") && this.setCornerRadius(t.cornerRadius, Io(t, "cornerIteration", null)) } }, { key: "setCornerRadius", value: function(t, e) { return this.cornerRadius = t, this.cornerIteration = e, this } }, { key: "renderContent", value: function() { ne(this.parent, this.color, this.stroke, this.strokeThickness, this.cornerRadius, this.color2, this.horizontalGradient, this.cornerIteration) } }]), s }(),
        Ao = Phaser.Utils.Objects.GetValue,
        jo = function() { w(s, go); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, "innerbounds")).setColor(Ao(e, "color", null), Ao(e, "color2", null), Ao(e, "horizontalGradient", !0)), i.setStroke(Ao(e, "stroke", null), Ao(e, "strokeThickness", 2)), i } return k(s, [{ key: "color", get: function() { return this._color }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._color != t), this._color = t } }, { key: "color2", get: function() { return this._color2 }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._color2 != t), this._color2 = t } }, { key: "horizontalGradient", get: function() { return this._horizontalGradient }, set: function(t) { this.setDirty(this._horizontalGradient != t), this._horizontalGradient = t } }, { key: "setColor", value: function(t, e, i) { return void 0 === i && (i = !0), this.color = t, this.color2 = e, this.horizontalGradient = i, this } }, { key: "stroke", get: function() { return this._stroke }, set: function(t) { t = ee(t, this.canvas, this.context), this.setDirty(this._stroke != t), this._stroke = t } }, { key: "strokeThickness", get: function() { return this._strokeThickness }, set: function(t) { this.setDirty(this._strokeThickness != t), this._strokeThickness = t } }, { key: "setStroke", value: function(t, e) { return null != t && void 0 === e && (e = 2), this.stroke = t, this.strokeThickness = e, this } }, { key: "modifyPorperties", value: function(t) { O(C(s.prototype), "modifyPorperties", this).call(this, t), t.hasOwnProperty("color") && this.setColor(t.color, Ao(t, "color2", null), Ao(t, "horizontalGradient", !0)), t.hasOwnProperty("stroke") && this.setStroke(t.stroke, Ao(t, "strokeThickness", 2)) } }, { key: "renderContent", value: function() { var t = this.parent.padding,
                        e = t.left,
                        i = t.top,
                        n = this.parent.width - t.left - t.right,
                        s = this.parent.height - t.top - t.bottom,
                        r = this.context; if (null != this.color) { var o, a; if (null != this.color2)(a = this.horizontalGradient ? r.createLinearGradient(0, 0, n, 0) : r.createLinearGradient(0, 0, 0, s)).addColorStop(0, this.color), a.addColorStop(1, this.color2), o = a;
                        else o = this.color;
                        r.fillStyle = o, r.fillRect(e, i, n, s) }
                    null != this.stroke && 0 < this.strokeThickness && (r.strokeStyle = this.stroke, r.lineWidth = this.strokeThickness, r.strokeRect(e, i, n, s)) } }]), s }(),
        Do = Phaser.Utils.Objects.GetValue,
        zo = function() {
            function i(t, e) { X(this, i), this.parent = t, this.set(e) } return k(i, [{ key: "toJSON", value: function() { return { bold: this.bold, italic: this.italic, fontSize: this.fontSize, fontFamily: this.fontFamily, color: this.color, stroke: this.stroke, strokeThickness: this.strokeThickness, shaodwColor: this.shadowColor, shadowBlur: this.shadowBlur, shadowOffsetX: this.shadowOffsetX, shadowOffsetY: this.shadowOffsetY, offsetX: this.offsetX, offsetY: this.offsetY, leftSpace: this.leftSpace, rightSpace: this.rightSpace, align: this.align } } }, { key: "set", value: function(t) { return this.setBold(Do(t, "bold", !1)), this.setItalic(Do(t, "italic", !1)), this.setFontSize(Do(t, "fontSize", "16px")), this.setFontFamily(Do(t, "fontFamily", "Courier")), this.setColor(Do(t, "color", "#fff")), this.setStrokeStyle(Do(t, "stroke", null), Do(t, "strokeThickness", 0)), this.setShadow(Do(t, "shadowColor", null), Do(t, "shadowOffsetX", 0), Do(t, "shadowOffsetY", 0), Do(t, "shadowBlur", 0)), this.setOffset(Do(t, "offsetX", 0), Do(t, "offsetY", 0)), this.setSpace(Do(t, "leftSpace", 0), Do(t, "rightSpace", 0)), this.setAlign(Do(t, "align", void 0)), this.setBackgroundColor(Do(t, "backgroundColor", null)), this } }, { key: "modify", value: function(t) { return t.hasOwnProperty("bold") && this.setBold(t.bold), t.hasOwnProperty("italic") && this.setItalic(t.italic), t.hasOwnProperty("fontSize") && this.setFontSize(t.fontSize), t.hasOwnProperty("fontFamily") && this.setFontFamily(t.fontFamily), t.hasOwnProperty("color") && this.setColor(t.color), (t.hasOwnProperty("stroke") || t.hasOwnProperty("strokeThickness")) && this.setStrokeStyle(yo("stroke", t, this), yo("strokeThickness", t, this)), t.hasOwnProperty("shadowColor") && this.setShadowColor(t.shadowColor), (t.hasOwnProperty("shadowOffsetX") || t.hasOwnProperty("shadowOffsetY")) && this.setShadowOffset(yo("shadowOffsetX", t, this), yo("shadowOffsetY", t, this)), t.hasOwnProperty("shadowBlur") && this.setShadowBlur(t.shaodwBlur), t.hasOwnProperty("offsetX") && this.setOffsetX(t.offsetX), t.hasOwnProperty("offsetY") && this.setOffsetY(t.offsetY), t.hasOwnProperty("leftSpace") && this.setLeftSpace(t.leftSpace), t.hasOwnProperty("rightSpace") && this.setRightSpace(t.rightSpace), t.hasOwnProperty("align") && this.setAlign(t.align), t.hasOwnProperty("backgroundColor") && this.setBackgroundColor(t.backgroundColor), this } }, { key: "setUpdateTextFlag", value: function() { return this.parent && (this.parent.updateTextFlag = !0), this } }, { key: "clone", value: function() { return new i(null, this.toJSON()) } }, { key: "copyFrom", value: function(t) { return this.set(t.toJSON()), this } }, { key: "copyTo", value: function(t) { return t.set(this.toJSON()), this } }, { key: "setBold", value: function(t) { return void 0 === t && (t = !0), this.bold = t, this.setUpdateTextFlag(), this } }, { key: "setItalic", value: function(t) { return void 0 === t && (t = !0), this.italic = t, this.setUpdateTextFlag(), this } }, { key: "fontStyle", get: function() { return this.bold && this.italic ? "bold italic" : this.bold ? "bold" : this.italic ? "italic" : "" } }, { key: "setFontSize", value: function(t) { return "number" == typeof t && (t = "".concat(t, "px")), this.fontSize = t, this.setUpdateTextFlag(), this } }, { key: "setFontFamily", value: function(t) { return this.fontFamily = t, this.setUpdateTextFlag(), this } }, { key: "font", get: function() { return "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily) } }, { key: "setColor", value: function(t) { return this.color = ee(t), this } }, { key: "hasFill", get: function() { return null != this.color } }, { key: "setStrokeStyle", value: function(t, e) { return this.stroke = ee(t), void 0 !== e && (this.strokeThickness = e), this } }, { key: "setStrokeThickness", value: function(t) { return this.strokeThickness = t, this } }, { key: "hasStroke", get: function() { return null != this.stroke && 0 < this.strokeThickness } }, { key: "setShadowColor", value: function(t) { return this.shadowColor = ee(t), this } }, { key: "setShadowOffset", value: function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.shadowOffsetX = t, this.shadowOffsetY = e, this } }, { key: "setShadowBlur", value: function(t) { return void 0 === t && (t = 0), this.shaodwBlur = t, this } }, { key: "setShadow", value: function(t, e, i, n) { return this.setShadowColor(t).setShadowOffset(e, i).setShadowBlur(n), this } }, { key: "setBackgroundColor", value: function(t) { return this.backgroundColor = ee(t), this } }, { key: "hasBackgroundColor", get: function() { return null != this.backgroundColor } }, { key: "setOffsetX", value: function(t) { return void 0 === t && (t = 0), this.offsetX = t, this } }, { key: "setOffsetY", value: function(t) { return void 0 === t && (t = 0), this.offsetY = t, this } }, { key: "setOffset", value: function(t, e) { return this.setOffsetX(t).setOffsetY(e), this } }, { key: "setLeftSpace", value: function(t) { return void 0 === t && (t = 0), this.leftSpace = t, this } }, { key: "setRightSpace", value: function(t) { return void 0 === t && (t = 0), this.rightSpace = t, this } }, { key: "setSpace", value: function(t, e) { return this.setLeftSpace(t).setRightSpace(e), this } }, { key: "setAlign", value: function(t) { return this.align = t, this } }, { key: "syncFont", value: function(t) { return t.font = this.font, this } }, { key: "syncStyle", value: function(t) { t.textBaseline = "alphabetic"; var e = this.hasFill,
                        i = this.hasStroke; return t.fillStyle = e ? this.color : "#000", t.strokeStyle = i ? this.stroke : "#000", t.lineWidth = i ? this.strokeThickness : 0, t.lineCap = "round", t.lineJoin = "round", this } }, { key: "syncShadow", value: function(t) { null != t.shadowColor ? (t.shadowColor = this.shadowColor, t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowBlur = this.shadowBlur) : (t.shadowColor = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 0) } }, { key: "getTextMetrics", value: function(t, e) { return this.syncFont(t).syncStyle(t), t.measureText(e) } }]), i }(),
        Fo = Phaser.Utils.Array.Remove,
        Yo = "text",
        Xo = "command",
        Wo = function() { w(r, go); var s = T(r);

            function r(t, e, i) { var n; return X(this, r), (n = s.call(this, t, Yo)).updateTextFlag = !1, n.style = new zo(W(n), i), n.setText(e), n } return k(r, [{ key: "autoRound", get: function() { return this.parent.autoRound } }, { key: "offsetX", get: function() { return this.style.offsetX }, set: function(t) { this.style && (this.style.offsetX = t) } }, { key: "offsetY", get: function() { return this.style.offsetY }, set: function(t) { this.style && (this.style.offsetY = t) } }, { key: "leftSpace", get: function() { return this.style.leftSpace * this.scaleX }, set: function(t) { this.style && (this.style.leftSpace = t), e(C(r.prototype), "leftSpace", t, this, !0) } }, { key: "rightSpace", get: function() { return this.style.rightSpace * this.scaleX }, set: function(t) { this.style && (this.style.rightSpace = t), e(C(r.prototype), "rightSpace", t, this, !0) } }, { key: "align", get: function() { return this.style.align }, set: function(t) { this.style && (this.style.align = t) } }, { key: "modifyStyle", value: function(t) { return this.setDirty(!0), this.style.modify(t), this.updateTextFlag && this.updateTextSize(), this } }, { key: "modifyPorperties", value: function(t) { return t && (this.modifyStyle(t), O(C(r.prototype), "modifyPorperties", this).call(this, t)), this } }, { key: "setText", value: function(t) { return this.setDirty(this.text != t), this.text = t, this.updateTextSize(), this } }, { key: "updateTextSize", value: function() { if ("\n" === this.text || "" === this.text) this.textWidth = 0, this.textHeight = 0, this.ascent = 0, this.descent = 0;
                    else { var t, e, i = this.style.getTextMetrics(this.context, this.text);
                        this.textWidth = i.width, e = "actualBoundingBoxAscent" in i ? (t = i.actualBoundingBoxAscent, i.actualBoundingBoxDescent) : t = 0, this.textHeight = t + e, this.ascent = t, this.descent = e } return this.updateTextFlag = !1, this } }, { key: "width", get: function() { return this.textWidth * this.scaleX }, set: function(t) { 0 < this.textWidth ? this.scaleX = t / this.textWidth : this.scaleX = 1 } }, { key: "height", get: function() { return this.textHeight * this.scaleY }, set: function(t) { 0 < this.textHeight ? this.scaleY = t / this.textHeight : this.scaleY = 1 } }, { key: "willRender", get: function() { return "\n" !== this.text && O(C(r.prototype), "willRender", this) } }, { key: "renderContent", value: function() { var t = this.context,
                        e = this.style; if (e.hasBackgroundColor) { t.fillStyle = e.backgroundColor; var i = this.drawTLX,
                            n = this.drawTLY,
                            s = this.drawTRX - i,
                            r = this.drawBLY - n;
                        t.fillRect(i, n, s, r) } var o = e.hasFill,
                        a = e.hasStroke;
                    (o || a) && (e.syncFont(t).syncStyle(t), a && (e.syncShadow(t), t.strokeText(this.text, 0, 0)), o && (e.syncShadow(t), t.fillText(this.text, 0, 0))) } }, { key: "drawTLX", get: function() { return -this.leftSpace } }, { key: "drawTLY", get: function() { return -this.ascent } }, { key: "drawBLX", get: function() { return -this.leftSpace } }, { key: "drawBLY", get: function() { return this.descent } }, { key: "drawTRX", get: function() { return this.textWidth + this.rightSpace } }, { key: "drawTRY", get: function() { return -this.ascent } }, { key: "drawBRX", get: function() { return this.textWidth + this.rightSpace } }, { key: "drawBRY", get: function() { return this.descent } }]), r }(),
        Go = function() { w(r, go); var s = T(r);

            function r(t, e, i) { var n; return X(this, r), (n = s.call(this, t, "image")).setTexture(e, i), n } return k(r, [{ key: "frameWidth", get: function() { return this.frameObj ? this.frameObj.cutWidth : 0 } }, { key: "frameHeight", get: function() { return this.frameObj ? this.frameObj.cutHeight : 0 } }, { key: "offsetY", get: function() { return -this.height }, set: function() {} }, { key: "key", get: function() { return this._key }, set: function(t) { this.setDirty(this._key != t), this._key = t } }, { key: "frame", get: function() { return this._frame }, set: function(t) { this.setDirty(this._frame != t), this._frame = t } }, { key: "setTexture", value: function(t, e) { return this.key = t, this.frame = e, this.frameObj = this.scene.sys.textures.getFrame(t, e), this } }, { key: "width", get: function() { return this.frameWidth * this.scaleX }, set: function(t) { this.setDirty(this.width !== t), this.scaleX = t / this.frameWidth } }, { key: "height", get: function() { return this.frameHeight * this.scaleY }, set: function(t) { this.setDirty(this.height !== t), this.scaleY = t / this.frameHeight } }, { key: "setHeight", value: function(t, e) { return void 0 === e && (e = !1), this.height = t, e && (this.scaleX = this.scaleY), this } }, { key: "renderContent", value: function() { var t = this.context,
                        e = this.frameObj,
                        i = this.frameWidth,
                        n = this.frameHeight;
                    t.drawImage(e.source.image, e.cutX, e.cutY, i, n, 0, 0, i, n) } }, { key: "drawTLX", get: function() { return -this.leftSpace } }, { key: "drawTLY", get: function() { return 0 } }, { key: "drawBLX", get: function() { return -this.leftSpace } }, { key: "drawBLY", get: function() { return this.frameHeight } }, { key: "drawTRX", get: function() { return this.frameWidth + this.rightSpace } }, { key: "drawTRY", get: function() { return 0 } }, { key: "drawBRX", get: function() { return this.frameWidth + this.rightSpace } }, { key: "drawBRY", get: function() { return this.frameHeight } }]), r }(),
        Vo = function() { w(o, go); var r = T(o);

            function o(t, e, i, n) { var s; return X(this, o), (s = r.call(this, t, "drawer")).setRenderCallback(e), s.setDrawerSize(i, n), s } return k(o, [{ key: "setRenderCallback", value: function(t) { return t ? this.renderContent = t.bind(this) : delete this.renderContent, this } }, { key: "setDrawerSize", value: function(t, e) { return !0 === t ? (this.toLocalPosition = !1, e = t = void 0) : this.toLocalPosition = !0, void 0 === t && (t = 0), void 0 === e && (e = t), this.drawerWidth = t, this.drawerHeight = e, this } }, { key: "onFree", value: function() { O(C(o.prototype), "onFree", this).call(this), this.setRenderCallback() } }, { key: "width", get: function() { return this.drawerWidth * this.scaleX }, set: function(t) { this.setDirty(this.width !== t), this.scaleX = 0 < this.drawerWidth ? t / this.drawerWidth : 1 } }, { key: "height", get: function() { return this.drawerHeight * this.scaleY }, set: function(t) { this.setDirty(this.height !== t), this.scaleY = 0 < this.drawerHeight ? t / this.drawerHeight : 1 } }, { key: "offsetY", get: function() { return -this.height }, set: function() {} }, { key: "drawTLX", get: function() { return -this.leftSpace } }, { key: "drawTLY", get: function() { return 0 } }, { key: "drawBLX", get: function() { return -this.leftSpace } }, { key: "drawBLY", get: function() { return this.drawerHeight } }, { key: "drawTRX", get: function() { return this.drawerWidth + this.rightSpace } }, { key: "drawTRY", get: function() { return 0 } }, { key: "drawBRX", get: function() { return this.drawerWidth + this.rightSpace } }, { key: "drawBRY", get: function() { return this.drawerHeight } }]), o }(),
        Uo = function() { w(s, go); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, "space")).setSpaceWidth(e), i } return k(s, [{ key: "width", get: function() { return this.spaceWidth * this.scaleX }, set: function(t) { 0 < this.spaceWidth ? this.scaleX = t / this.spaceWidth : this.scaleX = 1 } }, { key: "setSpaceWidth", value: function(t) { return this.spaceWidth = t, this } }]), s }(),
        Ho = function() { w(a, so); var o = T(a);

            function a(t, e, i, n, s) { var r; return X(this, a), (r = o.call(this, t, Xo)).setName(e).setParameter(n).setCallback(i, s), r } return k(a, [{ key: "setName", value: function(t) { return this.name = t, this } }, { key: "setParameter", value: function(t) { return this.param = t, this } }, { key: "setCallback", value: function(t, e) { return this.callback = t, this.scope = e, this } }, { key: "exec", value: function() { return this.scope ? this.callback.call(this.scope, this.param, this.name) : this.callback(this.param, this.name) } }, { key: "onFree", value: function() { O(C(a.prototype), "onFree", this).call(this), this.setName().setCallback().setParameter() } }]), a }(),
        No = Phaser.Utils.Objects.GetValue,
        Jo = Phaser.Utils.Objects.Merge,
        Ko = Phaser.Utils.Objects.GetValue,
        Zo = Phaser.Utils.Objects.Merge,
        qo = Phaser.Utils.Array.GetAll,
        $o = Phaser.Math.RotateAround,
        Qo = Phaser.Math.Distance.BetweenPointsSquared,
        ta = function(t, e, i, n) { if (this.childrenInteractiveEnable) { var s = Ro(this.children, e, i);
                s && this.emit("child.pointerdown", s, t, e, i, n) } },
        ea = function(t, e, i, n) { if (this.childrenInteractiveEnable) { var s = Ro(this.children, e, i);
                s && this.emit("child.pointerup", s, t, e, i, n) } },
        ia = function(t, e, i, n) { if (this.childrenInteractiveEnable)
                if (null !== e) { var s = Ro(this.children, e, i);
                    s !== this.lastOverChild && (null !== this.lastOverChild && this.emit("child.pointerout", this.lastOverChild, t, e, i, n), null !== s && this.emit("child.pointerover", s, t, e, i, n), this.lastOverChild = s) } else null !== this.lastOverChild && (this.emit("child.pointerout", this.lastOverChild, t, e, i, n), this.lastOverChild = null) },
        na = Phaser.GameObjects.GameObject,
        sa = Phaser.Utils.Array.BringToTop,
        ra = Phaser.Utils.Array.SendToBack,
        oa = Phaser.Utils.Array.MoveUp,
        aa = Phaser.Utils.Array.MoveDown,
        ha = Phaser.Utils.Array.MoveAbove,
        la = Phaser.Utils.Array.MoveBelow,
        ua = { moveChildToFist: function(t) { return ra(this.children, t), this }, moveChildToLast: function(t) { return sa(this.children, t), this }, movechildUp: function(t) { return oa(this.children, t), this }, movechildDown: function(t) { return aa(this.children, t), this }, movechildAbove: function(t, e) { return ha(this.children, t, e), this }, movechildBelow: function(t, e) { return la(this.children, t, e), this } },
        ca = { setFixedSize: function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), 0 < t && 0 < e && this.fixedWidth === t && this.fixedHeight === e || (this.dirty = !0), this.fixedWidth = t, this.fixedHeight = e, 0 < t && (this.width = t), 0 < e && (this.height = e), this }, setPadding: function(t, e) { var i = this.padding,
                    n = i.left,
                    s = i.right,
                    r = i.top,
                    o = i.bottom; return io(i, t, e), this.dirty = this.dirty || n != i.left || s != i.right || r != i.top || o != i.bottom, this }, getPadding: function(t) { return eo(this.padding, t) }, modifyTextStyle: function(t) { return this.textStyle.modify(t), this }, resetTextStyle: function() { return this.textStyle.copyFrom(this.defaultTextStyle), this }, removeChild: function(t) { return this.poolManager.free(t), Fo(this.children, t), this.lastAppendedChildren.length = 0, this.lastOverChild = null, this.dirty = !0, this }, removeChildren: function() { return this.poolManager.freeMultiple(this.children), this.children.length = 0, this.lastAppendedChildren.length = 0, this.lastOverChild = null, this.dirty = !0, this }, clearContent: function() { return this.setText(), this }, addChild: mo, createCharChild: function(t, e) { e && this.textStyle.modify(e); var i = this.poolManager.allocate(Yo); return null === i ? i = new Wo(this, t, this.textStyle) : i.setParent(this).setActive().modifyStyle(this.textStyle).setText(t), i }, createCharChildren: function(t, e) { e && this.textStyle.modify(e); for (var i = [], n = 0, s = t.length; n < s; n++) { var r = t.charAt(n),
                        o = this.poolManager.allocate(Yo);
                    null === o ? o = new Wo(this, r, this.textStyle) : o.setParent(this).setActive().modifyStyle(this.textStyle).setText(r), i.push(o) } return i }, setText: function(t, e) { return void 0 === t && (t = ""), this.removeChildren(), xo.call(this, t, e), this.dirty = !0, this }, appendText: xo, insertText: function(t, e, i) { var n = this.createCharChildren(e, i); return t = this.getCharChildIndex(t, !0), this.addChild(n, t), this }, removeText: function(t, e) { void 0 === e && (e = 1); for (var i = 0; i < e; i++) { var n = this.getCharChildIndex(t, !0); if (void 0 === n) break;
                    this.removeChild(this.children[n]) } return this }, getText: function(t) { var e = ""; return this.forEachCharChild(function(t) { e += t.text }, void 0, t), e }, createImageChild: function(t, e, i) { var n = this.poolManager.allocate("image"); return null === n ? n = new Go(this, t, e) : n.setParent(this).setActive().setTexture(t, e), n.modifyPorperties(i), n }, appendImage: Co, createDrawerChild: function(t, e, i) { var n = this.poolManager.allocate("drawer"); return null === n ? n = new Vo(this, t, e, i) : n.setParent(this).setActive().setRenderCallback(t).setDrawerSize(e, i), n }, appendDrawer: function(t, e, i) { var n = this.createDrawerChild(t, e, i); return this.addChild(n), this }, createSpaceChild: function(t) { var e = this.poolManager.allocate("space"); return null === e ? e = new Uo(this, t) : e.setParent(this).setActive().setSpaceWidth(t), e }, appendSpace: wo, createCommandChild: function(t, e, i, n) { var s = this.poolManager.allocate(Xo); return null === s ? s = new Ho(this, t, e, i, n) : s.setParent(this).setActive().setName(t).setCallback(e, n).setParameter(i), s }, appendCommand: So, setWrapConfig: function(t) { return void 0 === t && (t = {}), this.wrapConfig = t, this }, runWordWrap: function(t) { return void 0 === t && (t = {}), Mo.call(this, Jo(t, this.wrapConfig)) }, runVerticalWrap: function(t) { return void 0 === t && (t = {}), Eo.call(this, Zo(t, this.wrapConfig)) }, renderContent: function() { var t;
                this.clear(), this.setSize(this.width, this.height), this.background.active && this.background.render(); for (var e = 0, i = this.children.length; e < i; e++)(t = this.children[e]).active && t.render();
                this.innerBounds.active && this.innerBounds.render() }, forEachChild: function(t, e, i) { void 0 === i && (i = !0); for (var n = this.children, s = 0, r = 0, o = n.length; r < o; r++) { var a, h = n[r]; if (!i || h.active)
                        if (a = e ? t.call(this, h, s, n) : t(h, s, n), s++, a) break } return this }, forEachRenderableChild: function(t, e, i) { void 0 === i && (i = !0); for (var n = this.children, s = 0, r = 0, o = n.length; r < o; r++) { var a, h = n[r]; if (!i || h.active)
                        if (h.renderable && !h.removed)
                            if (a = e ? t.call(this, h, s, n) : t(h, s, n), s++, a) break } return this }, forEachCharChild: function(t, e, i) { void 0 === i && (i = !0); for (var n = this.children, s = 0, r = 0, o = n.length; r < o; r++) { var a, h = n[r]; if (!i || h.active)
                        if (bo(h) && !h.removed)
                            if (a = e ? t.call(this, h, s, n) : t(h, s, n), s++, a) break } return this }, getChildren: function() { return this.children }, getActiveChildren: function() { return qo(this.children, "active", !0) }, getCharChildren: function(t, e) { return void 0 === e && (e = []), this.forEachCharChild(function(t) { e.push(t) }, void 0, t), e }, getLastAppendedChildren: function() { return this.lastAppendedChildren }, getNearestChild: function(t, e) { var i = { x: t, y: e },
                    n = 1 / 0,
                    s = null; return this.forEachRenderableChild(function(t) { var e = Qo(i, _o(t, !0));
                    e < n && (n = e, s = t) }), s }, setToMinSize: function() { for (var t = this.children, e = 0, i = 0, n = 0, s = t.length; n < s; n++) { var r = t[n]; if (r.renderable && r.active && r.visible) { var o = void 0 !== r.x0 ? r.x0 : r.x,
                            a = void 0 !== r.y0 ? r.y0 : r.y;
                        e = Math.max(e, o), i = Math.max(i, a) } } var h = e + this.padding.left + this.padding.right + this.wrapPadding.left + this.wrapPadding.right,
                    l = i + this.padding.top + this.padding.bottom + this.wrapPadding.top + this.wrapPadding.bottom; return this.width === h && this.height === l || (this.dirty = !0, this.width = h, this.height = l), this }, getCharChildIndex: function(t, e) { void 0 === e && (e = !0); for (var i = this.children, n = 0, s = i.length; n < s; n++) { var r = i[n]; if ((!e || r.active) && (bo(r) && !r.removed)) { if (0 === t) return n;
                        t-- } } }, getCharChild: function(t, e) { void 0 === e && (e = !0); for (var i = this.children, n = 0, s = i.length; n < s; n++) { var r = i[n]; if ((!e || r.active) && (bo(r) && !r.removed)) { if (0 === t) return r;
                        t-- } } }, getCharIndex: function(t, e) { if ("number" != typeof t && (t = this.children.indexOf(t)) < 0) return null;
                void 0 === e && (e = !0); var i = this.children;
                t >= i.length && (t = i.length); for (var n = 0, s = 0; s < t; s++) { var r = i[s];
                    e && !r.active || bo(r) && !r.removed && n++ } return n }, setChildrenInteractiveEnable: function(t) { return void 0 === t && (t = !0), this.childrenInteractiveEnable !== t && (this.lastOverChild = null), this.childrenInteractiveEnable = t, this }, setInteractive: function(t, e, i) { var n = !!this.input; return na.prototype.setInteractive.call(this, t, e, i), n || function() { return this.on("pointerdown", ta, this).on("pointerdown", ea, this).on("pointermove", ia, this).on("pointerover", ia, this).on("pointerout", function(t, e) { ia.call(this, t, null, null, e) }, this), this }.call(this), this } };
    Object.assign(ca, ua, { setBackgroundColor: function(t, e, i) { return this.background.setColor(t, e, i), this }, setBackgroundStroke: function(t, e) { return this.background.setStroke(t, e), this }, setBackgroundCornerRadius: function(t, e) { return this.background.setCornerRadius(t, e), this } }, { setInnerBoundsColor: function(t, e, i) { return this.innerBounds.setColor(t, e, i), this }, setInnerBoundsStroke: function(t, e) { return this.innerBounds.setStroke(t, e), this } }); var da = Phaser.Utils.Objects.GetFastValue,
        fa = {},
        pa = function() {
            function e(t) { X(this, e), this.pools = da(t, "pools", fa) } return k(e, [{ key: "free", value: function(t) { if (!this.pools) return this; var e = t.type; return this.pools.hasOwnProperty(e) || (this.pools[e] = new N()), this.pools[e].push(t), t.onFree(), this } }, { key: "freeMultiple", value: function(t) { if (!this.pools) return this; for (var e = 0, i = t.length; e < i; e++) this.free(t[e]); return this } }, { key: "allocate", value: function(t) { return this.pools && this.pools.hasOwnProperty(t) ? this.pools[t].pop() : null } }]), e }(),
        va = Phaser.Utils.Objects.IsPlainObject,
        ga = Phaser.Utils.Objects.GetValue,
        ya = function() { w(d, Qt); var c = T(d);

            function d(t, e, i, n, s, r) { var o;
                X(this, d), va(e) ? (e = ga(r = e, "x", 0), i = ga(r, "y", 0), n = ga(r, "width", 0), s = ga(r, "height", 0)) : va(n) && (n = ga(r = n, "width", 0), s = ga(r, "height", 0)); var a = 0 === n ? 1 : n,
                    h = 0 === s ? 1 : s;
                (o = c.call(this, t, e, i, a, h)).type = "rexDynamicText", o.autoRound = !0, o.padding = io(), o.wrapPadding = io(); var l = ga(r, "style", void 0);
                o.defaultTextStyle = new zo(null, l), o.textStyle = o.defaultTextStyle.clone(), o.background = new Lo(W(o), ga(r, "background", void 0)), o.innerBounds = new jo(W(o), ga(r, "innerBounds", void 0)), o.children = [], o.lastAppendedChildren = [], o.lastOverChild = null, o.poolManager = new pa(r), o.setFixedSize(n, s), o.setPadding(ga(r, "padding", 0)), o.setWrapConfig(ga(r, "wrap", void 0)), o.setChildrenInteractiveEnable(ga(r, "childrenInteractive", !1)); var u = ga(r, "text", void 0); return u && o.setText(u), o } return k(d, [{ key: "updateTexture", value: function() { return this.renderContent(), O(C(d.prototype), "updateTexture", this).call(this), this } }, { key: "text", get: function() { return this.getText(!0) }, set: function(t) { this.setText(t) } }]), d }();
    Object.assign(ya.prototype, ca), p.register("dynamicText", function(t, e, i, n, s) { var r = new ya(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.DynamicText", ya);

    function ma(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = 0); var r, o = { mode: 0, volume: { start: s, end: n }, duration: i }; return "string" == typeof e && (e = t.sys.sound.add(e)), e.hasOwnProperty("_fade") ? (r = e._fade).stop().resetFromJSON(o) : (r = new Wa(t, e, o), e._fade = r), r.start(), e.isPlaying || e.setVolume(s).play(), e }

    function ka(t, e, i, n) { void 0 === n && (n = !0); var s, r = { mode: n ? 2 : 1, volume: { start: e.volume, end: 0 }, duration: i }; return e.hasOwnProperty("_fade") ? (s = e._fade).stop().resetFromJSON(r) : (s = new Wa(t, e, r), e._fade = s), s.start(), e.isPlaying || e.play(), e }

    function ba(t, e) { var i = ih(e, "sounds"); return !1 !== i && (this.soundManager = new Ha(t, i)), this.gameObjectManagers = {}, this.timeline = new eh(this), this.managersScene = t, this } var xa = Phaser.Utils.Objects.GetValue,
        Ca = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e))._isRunning = !1, i.isPaused = !1, i.tickingState = !1, i.setTickingMode(xa(e, "tickingMode", 1)), i } return k(s, [{ key: "boot", value: function() { 2 !== this.tickingMode || this.tickingState || this.startTicking() } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.stop(), this.tickingState && this.stopTicking(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "setTickingMode", value: function(t) { "string" == typeof t && (t = wa[t]), this.tickingMode = t } }, { key: "startTicking", value: function() { this.tickingState = !0 } }, { key: "stopTicking", value: function() { this.tickingState = !1 } }, { key: "isRunning", get: function() { return this._isRunning }, set: function(t) { this._isRunning !== t && (this._isRunning = t, 1 === this.tickingMode && t != this.tickingState && (t ? this.startTicking() : this.stopTicking())) } }, { key: "start", value: function() { return this.isPaused = !1, this.isRunning = !0, this } }, { key: "pause", value: function() { return this.isRunning && (this.isPaused = !0, this.isRunning = !1), this } }, { key: "resume", value: function() { return this.isPaused && (this.isRunning = !0), this } }, { key: "stop", value: function() { return this.isPaused = !1, this.isRunning = !1, this } }, { key: "complete", value: function() { this.isPaused = !1, this.isRunning = !1, this.emit("complete", this.parent, this) } }]), s }(),
        wa = { no: 0, lazy: 1, always: 2 },
        Sa = Phaser.Utils.Objects.GetValue,
        Pa = function() { w(s, Ca); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).tickEventName = Sa(e, "tickEventName", "update"), i } return k(s, [{ key: "startTicking", value: function() { O(C(s.prototype), "startTicking", this).call(this), this.scene.sys.events.on(this.tickEventName, this.update, this) } }, { key: "stopTicking", value: function() { O(C(s.prototype), "stopTicking", this).call(this), this.scene && this.scene.sys.events.off(this.tickEventName, this.update, this) } }]), s }(),
        Ta = Phaser.Utils.Objects.GetValue,
        Oa = Phaser.Math.Clamp,
        Ma = function() {
            function e(t) { X(this, e), this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function(t) { this.state = Ta(t, "state", Ea), this.timeScale = Ta(t, "timeScale", 1), this.delay = Ta(t, "delay", 0), this.repeat = Ta(t, "repeat", 0), this.repeatCounter = Ta(t, "repeatCounter", 0), this.repeatDelay = Ta(t, "repeatDelay", 0), this.duration = Ta(t, "duration", 0), this.nowTime = Ta(t, "nowTime", 0), this.justRestart = Ta(t, "justRestart", !1) } }, { key: "toJSON", value: function() { return { state: this.state, timeScale: this.timeScale, delay: this.delay, repeat: this.repeat, repeatCounter: this.repeatCounter, repeatDelay: this.repeatDelay, duration: this.duration, nowTime: this.nowTime, justRestart: this.justRestart } } }, { key: "destroy", value: function() {} }, { key: "setTimeScale", value: function(t) { return this.timeScale = t, this } }, { key: "setDelay", value: function(t) { return void 0 === t && (t = 0), this.delay = t, this } }, { key: "setDuration", value: function(t) { return this.duration = t, this } }, { key: "setRepeat", value: function(t) { return this.repeat = t, this } }, { key: "setRepeatInfinity", value: function() { return this.repeat = -1, this } }, { key: "setRepeatDelay", value: function(t) { return this.repeatDelay = t, this } }, { key: "start", value: function() { return this.nowTime = 0 < this.delay ? -this.delay : 0, this.state = 0 <= this.nowTime ? Ra : _a, this.repeatCounter = 0, this } }, { key: "stop", value: function() { return this.state = Ea, this } }, { key: "update", value: function(t, e) { this.state !== Ea && this.state !== Ia && 0 !== e && 0 !== this.timeScale && (this.nowTime += e * this.timeScale, this.justRestart = !1, this.nowTime >= this.duration ? -1 === this.repeat || this.repeatCounter < this.repeat ? (this.repeatCounter++, this.justRestart = !0, this.nowTime -= this.duration, 0 < this.repeatDelay && (this.nowTime -= this.repeatDelay, this.state = Ba)) : (this.nowTime = this.duration, this.state = Ia) : 0 <= this.nowTime && (this.state = Ra)) } }, { key: "t", get: function() { var t; switch (this.state) {
                        case Ea:
                        case _a:
                        case Ba:
                            t = 0; break;
                        case Ra:
                            t = this.nowTime / this.duration; break;
                        case Ia:
                            t = 1 } return Oa(t, 0, 1) }, set: function(t) {
                    (t = Oa(t, -1, 1)) < 0 ? (this.state = _a, this.nowTime = -this.delay * t) : (this.state = Ra, this.nowTime = this.duration * t, 1 === t && 0 !== this.repeat && this.repeatCounter++) } }, { key: "setT", value: function(t) { return this.t = t, this } }, { key: "isIdle", get: function() { return this.state === Ea } }, { key: "isDelay", get: function() { return this.state === _a } }, { key: "isCountDown", get: function() { return this.state === Ra } }, { key: "isRunning", get: function() { return this.state === _a || this.state === Ra } }, { key: "isDone", get: function() { return this.state === Ia } }, { key: "isOddIteration", get: function() { return 1 == (1 & this.repeatCounter) } }, { key: "isEvenIteration", get: function() { return 0 == (1 & this.repeatCounter) } }]), e }(),
        Ea = 0,
        _a = 1,
        Ra = 2,
        Ba = 3,
        Ia = -1,
        La = function() { w(s, Pa); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).timer = new Ma(), i } return k(s, [{ key: "shutdown", value: function(t) { this.isShutdown || (O(C(s.prototype), "shutdown", this).call(this, t), this.timer.destroy(), this.timer = void 0) } }, { key: "start", value: function() { return this.timer.start(), O(C(s.prototype), "start", this).call(this), this } }, { key: "stop", value: function() { return this.timer.stop(), O(C(s.prototype), "stop", this).call(this), this } }, { key: "complete", value: function() { return this.timer.stop(), O(C(s.prototype), "complete", this).call(this), this } }]), s }(),
        Aa = Phaser.Utils.Objects.GetValue,
        ja = Phaser.Utils.Objects.GetAdvancedValue,
        Da = Phaser.Tweens.Builders.GetEaseFunction,
        za = function() { w(e, La); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "resetFromJSON", value: function(t) { return this.timer.resetFromJSON(Aa(t, "timer")), this.setEnable(Aa(t, "enable", !0)), this.setTarget(Aa(t, "target", this.parent)), this.setDelay(ja(t, "delay", 0)), this.setDuration(ja(t, "duration", 1e3)), this.setEase(Aa(t, "ease", "Linear")), this.setRepeat(Aa(t, "repeat", 0)), this } }, { key: "setEnable", value: function(t) { return null == t && (t = !0), this.enable = t, this } }, { key: "setTarget", value: function(t) { return void 0 === t && (t = this.parent), this.target = t, this } }, { key: "setDelay", value: function(t) { return this.delay = t, this } }, { key: "setDuration", value: function(t) { return this.duration = t, this } }, { key: "setRepeat", value: function(t) { return this.repeat = t, this } }, { key: "setRepeatDelay", value: function(t) { return this.repeatDelay = t, this } }, { key: "setEase", value: function(t) { return void 0 === t && (t = "Linear"), this.ease = t, this.easeFn = Da(t), this } }, { key: "start", value: function() { return this.timer.isRunning || O(C(e.prototype), "start", this).call(this), this } }, { key: "restart", value: function() { return this.timer.stop(), this.start.apply(this, arguments), this } }, { key: "stop", value: function(t) { return void 0 === t && (t = !1), O(C(e.prototype), "stop", this).call(this), t && (this.timer.setT(1), this.updateGameObject(this.target, this.timer), this.complete()), this } }, { key: "update", value: function(t, e) { if (!this.isRunning || !this.enable || !this.parent.active) return this; var i = this.target,
                        n = this.timer; return n.update(t, e), n.isDelay || this.updateGameObject(i, n), this.emit("update", i, this), n.isDone && this.complete(), this } }, { key: "updateGameObject", value: function() {} }]), e }(),
        Fa = Phaser.Utils.Objects.GetValue,
        Ya = Phaser.Utils.Objects.GetAdvancedValue,
        Xa = Phaser.Math.Linear,
        Wa = function() { w(r, za); var s = T(r);

            function r(t, e, i) { var n; return X(this, r), e.scene = t, e.active = !0, (n = s.call(this, e, i)).volume = {}, n.resetFromJSON(i), n } return k(r, [{ key: "resetFromJSON", value: function(t) { return O(C(r.prototype), "resetFromJSON", this).call(this, t), this.setMode(Fa(t, "mode", 0)), this.setEnable(Fa(t, "enable", !0)), this.setVolumeRange(Ya(t, "volume.start", this.parent.volume), Ya(t, "volume.end", 0)), this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = Ga[t]), this.mode = t, this } }, { key: "setVolumeRange", value: function(t, e) { return this.volume.start = t, this.volume.end = e, this } }, { key: "start", value: function() { return this.timer.isRunning || (this.parent.setVolume(this.volume.start), this.timer.setDelay(this.delay).setDuration(this.duration), O(C(r.prototype), "start", this).call(this)), this } }, { key: "updateGameObject", value: function(t, e) { t.volume = Xa(this.volume.start, this.volume.end, e.t) } }, { key: "complete", value: function() { switch (O(C(r.prototype), "complete", this).call(this), this.mode) {
                        case 1:
                            this.parent.stop(); break;
                        case 2:
                            this.parent.destroy() } return this } }]), r }(),
        Ga = { stop: 1, destroy: 2 },
        Va = Phaser.Utils.Objects.GetValue,
        Ua = Phaser.Utils.Array.Remove,
        Ha = function() {
            function n(t, e) { X(this, n), this.scene = t, this.soundEffects = [], this.backgroundMusic = void 0, this.setBackgroundMusicLoopValue(Va(e, "bgm.loop", !0)), this.setBackgroundMusicFadeTime(Va(e, "bgm.fade", 500)); var i = Va(e, "bgm.initial", void 0);
                i && this.setCurrentBackgroundMusic(i) } return k(n, [{ key: "destroy", value: function(t) { if (this.soundEffects.length && !t)
                        for (var e = this.soundEffects.length - 1; 0 <= e; e--) this.soundEffects[e].destroy();
                    this.soundEffects.length = 0, this.backgroundMusic && !t && this.backgroundMusic.destroy(), this.backgroundMusic = void 0, this.scene = void 0 } }, { key: "setBackgroundMusicLoopValue", value: function(t) { return this.backgroundMusicLoopValue = t, this } }, { key: "setBackgroundMusicFadeTime", value: function(t) { return this.backgroundMusicFadeTime = t, this } }, { key: "getSoundEffects", value: function() { return this.soundEffects } }, { key: "getLastSoundEffect", value: function() { return this.soundEffects[this.soundEffects.length - 1] } }, { key: "getBackgroundMusic", value: function() { return this.backgroundMusic } }, { key: "playSoundEffect", value: function(t) { var e = this.scene.sys.sound.add(t); return this.soundEffects.push(e), e.once("complete", function() { e.destroy(), this.scene && Ua(this.soundEffects, e) }, this).once("destroy", function() { this.scene && Ua(this.soundEffects, e) }, this).play(), this } }, { key: "setSoundEffectVolume", value: function(t) { var e = this.getLastSoundEffect(); return e && e.setVolume(t), this } }, { key: "fadeInSoundEffect", value: function(t) { var e = this.getLastSoundEffect(); return e && ma(this.scene, e, t), this } }, { key: "fadeOutSoundEffect", value: function(t, e) { var i = this.getLastSoundEffect(); return i && ka(this.scene, i, t, e), this } }, { key: "fadeOutAllSoundEffects", value: function(t, e) { for (var i = this.soundEffects.length - 1; 0 <= i; i--) ka(this.scene, this.soundEffects[i], t, e); return this } }, { key: "setCurrentBackgroundMusic", value: function(t) {
                    (this.backgroundMusic = t) && (t.setLoop(this.backgroundMusicLoopValue), t.once("complete", function() { this.backgroundMusic.destroy(), this.backgroundMusic = void 0 }, this).once("destroy", function() { this.backgroundMusic = void 0 }, this), t.isPlaying || t.play()) } }, { key: "playBackgroundMusic", value: function(t) { return this.backgroundMusic && this.backgroundMusic.key === t || (this.stopBackgroundMusic(), this.setCurrentBackgroundMusic(this.scene.sys.sound.add(t)), 0 < this.backgroundMusicFadeTime && this.fadeInBackgroundMusic(this.backgroundMusicFadeTime)), this } }, { key: "pauseBackgroundMusic", value: function() { return this.backgroundMusic && this.backgroundMusic.pause(), this } }, { key: "resumeBackgroundMusic", value: function() { return this.backgroundMusic && this.backgroundMusic.resume(), this } }, { key: "stopBackgroundMusic", value: function() { return this.backgroundMusic && (0 < this.backgroundMusicFadeTime ? this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, !0) : (this.backgroundMusic.stop(), this.backgroundMusic.destroy(), this.backgroundMusic = void 0)), this } }, { key: "fadeInBackgroundMusic", value: function(t) { return this.backgroundMusic && ma(this.scene, this.backgroundMusic, t), this } }, { key: "fadeOutBackgroundMusic", value: function(t, e) { return this.backgroundMusic && ka(this.scene, this.backgroundMusic, t, e), this } }, { key: "crossFadeBackgroundMusic", value: function(t, e) { var i = this.backgroundMusicFadeTime; return this.backgroundMusicFadeTime = 0, this.fadeOutBackgroundMusic(e, !0).playBackgroundMusic(t).fadeInBackgroundMusic(e), this.backgroundMusicFadeTime = i, this } }]), n }(),
        Na = Phaser.Utils.Objects.GetValue,
        Ja = function() { w(s, Ca); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.isRunning = Na(t, "isRunning", !1), this.timeScale = Na(t, "timeScale", 1), this.now = Na(t, "now", 0), this } }, { key: "toJSON", value: function() { return { isRunning: this.isRunning, timeScale: this.timeScale, now: this.now, tickingMode: this.tickingMode } } }, { key: "start", value: function(t) { return void 0 === t && (t = 0), this.delta = 0, this.now = t, O(C(s.prototype), "start", this).call(this), this } }, { key: "seek", value: function(t) { return this.now = t, this } }, { key: "setTimeScale", value: function(t) { return this.timeScale = t, this } }, { key: "tick", value: function(t) { return t *= this.timeScale, this.now += t, this.delta = t, this.emit("update", this.now, this.delta), this } }]), s }(),
        Ka = function() { w(e, Ja); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "startTicking", value: function() { O(C(e.prototype), "startTicking", this).call(this), this.scene.sys.events.on("update", this.update, this) } }, { key: "stopTicking", value: function() { O(C(e.prototype), "stopTicking", this).call(this), this.scene && this.scene.sys.events.off("update", this.update, this) } }, { key: "update", value: function(t, e) { return this.isRunning && 0 !== this.timeScale && this.tick(e), this } }]), e }(),
        Za = Phaser.Math.Clamp,
        qa = function() {
            function i(t, e) { X(this, i), this.setTimeline(t).reset(e) } return k(i, [{ key: "setTimeline", value: function(t) { return this.timeline = t, this } }, { key: "setName", value: function(t) { return this.name = t, this } }, { key: "setCallbacks", value: function(t, e, i, n) { return this.target = t, this.onStart = e, this.onProgress = i, this.onComplete = n, this } }, { key: "setDuration", value: function(t, e) { return void 0 === e && (e = !1), this.duration = t, this.remainder = t, this.t = 0, this.yoyo = e, this } }, { key: "setPaused", value: function(t) { return this.isPaused = t, this } }, { key: "pause", value: function() { return this.isPaused = !0, this } }, { key: "resume", value: function() { return this.isPaused = !1, this } }, { key: "setRemoved", value: function(t) { return this.removed = t, this } }, { key: "remove", value: function() { return this.removed = !0, this } }, { key: "seek", value: function(t) { return this.remainder = this.duration * (1 - t), this } }, { key: "reset", value: function(t) { return this.setName(t.name).setDuration(t.duration, t.yoyo).setCallbacks(t.target, t.onStart, t.onProgress, t.onComplete).setPaused(!1).setRemoved(!1), this } }, { key: "onFree", value: function() { this.setTimeline().setCallbacks() } }, { key: "getProgress", value: function() { var t, e, i = 1 - this.remainder / this.duration; return i = Za(i, 0, 1), this.yoyo && (void 0 === e && (e = .5), (t = i) <= e ? t /= e : t = 1 - (t - e) / (1 - e), i = t), i } }, { key: "setProgress", value: function(t) { t = Za(t, 0, 1), this.remainder = this.duration * (1 - t) } }, { key: "runCallback", value: function(t) { t && t(this.target, this.t, this) } }, { key: "update", value: function(t, e) { if (this.removed) return !0; if (this.isPaused) return !1;
                    this.remainder -= e, this.t = this.getProgress(), this.runCallback(this.onProgress); var i = this.remainder <= 0; return i && this.runCallback(this.onComplete), i } }]), i }(),
        $a = function() { w(e, N); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "allocate", value: function() { return this.pop() } }, { key: "free", value: function(t) { t.onFree(), this.push(t) } }, { key: "freeMultiple", value: function(t) { for (var e = 0, i = t.length; e < i; e++) this.free(t[e]); return this } }]), e }(),
        Qa = Phaser.Utils.Objects.GetValue,
        th = new $a(),
        eh = function() { w(a, Ka); var n = T(a);

            function a(t, e) { var i; return X(this, a), (i = n.call(this, t, e)).addedTimers = [], i.timers = [], i.timerPool = Qa(e, "pool", th), i } return k(a, [{ key: "shutdown", value: function() { this.isShutdown || (this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers), this.timerPool = void 0, this.addedTimers = void 0, this.timers = void 0, O(C(a.prototype), "shutdown", this).call(this)) } }, { key: "addTimer", value: function(t) { var e = this.timerPool.allocate(); return e ? e.setTimeline(this).reset(t) : e = new qa(this, t), this.addedTimers.push(e), e.runCallback(e.onStart), this.isRunning || this.start(), e } }, { key: "delayCall", value: function(t, n, s, r) { return this.addTimer({ duration: t, onComplete: function(t, e, i) { void 0 === s && (s = []), s.push(i), n.apply(r, s) } }) } }, { key: "getTimers", value: function(t) { for (var e = [], i = [this.addedTimers, this.timers], n = 0, s = i.length; n < s; n++)
                        for (var r = i[n], o = 0, a = r.length; o < a; o++) { var h = r[o];
                            h.name === t && e.push(h) }
                    return e } }, { key: "update", value: function(t, e) { var i;
                    O(C(a.prototype), "update", this).call(this, t, e), (i = this.timers).push.apply(i, M(this.addedTimers)); for (var n = [], s = this.addedTimers.length = 0, r = this.timers.length; s < r; s++) { var o = this.timers[s];
                        o.update(this.now, this.delta) ? this.timerPool.free(o) : n.push(o) }
                    this.timers = n, 0 === this.timers.length && 0 === this.addedTimers.length && this.complete() } }]), a }(),
        ih = Phaser.Utils.Objects.GetValue,
        nh = { hasProperty: function(t) { var e = this.gameObject; return !!e.hasOwnProperty(t) || void 0 !== e[t] }, getProperty: function(t) { return this.gameObject[t] }, setProperty: function(t, e) { return this.gameObject[t] = e, this }, easeProperty: function(t, e, i, n, s, r, o) { var a = this.tweens,
                    h = a[t];
                h && h.remove(); var l = this.gameObject,
                    u = { targets: l, duration: i, ease: n, repeat: s, yoyo: r, onComplete: function() { a[t].remove(), a[t] = null, o && o(l, t) }, onCompleteScope: this }; return u[t] = e, (h = this.scene.tweens.add(u)).timeScale = this.timeScale, a[t] = h, this } },
        sh = { hasMethod: function(t) { return "function" == typeof this.gameObject[t] }, call: function(t) { if (!this.hasMethod(t)) return this; for (var e = this.gameObject, i = arguments.length, n = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) n[s - 1] = arguments[s]; return e[t].apply(e, n), this } },
        rh = function() {
            function n(t, e, i) { X(this, n), this.GOManager = t, this.tweens = {}, this.setGO(e, i) } return k(n, [{ key: "scene", get: function() { return this.GOManager.scene } }, { key: "timeScale", get: function() { return this.GOManager.timeScale } }, { key: "destroy", value: function() { this.freeGO(), this.GOManager = void 0 } }, { key: "freeTweens", value: function() { var t, e = this.tweens; for (var i in e)(t = e[i]) && t.remove(), e[i] = null; return this } }, { key: "freeGO", value: function() { return this.freeTweens(), this.gameObject.destroy(), this.gameObject = void 0, this } }, { key: "setGO", value: function(t, e) { return t.setName(e), this.gameObject = t, this.name = e, this.freeTweens(), this } }, { key: "setTimeScale", value: function(t) { var e = this.tweens; for (var i in e) { var n = e[i];
                        n && (n.timeScale = t) } return this } }]), n }();
    Object.assign(rh.prototype, nh, sh, { hasData: function(t) { var e = this.gameObject; return !!e.data && e.data.has(t) }, getData: function(t) { return this.gameObject.getData(t) }, setData: function(t, e) { return this.gameObject.setData(t, e), this } });

    function oh(t) { return t >> 16 & 255 }

    function ah(t) { return t >> 8 & 255 }

    function hh(t) { return 255 & t }

    function lh(t, e, i, n, s) { if (t.hasOwnProperty("vp")) return t;
        void 0 === i && (i = .5), void 0 === n && (n = .5), void 0 === s && (s = fh),
            function(e) { if (e.events) return; var i = new dh(),
                    n = e.x;
                Object.defineProperty(e, "x", { get: function() { return n }, set: function(t) { n !== t && (n = t, i.emit("update", e)) } }); var s = e.y;
                Object.defineProperty(e, "y", { get: function() { return s }, set: function(t) { s !== t && (s = t, i.emit("update", e)) } }); var r = e.width;
                Object.defineProperty(e, "width", { get: function() { return r }, set: function(t) { r !== t && (r = t, i.emit("update", e)) } }); var o = e.height;
                Object.defineProperty(e, "height", { get: function() { return o }, set: function(t) { o !== t && (o = t, i.emit("update", e)) } }), e.events = i }(e); var r = e.events;

        function o() { s(t, e, i, n) }
        t.vp = e, r.on("update", o), t.once("destroy", function() { r.off("update", o), t.vp = void 0 }), Object.defineProperty(t, "vpx", { get: function() { return i }, set: function(t) { i !== t && (i = t, o()) } }), Object.defineProperty(t, "vpy", { get: function() { return n }, set: function(t) { n !== t && (n = t, o()) } }), o() } var uh = { tint: 0, alpha: 1 },
        ch = { setGOFadeMode: function(t) { return "string" == typeof t && (t = uh[t]), this.fadeMode = t, this }, setGOFadeTime: function(t) { return this.fadeTime = t, this }, hasTintFadeEffect: function(t) { return (void 0 === this.fadeMode || 0 === this.fadeMode) && 0 < this.fadeTime && void 0 !== t.setTint }, hasAlphaFadeEffect: function(t) { return (void 0 === this.fadeMode || 1 === this.fadeMode) && 0 < this.fadeTime && void 0 !== t.setAlpha }, fadeBob: function(t, e, i, n) { var s = t.gameObject; return this.hasTintFadeEffect(s) ? (void 0 !== e && t.setProperty("tintGray", 255 * e), t.easeProperty("tintGray", Math.floor(255 * i), this.fadeTime, "Linear", 0, !1, n)) : this.hasAlphaFadeEffect(s) ? (void 0 !== e && t.setProperty("alpha", e), t.easeProperty("alpha", i, this.fadeTime, "Linear", 0, !1, n)) : n && n(s), this } },
        dh = Phaser.Events.EventEmitter,
        fh = function(t, e, i, n) { t.x = e.x + e.width * i, t.y = e.y + e.height * n },
        ph = Phaser.Utils.Array.Remove,
        vh = { has: function(t) { return this.bobs.hasOwnProperty(t) }, get: function(t) { return this.bobs[t] }, getGO: function(t) { var e = this.get(t); return e ? e.gameObject : null }, addGO: function(t, e) { this.remove(t, !0), this.hasTintFadeEffect(e) && function(e, i) { if (e.hasOwnProperty("tintR")) return;
                    void 0 === i && (i = 16777215); var n = oh(i),
                        s = ah(i),
                        r = hh(i);
                    Object.defineProperty(e, "tint", { get: function() { return i }, set: function(t) { t = 16777215 & Math.floor(t), e.setTint && e.setTint(t), i !== t && (n = oh(i = t), s = ah(i), r = hh(i)) } }), Object.defineProperty(e, "tintR", { get: function() { return n }, set: function(t) { t = 255 & Math.floor(t), n !== t && (n = t, e.tint = (255 & t) << 16 | 65535 & i) } }), Object.defineProperty(e, "tintG", { get: function() { return s }, set: function(t) { t = 255 & Math.floor(t), s !== t && (s = t, e.tint = (255 & t) << 8 | 16711935 & i) } }), Object.defineProperty(e, "tintB", { get: function() { return r }, set: function(t) { t = 255 & Math.floor(t), r !== t && (r = t, e.tint = 255 & t | 16776960 & i) } }), Object.defineProperty(e, "tintGray", { get: function() { return Math.floor((n + s + r) / 3) }, set: function(t) { t = 255 & Math.floor(t), n === t && s === t && r === t || (r = s = n = t, e.tint = (255 & t) << 16 | (255 & t) << 8 | 255 & t) } }), e.tint = i }(e), this.viewportCoordinateEnable && lh(e, this.viewport), e.once("destroy", function() { ph(this.removedGOs, e), this.isEmpty && this.emit("empty") }, this); var i = new this.BobClass(this, e, t); return this.bobs[t] = i, this }, add: function(t) { for (var e = this.createGameObjectCallback, i = this.createGameObjectScope, n = arguments.length, s = new Array(1 < n ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r]; var o = e.call.apply(e, [i, this.scene].concat(s));
                this.addGO(t, o); var a = this.get(t); return this.fadeBob(a, 0, 1), this }, forEachGO: function(t, e) { for (var i in this.bobs) { var n = this.bobs[i].gameObject; if (e ? t.call(e, n, i, this) : t(n, i, this)) break } return this } },
        gh = { remove: function(t, e) { if (!this.has(t)) return this; var i = this.get(t); return delete this.bobs[t], this.removedGOs.push(i.gameObject), e ? i.destroy() : this.fadeBob(i, void 0, 0, function() { i.destroy() }), this }, removeAll: function() { var t = this.bobs; for (var e in t) this.remove(e); return this }, clear: function(t) { void 0 === t && (t = !0); var e = this.bobs; for (var i in e) t && e[i].destroy(), delete e[i]; return this.removedGOs.length = 0, this } },
        yh = { hasProperty: function(t, e) { return !!this.has(t) && this.get(t).hasProperty(e) }, getProperty: function(t, e) { if (this.has(t)) return this.get(t).getProperty(e) }, isNumberProperty: function(t, e) { return "number" == typeof this.getProperty(t, e) }, setProperty: function(t, e, i) { return this.has(t) && (this.symbols && "string" == typeof i && this.isNumberProperty(t, e) && (i in this.symbols ? i = this.symbols[i] : console.warn("Can't find symbol ".concat(i))), this.get(t).setProperty(e, i)), this }, easeProperty: function(t, e, i, n, s, r, o, a) { return this.has(t) && (void 0 === n && (n = 1e3), void 0 === s && (s = "Linear"), void 0 === r && (r = 0), void 0 === o && (o = !1), this.symbols && "string" == typeof i && this.isNumberProperty(t, e) && (i in this.symbols ? i = this.symbols[i] : console.warn("Can't find symbol ".concat(i))), this.get(t).easeProperty(e, i, n, s, r, o, a)), this }, hasTweenTask: function(t, e) { return !!this.has(t) && this.get(t).tweens.hasOwnProperty(e) }, getTweenTask: function(t, e) { if (!this.has(t)) return null; var i = this.get(t).tweens[e]; return i || null } },
        mh = { hasMethod: function(t, e) { return !!this.has(t) && this.get(t).hasMethod(e) }, call: function(t, e) { var i; if (!this.has(t)) return this; for (var n = arguments.length, s = new Array(2 < n ? n - 2 : 0), r = 2; r < n; r++) s[r - 2] = arguments[r]; return (i = this.get(t)).call.apply(i, [e].concat(s)), this } },
        kh = { hasData: function(t, e) { return !!this.has(t) && this.get(t).hasData(e) }, getData: function(t, e) { if (this.has(t)) return this.get(t).getData(e) }, setData: function(t, e, i) { return this.has(t) && this.get(t).setData(e, i), this } },
        bh = { drawGameObjectsBounds: function(e, i) { return this.forEachGO(function(t) { t.drawBounds ? t.drawBounds(e, i) : tr(t, e, i) }), this } };
    Object.assign(bh, ch, vh, gh, yh, mh, kh);

    function xh(t, e, i) { e instanceof Ch || (i = e, e = void 0), void 0 === i ? i = new wh() : !0 === i && (i = Sh); var n, s, r = t.sys.scale,
            o = r.baseSize,
            a = r.parentSize,
            h = r.canvasBounds,
            l = r.displayScale,
            u = 0 <= h.x ? 0 : -(h.x * l.x),
            c = 0 <= h.y ? 0 : -(h.y * l.y); return n = a.width >= h.width ? o.width : o.width - (h.width - a.width) * l.x, s = a.height >= h.height ? o.height : o.height - (h.height - a.height) * l.y, i.setTo(u, c, n, s), e && (i.width /= e.zoomX, i.height /= e.zoomY, i.centerX = e.centerX + e.scrollX, i.centerY = e.centerY + e.scrollY), i } var Ch = Phaser.Cameras.Scene2D.BaseCamera,
        wh = Phaser.Geom.Rectangle,
        Sh = new wh(),
        Ph = Phaser.Utils.Objects.GetValue,
        Th = function() {
            function s(t, e) { X(this, s), this.scene = t, this.BobClass = Ph(e, "BobClass", rh), this.setCreateGameObjectCallback(Ph(e, "createGameObject"), Ph(e, "createGameObjectScope")), this.setEventEmitter(Ph(e, "eventEmitter", void 0)); var i = Ph(e, "fade", 500); "number" == typeof i ? (this.setGOFadeMode(), this.setGOFadeTime(i)) : (this.setGOFadeMode(Ph(i, "mode")), this.setGOFadeTime(Ph(i, "time", 500))); var n = Ph(e, "viewportCoordinate", !1);!1 !== n ? (this.setViewportCoordinateEnable(Ph(e, "enable", !0)), this.setViewport(Ph(n, "viewport"))) : this.setViewportCoordinateEnable(!1), this.setSymbols(Ph(e, "symbols")), this.bobs = {}, this.removedGOs = [], this._timeScale = 1 } return k(s, [{ key: "destroy", value: function(t) { this.clear(!t), this.createGameObjectCallback = void 0, this.viewport = void 0, this.scene = void 0 } }, { key: "timeScale", get: function() { return this._timeScale }, set: function(t) { if (this._timeScale !== t) { this._timeScale = t; var e = this.bobs; for (var i in e) e[i].setTimeScale(t) } } }, { key: "setTimeScale", value: function(t) { return this.timeScale = t, this } }, { key: "setCreateGameObjectCallback", value: function(t, e) { return this.createGameObjectCallback = t, this.createGameObjectScope = e, this } }, { key: "setViewportCoordinateEnable", value: function(t) { return void 0 === t && (t = !0), this.viewportCoordinateEnable = t, this } }, { key: "setViewport", value: function(t) { return void 0 === t && (t = xh(this.scene, this.scene.cameras.main)), this.viewport = t, this } }, { key: "setSymbols", value: function(t) { return this.symbols = t, this } }, { key: "isEmpty", get: function() { return function(t) { for (var e in t) return !1; return !0 }(this.bobs) && 0 === this.removedGOs.length } }]), s }();
    Object.assign(Th.prototype, ls, bh);

    function Oh(t, e) { void 0 === t && (t = {}), void 0 === e && (e = Th), t.createGameObjectScope || (t.createGameObjectScope = this); var i = new e(this.managersScene, t); return this.gameObjectManagers[t.name] = i, this }

    function Mh(t) { return this.gameObjectManagers[t] }

    function Eh() { var t = []; for (var e in this.gameObjectManagers) t.push(e); return t }

    function _h(t) { for (var e in this.timeline.timeScale = t, this.gameObjectManagers) this.gameObjectManagers[e].setTimeScale(t); return this }

    function Rh() { return this.timeline.timeScale }

    function Bh(t) { for (var e in this.soundManager && this.soundManager.destroy(t), this.soundManager = void 0, this.gameObjectManagers) this.gameObjectManagers[e].destroy(t), delete this.gameObjectManagers[e];
        this.timeline && this.timeline.destroy(), this.timeline = void 0, this.managersScene = void 0 }

    function Ih(i) { var t = function() { w(e, i); var t = T(e);

                function e() { return X(this, e), t.apply(this, arguments) } return k(e) }(),
            e = { initManagers: ba, addGameObjectManager: Oh, getGameObjectManager: Mh, getGameObjectManagerNames: Eh, setTimeScale: _h, getTimeScale: Rh, destroyManagers: Bh }; return Object.assign(t.prototype, e, Dh, zh), t }

    function Lh(t) { return t.replace(Fh, "\\$&").replace(Yh, "\\x2d") }

    function Ah(t) { return "string" != typeof t || ("" === t ? t = null : Xh.test(t) ? t = parseFloat(t) : "false" === t ? t = !1 : "true" === t && (t = !0)), t }

    function jh(t) { return t } var Dh = { addGameObjectManager: Oh, getGameObjectManager: function(t) { return this.gameObjectManagers[t] }, getGameObjectManagerNames: function() { var t = []; for (var e in this.gameObjectManagers) t.push(e); return t } },
        zh = { createGameObject: function(t, e) { for (var i, n = arguments.length, s = new Array(2 < n ? n - 2 : 0), r = 2; r < n; r++) s[r - 2] = arguments[r]; return (i = this.getGameObjectManager(t)).add.apply(i, [e].concat(s)), this }, destroyGameObject: function(t, e) { var i = this.getGameObjectManager(t); return void 0 === e ? i.removeAll() : i.remove(e), this }, callGameObjectMethod: function(t, e, i) { for (var n, s = arguments.length, r = new Array(3 < s ? s - 3 : 0), o = 3; o < s; o++) r[o - 3] = arguments[o]; return (n = this.getGameObjectManager(t)).call.apply(n, [e, i].concat(r)), this }, setGameObjectProperty: function(t, e, i, n) { return this.getGameObjectManager(t).setProperty(e, i, n), this }, easeGameObjectProperty: function(t, e, i, n, s, r, o, a) { return this.getGameObjectManager(t).easeProperty(e, i, n, s, r, o, a), this }, getGameObject: function(t, e, i) { var n = this.getGameObjectManager(t); if ("string" == typeof e) return n.getGO(e); var s = e; for (e in void 0 === s && (s = n.bobs), void 0 === i && (i = {}), s) i[e] = n.getGO(e); return i }, addGameObject: function(t, e, i) { var n = this.getGameObjectManager(t); if ("string" == typeof e) n.addGO(e, i);
                else { var s = e; for (e in s) n.addGO(e, s[e]) } return this }, drawGameObjectsBounds: function(t, e, i) { t instanceof Phaser.GameObjects.Graphics && (i = e, e = t, t = void 0), void 0 === t && (t = this.getGameObjectManagerNames()), Array.isArray(t) || (t = [t]); for (var n = 0, s = t.length; n < s; n++) this.getGameObjectManager(t[n]).drawGameObjectsBounds(e, i); return this } },
        Fh = /[|\\{}()[\]^$+*?.]/g,
        Yh = /-/g,
        Xh = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i,
        Wh = function() {
            function i(t) { X(this, i), this.setEventEmitter(ot(t, "eventEmitter", void 0)), this.setTagExpression(ot(t, "regex.tag", "[!$a-z0-9-_.]+")), this.setValueExpression(ot(t, "regex.value", "[ !$a-z0-9-_.#,|&]+")), this.setValueConverter(ot(t, "valueConvert", !0)); var e = ot(t, "delimiters", "<>");
                this.setDelimiters(e[0], e[1]), this.setLoopEnable(ot(t, "loop", !1)), this.isRunning = !1, this.isPaused = !1, this.skipEventFlag = !1, this.justCompleted = !1, this.lastTagStart = null, this.lastTagEnd = null, this.lastContent = null } return k(i, [{ key: "shutdown", value: function() { this.destroyEventEmitter() } }, { key: "destroy", value: function() { this.shutdown() } }, { key: "setTagExpression", value: function(t) { return this.tagExpression = t, this } }, { key: "setValueExpression", value: function(t) { return this.valueExpression = t, this } }, { key: "setValueConverter", value: function(t) { return t = !0 === t ? Ah : t || jh, this.valueConverter = t, this } }, { key: "setDelimiters", value: function(t, e) { void 0 === e && (e = t[1], t = t[0]), this.delimiterLeft = t, this.delimiterRight = e, t = Lh(t), e = Lh(e); var i = "".concat(t, "(").concat(this.tagExpression, ")(=(").concat(this.valueExpression, "))?").concat(e),
                        n = "".concat(t, "/(").concat(this.tagExpression, ")").concat(e); return this.reTagOn = RegExp(i, "i"), this.reTagOff = RegExp(n, "i"), this.reSplit = RegExp("".concat(i, "|").concat(n), "gi"), this } }, { key: "setLoopEnable", value: function(t) { return void 0 === t && (t = !0), this.loopEnable = t, this } }, { key: "setSource", value: function(t) { return this.source = t, this } }, { key: "resetIndex", value: function(t) { return void 0 === t && (t = 0), this.progressIndex = t, this.reSplit.lastIndex = t, this.lastTagStart = null, this.lastTagEnd = null, this.lastContent = null, this.justCompleted = !1, this.isRunning = !1, this } }, { key: "start", value: function(t) { return this.setSource(t).restart(), this } }, { key: "restart", value: function() { this.resetIndex().next() } }, { key: "next", value: function() { if (this.isPaused && this.onResume(), this.isRunning) return this; if (this.isRunning = !0, this.justCompleted) return this.isRunning = !1, this;
                    0 === this.reSplit.lastIndex && this.onStart(); var t = this.source,
                        e = t.length; for (this.reSplit.lastIndex = this.progressIndex;;) { var i = this.reSplit.exec(t); if (!i) { if (this.progressIndex < e && (this.onContent(t.substring(this.progressIndex, e)), this.isPaused)) { this.progressIndex = e; break } return this.onComplete(), void(this.isRunning = !1) } var n = i[0],
                            s = this.reSplit.lastIndex,
                            r = s - n.length; if (this.progressIndex < r && (this.onContent(t.substring(this.progressIndex, r)), this.isPaused)) { this.progressIndex = r; break } if (this.reTagOff.test(n) ? this.onTagEnd(n) : this.onTagStart(n), this.progressIndex = s, this.isPaused) break } return this.isRunning = !1, this } }, { key: "skipEvent", value: function() { return this.skipEventFlag = !0, this } }, { key: "pause", value: function() { return this.isPaused || this.onPause(), this } }, { key: "pauseUntilEvent", value: function(t, e) { return this.isPaused || (this.pause(), t.once(e, function() { this.next() }, this)), this } }, { key: "onContent", value: function(t) { this.skipEventFlag = !1, this.emit("content", t), this.lastContent = t } }, { key: "onTagStart", value: function(t) { var e = t.match(this.reTagOn),
                        i = e[1],
                        n = function(t, e) { if (null == t) return []; for (var i = t.split(","), n = 0, s = i.length; n < s; n++) i[n] = e(i[n]); return i }(e[3], this.valueConverter);
                    this.skipEventFlag = !1, this.emit.apply(this, ["+".concat(i)].concat(M(n))), this.skipEventFlag || this.emit.apply(this, ["+", i].concat(M(n))), this.lastTagStart = i } }, { key: "onTagEnd", value: function(t) { var e = t.match(this.reTagOff)[1];
                    this.skipEventFlag = !1, this.emit("-".concat(e)), this.skipEventFlag || this.emit("-", e), this.lastTagEnd = e } }, { key: "onStart", value: function() { this.isRunning = !0, this.emit("start", this) } }, { key: "onComplete", value: function() { this.isRunning = !1, this.justCompleted = !0, this.emit("complete", this), this.loopEnable && this.resetIndex() } }, { key: "onPause", value: function() { this.isPaused = !0, this.emit("pause", this) } }, { key: "onResume", value: function() { this.isPaused = !1, this.emit("resume", this) } }, { key: "getTagOnRegString", value: function(t, e) { return void 0 === t && (t = this.tagExpression), void 0 === e && (e = this.valueExpression), "".concat(Lh(this.delimiterLeft), "(").concat(t, ")(=(").concat(e, "))?").concat(Lh(this.delimiterRight)) } }, { key: "getTagOffRegString", value: function(t) { return void 0 === t && (t = this.tagExpression), "".concat(Lh(this.delimiterLeft), "/(").concat(t, ")").concat(Lh(this.delimiterRight)) } }]), i }();
    Object.assign(Wh.prototype, ls);

    function Gh(t) { this.typeWriter.setTypingSpeed(t) } var Vh = function(t, e) { So.call(t, "speed", Gh, e, t) },
        Uh = function(t) { if (!this.skipSoundEffect) { var e = t[0],
                    i = t[1];
                this.soundManager.playSoundEffect(e), i && this.soundManager.fadeInSoundEffect(i) } },
        Hh = function(t) { this.soundManager.fadeInSoundEffect(t) },
        Nh = function(t) { var e;
            (e = this.soundManager).fadeOutSoundEffect.apply(e, M(t)) },
        Jh = function(t) { this.soundManager.setSoundEffectVolume(t) },
        Kh = function(t) { var e = t[0],
                i = t[1];
            this.soundManager.playBackgroundMusic(e), i && this.soundManager.fadeInBackgroundMusic(i) },
        Zh = function() { this.soundManager.stopBackgroundMusic() },
        qh = function(t) { this.soundManager.fadeInBackgroundMusic(t) },
        $h = function(t) { var e;
            (e = this.soundManager).fadeOutBackgroundMusic.apply(e, M(t)) },
        Qh = function(t) { var e;
            (e = this.soundManager).crossFadeBackgroundMusic.apply(e, M(t)) };
    Phaser.Utils.Objects.GetValue;

    function tl(t) { this.typeWriter.wait(t) }

    function el(t, e) { var i = "tag.".concat(e);
        null == t ? this.emit(i) : this.emit.apply(this, [i].concat(M(t))) }

    function il(i, n) { return new Promise(function(t, e) { i.once(n, function() { t() }) }) }

    function nl(t) { return il(t, "complete") }

    function sl(t, e, i, n, s) { return function() { t.emit(Il, s), e.apply(n, i) } }

    function rl(t, e, i, n, s) { var r = sl(t, i, n, s, "custom"),
            o = e ? "wait.".concat(e) : "wait";
        t.emit(o, r) }

    function ol(t, e, i, n, s) { var r, o = sl(t, i, n, s, "time");
        t.once(Il, function() { r && (r.remove(), r = void 0) }), r = t.timeline.delayCall(e, o), t.emit("wait.time", e) }

    function al(t, e, i, n) { var s = t.clickEE; if (s) { var r = sl(t, e, i, n, "click");
            t.once(Il, function() { s.off("pointerdown", r, t) }), s.once("pointerdown", r, t), t.emit("wait.click") } }

    function hl(t, e, i, n, s) { var r = sl(t, i, n, s, "music");
        e && (t.once(Il, function() { e.off("complete", r, t) }), e.once("complete", r, t)), t.emit("wait.music", e), e || r() }

    function ll(t) { switch (t) {
            case "camera.fadein":
            case "camera.fadeout":
            case "camera.flash":
            case "camera.shake":
            case "camera.zoom":
            case "camera.rotate":
            case "camera.scroll":
                return 1;
            default:
                return } }

    function ul(e, t, i, n, s) { var r, o, a = sl(e, i, n, s, "camera.".concat(t)),
            h = e.camera; switch (t) {
            case "camera.fadein":
                r = h.fadeEffect, o = "camerafadeincomplete"; break;
            case "camera.fadeout":
                r = h.fadeEffect, o = "camerafadeoutcomplete"; break;
            case "camera.flash":
                r = h.flashEffect, o = "cameraflashcomplete"; break;
            case "camera.shake":
                r = h.shakeEffect, o = "camerashakecomplete"; break;
            case "camera.zoom":
                r = h.zoomEffect, o = "camerazoomcomplete"; break;
            case "camera.rotate":
                r = h.rotateToEffect, o = "camerarotatecomplete"; break;
            case "camera.scroll":
                r = h.panEffect, o = "camerapancomplete" }
        r.isRunning ? (e.once(Il, function(t) { h.off(o, a, e) }), h.once(o, a, e), e.emit("wait.camera", t)) : (e.emit("wait.camera", t), a()) }

    function cl(t, e, i, n, s) { var r = sl(t, i, n, s, "keydown"),
            o = "keydown-".concat(e.toUpperCase()),
            a = t.scene.input.keyboard;
        t.once(Il, function() { a.off(o, r, t) }), a.once(o, r, t), t.emit("wait.keydown", e) }

    function dl(i, t, e, n, s) { var r = sl(i, e, n, s),
            o = t.split("."),
            a = o[0],
            h = i.getGameObjectManager(a),
            l = "wait.".concat(a); switch (o.length) {
            case 1:
                return void(h.isEmpty ? (i.emit(l), r()) : (i.once(Il, function(t) { h.off("empty", r, i) }), h.once("empty", r, i), i.emit(l)));
            case 2:
                var u = o[1]; if (h.has(u)) { var c = h.get(u).gameObject;
                    i.once(Il, function() { c.off("destroy", r, i) }), c.once("destroy", r, i), i.emit(l, u) } else i.emit(l, u), r(); return;
            case 3:
                u = o[1]; var d = o[2]; if ("number" == typeof h.getProperty(u, d)) { var f = h.getTweenTask(u, d); return void(f ? (i.once(Il, function() { f.off("complete", r, i) }), f.once("complete", r, i), i.emit(l, u, d)) : (i.emit(l, u, d), r())) } var p = d,
                    v = p.startsWith("!"); if (v && (p = p.substring(1)), h.hasData(u, p)) { var g = (c = h.getGO(u)).getData(p),
                        y = !v; if (g === y) i.emit(l, u, d), r();
                    else { var m = "changedata-".concat(p);
                        e = function(t, e) {
                            (e = !!e) === y && r.call(i) };
                        i.once(Il, function() { c.off(m, e) }), c.on(m, e), i.emit(l, u, d) } return } } }

    function fl(t, e, i, n, s) { for (var r = 0, o = (e = "string" == typeof e && 1 < e.length && -1 !== e.indexOf("|") ? e.split("|") : [e]).length; r < o; r++) { var a = e[r]; if (null == a || "wait" === a) rl(t, void 0, i, n, s);
            else if ("number" != typeof a && isNaN(a))
                if ("click" === a) al(t, i, n, s);
                else if ("se" === a) { var h = t.soundManager.getLastSoundEffect();
                hl(t, h, i, n, s) } else if ("bgm" === a) { h = t.soundManager.getBackgroundMusic();
                hl(t, h, i, n, s) } else jl.hasOwnProperty(a.toUpperCase()) ? cl(t, a, i, n, s) : ll(a) ? ul(t, a, i, n, s) : (l = t, u = a.split("."), (l.gameObjectManagers.hasOwnProperty(u[0]) ? dl : rl)(t, a, i, n, s));
            else ol(t, parseFloat(a), i, n, s) } var l, u } var pl = function() { this.soundManager.pauseBackgroundMusic() },
        vl = function() { this.soundManager.resumeBackgroundMusic() },
        gl = function(t) { var e;
            (e = this.camera).fadeIn.apply(e, M(t)) },
        yl = function(t) { var e;
            (e = this.camera).fadeOut.apply(e, M(t)) },
        ml = function(t) { var e;
            (e = this.camera).shake.apply(e, M(t)) },
        kl = function(t) { var e;
            (e = this.camera).flash.apply(e, M(t)) },
        bl = function(t) { this.camera.setZoom(t) },
        xl = function(t) { var e;
            (e = this.camera).zoomTo.apply(e, M(t)) },
        Cl = Phaser.Math.DegToRad,
        wl = function(t) { this.camera.setRotation(t) },
        Sl = function(t) { var e = t[0],
                i = t[1],
                n = t[2];
            this.camera.rotateTo(e, !1, i, n) },
        Pl = function(t) { var e;
            (e = this.camera).setScroll.apply(e, M(t)) },
        Tl = function(t) { var e = t[0],
                i = t[1],
                n = t[2],
                s = t[3],
                r = this.camera,
                o = r.scrollX,
                a = r.scrollY;
            r.setScroll(e, i), e += r.centerX, i += r.centerY, r.setScroll(o, a), r.pan(e, i, n, s) },
        Ol = function(t, e) { So.call(t, "wait", tl, e, t) },
        Ml = function(t, e, i) { So.call(t, e, el, i, t) },
        El = [function(e, i) { var t;
            i.on("start", function() { t = e.textStyle.color }).on("+".concat("color"), function(t) { e.textStyle.setColor(t), i.skipEvent() }).on("-".concat("color"), function() { e.textStyle.setColor(t), i.skipEvent() }).on("complete", function() { e.textStyle.setColor(t) }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.stroke, e.textStyle.setStrokeStyle(null) }).on("+".concat("stroke"), function(t) { void 0 === t && (t = n), e.textStyle.setStrokeStyle(t), i.skipEvent() }).on("-".concat("stroke"), function() { e.textStyle.setStrokeStyle(null), i.skipEvent() }).on("complete", function() { e.textStyle.setStrokeStyle(n) }) }, function(t, e) { e.on("start", function() { t.textStyle.setBold(!1) }).on("+".concat("b"), function() { t.textStyle.setBold(!0), e.skipEvent() }).on("-".concat("b"), function() { t.textStyle.setBold(!1), e.skipEvent() }) }, function(t, e) { e.on("start", function() { t.textStyle.setItalic(!1) }).on("+".concat("i"), function() { t.textStyle.setItalic(!0), e.skipEvent() }).on("-".concat("i"), function() { t.textStyle.setItalic(!1), e.skipEvent() }) }, function(e, i) { var t;
            i.on("start", function() { t = e.textStyle.fontSize }).on("+".concat("size"), function(t) { e.textStyle.setFontSize(t), i.skipEvent() }).on("-".concat("size"), function() { e.textStyle.setFontSize(t), i.skipEvent() }).on("complete", function() { e.textStyle.setFontSize(t) }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.shadowColor, e.textStyle.setShadowColor(null) }).on("+".concat("shadow"), function(t) { void 0 === t && (t = n), e.textStyle.setShadowColor(t), i.skipEvent() }).on("-".concat("shadow"), function() { e.textStyle.setShadowColor(null), i.skipEvent() }).on("complete", function() { e.textStyle.setShadowColor(n) }) }, function(e, i) { i.on("+".concat("align"), function(t) { e.textStyle.setAlign(t), i.skipEvent() }).on("-".concat("align"), function() { e.textStyle.setAlign(), i.skipEvent() }).on("complete", function() { e.textStyle.setAlign() }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.offsetY, e.textStyle.setOffsetY(0) }).on("+".concat("y"), function(t) { void 0 === t && (t = n), e.textStyle.setOffsetY(t), i.skipEvent() }).on("-".concat("y"), function() { e.textStyle.setOffsetY(0), i.skipEvent() }).on("complete", function() { e.textStyle.setOffsetY(0) }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.offsetY, e.textStyle.setOffsetX(0) }).on("+".concat("x"), function(t) { void 0 === t && (t = n), e.textStyle.setOffsetX(t), i.skipEvent() }).on("-".concat("x"), function() { e.textStyle.setOffsetX(0), i.skipEvent() }).on("complete", function() { e.textStyle.setOffsetX(0) }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.leftSpace, e.textStyle.setLeftSpace(0) }).on("+".concat("left"), function(t) { void 0 === t && (t = n), e.textStyle.setLeftSpace(t), i.skipEvent() }).on("-".concat("left"), function() { e.textStyle.setLeftSpace(0), i.skipEvent() }).on("complete", function() { e.textStyle.setLeftSpace(0) }) }, function(e, i) { var n;
            i.on("start", function() { n = e.textStyle.rightSpace, e.textStyle.setRightSpace(0) }).on("+".concat("right"), function(t) { void 0 === t && (t = n), e.textStyle.setRightSpace(t), i.skipEvent() }).on("-".concat("right"), function() { e.textStyle.setRightSpace(0), i.skipEvent() }).on("complete", function() { e.textStyle.setRightSpace(0) }) }, function(i, n) { n.on("+".concat("img"), function(t) { var e = i.imageManager.get(t);
                Co.call(i, e.key, e.frame, { width: e.width, hieght: e.height, leftSpace: e.left, rightSpace: e.right }), n.skipEvent() }).on("-".concat("img"), function() { n.skipEvent() }) }, function(e, i) { i.on("+".concat("space"), function(t) { wo.call(e, t), i.skipEvent() }).on("-".concat("space"), function() { i.skipEvent() }) }, function(e, i) { i.on("+".concat("speed"), function(t) { Vh(e, t), i.skipEvent() }).on("-".concat("speed"), function() { Vh(e, void 0), i.skipEvent() }) }, function(i, n) { n.on("+".concat("se"), function(t, e) { So.call(i, "se", Uh, [t, e], i), n.skipEvent() }).on("-".concat("se"), function() { n.skipEvent() }) }, function(e, i) { i.on("+".concat("se.fadein"), function(t) { So.call(e, "se.fadein", Hh, t, e), i.skipEvent() }).on("-".concat("se.fadein"), function() { i.skipEvent() }) }, function(i, n) { var t = "se.fadeout";
            n.on("+".concat(t), function(t, e) { So.call(i, "se.fadeout", Nh, [t, e = "stop" === e], i), n.skipEvent() }).on("-".concat(t), function() { n.skipEvent() }) }, function(e, i) { i.on("+".concat("se.volume"), function(t) { So.call(e, "se.volume", Jh, t, e), i.skipEvent() }).on("-".concat("se.volume"), function() { i.skipEvent() }) }, function(i, n) { n.on("+".concat("bgm"), function(t, e) { So.call(i, "bgm", Kh, [t, e], i), n.skipEvent() }).on("-".concat("bgm"), function() { So.call(i, "bgm.stop", Zh, void 0, i), n.skipEvent() }) }, function(e, i) { var t = "bgm.fadein";
            i.on("+".concat(t), function(t) { So.call(e, "bgm.fadein", qh, t, e), i.skipEvent() }).on("-".concat(t), function() { i.skipEvent() }) }, function(i, n) { var t = "bgm.fadeout";
            n.on("+".concat(t), function(t, e) { So.call(i, "bgm.fadeout", $h, [t, e = "stop" === e], i), n.skipEvent() }).on("-".concat(t), function() { n.skipEvent() }) }, function(i, n) { n.on("+".concat("bgm.cross"), function(t, e) { So.call(i, "bgm.cross", Qh, [t, e], i), n.skipEvent() }).on("-".concat("bgm.cross"), function() { n.skipEvent() }) }, function(t, e) { e.on("+".concat("bgm.pause"), function() { So.call(t, "bgm.pause", pl, void 0, t), e.skipEvent() }).on("-".concat("bgm.pause"), function() { So.call(t, "bgm.resume", vl, void 0, t), e.skipEvent() }) }, function(s, r) { r.on("+".concat("camera.fadein"), function(t, e, i, n) { So.call(s, "camera.fadein", gl, [t, e, i, n], s), r.skipEvent() }) }, function(s, r) { r.on("+".concat("camera.fadeout"), function(t, e, i, n) { So.call(s, "camera.fadeout", yl, [t, e, i, n], s), r.skipEvent() }) }, function(i, n) { n.on("+".concat("camera.shake"), function(t, e) { So.call(i, "camera.shake", ml, [t, e], i), n.skipEvent() }) }, function(s, r) { r.on("+".concat("camera.flash"), function(t, e, i, n) { So.call(s, "camera.flash", kl, [t, e, i, n], s), r.skipEvent() }) }, function(n, s) { var t = "camera.zoom";
            s.on("+".concat(t), function(t) { So.call(n, "camera.zoom", bl, t, n), s.skipEvent() }).on("+".concat(t, ".to"), function(t, e, i) { So.call(n, "camera.zoom.to", xl, [t, e, i], n), s.skipEvent() }) }, function(n, s) { var t = "camera.rotate";
            s.on("+".concat(t), function(t) { t = Cl(t), So.call(n, "camera.rotate", wl, t, n), s.skipEvent() }).on("+".concat(t, ".to"), function(t, e, i) { t = Cl(t), So.call(n, "camera.rotate.to", Sl, [t, e, i], n), s.skipEvent() }) }, function(s, r) { var t = "camera.scroll";
            r.on("+".concat(t), function(t, e) { So.call(s, "camera.scroll", Pl, [t, e], s), r.skipEvent() }).on("+".concat(t, ".to"), function(t, e, i, n) { So.call(s, "camera.scroll.to", Tl, [t, e, i, n], s), r.skipEvent() }) }, function(e, i) { i.on("+".concat("wait"), function(t) { Ol(e, t), i.skipEvent() }).on("-".concat("wait"), function() { i.skipEvent() }).on("+".concat("click"), function() { Ol(e, "click"), i.skipEvent() }).on("-".concat("click"), function() { i.skipEvent() }) }, function(t, e) { e.on("+".concat("r"), function() { xo.call(t, "\n"), e.skipEvent() }).on("-".concat("r"), function() { e.skipEvent() }) }, function(t, e) { e.on("+".concat("content.off"), function() { e.setContentOutputEnable(!1), e.skipEvent() }) }, function(t, e) { e.on("+".concat("content.on"), function() { e.setContentOutputEnable(), e.skipEvent() }) }, function(i, n) { n.on("content", function(t) { if (n.contentOutputEnable) xo.call(i, t);
                else { var e = "+".concat(n.lastTagStart);
                    i.emit("parser.".concat(e, "#content"), n, t) } }) }, function(o, a) { a.on("start", function() { o.emit("parser.start", a) }).on("+", function(t) { if (!a.skipEventFlag) { for (var e = "+".concat(t), i = arguments.length, n = new Array(1 < i ? i - 1 : 0), s = 1; s < i; s++) n[s - 1] = arguments[s]; var r = n;
                    o.emit.apply(o, ["parser.".concat(e), a].concat(n, [r])), Ml(o, e, r) } }).on("-", function(t) { if (!a.skipEventFlag) { var e = "-".concat(t),
                        i = [];
                    o.emit("parser.".concat(e), a, i), Ml(o, e, i) } }).on("complete", function() { o.emit("parser.complete", a) }) }],
        _l = Phaser.Utils.Objects.GetValue,
        Rl = function() { w(s, Wh); var n = T(s);

            function s(t, e) { var i; return X(this, s), void 0 === e && (e = {}), e.hasOwnProperty("delimiters") || (e.delimiters = "[]"),
                    function(t, e, i) { for (var n = 0, s = El.length; n < s; n++) El[n](t, e, i) }(t, W(i = n.call(this, e)), e), i.setCommentLineStartSymbol(_l(e, "comment", "//")), i.setContentOutputEnable(), i } return k(s, [{ key: "setCommentLineStartSymbol", value: function(t) { return this.commentLineStart = t, this } }, { key: "setContentOutputEnable", value: function(t) { return void 0 === t && (t = !0), this.contentOutputEnable = t, this } }, { key: "start", value: function(t) { return O(C(s.prototype), "start", this).call(this, function(t, e) { for (var i = t.commentLineStart, n = e.split("\n"), s = 0, r = n.length; s < r; s++) { var o = n[s]; "" === o || (0 === o.trim().length || i && o.startsWith(i)) && (n[s] = "") } return n.join("") }(this, t)), this } }]), s }(),
        Bl = { setDefaultTypingSpeed: function(t) { return this.defaultSpeed = t, this }, setTypingSpeed: function(t) { return void 0 === t && (t = this.defaultSpeed), this.speed = t, this } },
        Il = "_remove.wait",
        Ll = "_remove.play",
        Al = [Il, Ll],
        jl = Phaser.Input.Keyboard.KeyCodes,
        Dl = { start: function(t) { return this.children = t, this.index = 0, this.isPageTyping = !0, this.onTypeStart && this.onTypeStart(t), this.typing(), nl(this) }, typing: function n(t) { void 0 === t && (t = 0); var e, i = 0; for (this.inTypingProcessLoop = !0; this.inTypingProcessLoop;) { var s = this.getNextChild(); if (!s) { this.timeline.isRunning ? this.timeline.once("complete", function() { this.isPageTyping = !1, this.emit("complete") }, this) : (this.isPageTyping = !1, this.emit("complete")); break } if (s.renderable) { var r = this.animationConfig; if (0 < r.duration) { var o = this.timeline.addTimer({ name: "anim", target: s, duration: r.duration, yoyo: r.yoyo, onStart: r.onStart, onProgress: r.onProgress, onComplete: r.onComplete });
                            this.skipTypingAnimation && o.seek(1) } else r.onStart && r.onStart(s, 0);
                        this.minSizeEnable && this.textPlayer.setToMinSize(), this.textPlayer.emit("typing", s); var a = this.nextChild; if (a && (!this.skipSpaceEnable || ((e = a).type !== Yo || " " !== e.text)) && (i += this.speed + t, (t = 0) < i)) { this.typingTimer = this.timeline.addTimer({ name: "delay", target: this, duration: i, onComplete: function(t, e, i) { t.typingTimer = void 0, n.call(t, i.remainder) } }); break } } else s.type === Xo && s.exec() }
                this.inTypingProcessLoop = !1 }, pause: function() { return this.timeline.pause(), this }, resume: function() { return this.timeline.resume(), this }, pauseTyping: function() { return this.isTypingPaused || (this.typingTimer ? (this.typingTimer.pause(), this.isTypingPaused = !0) : this.inTypingProcessLoop && (this.inTypingProcessLoop = !1, this.isTypingPaused = !0)), this }, resumeTyping: function(t) { return this.isTypingPaused && (void 0 === t && (t = 0), this.typingTimer ? (this.isTypingPaused = !1, this.typingTimer.resume(), this.typingTimer.remainder += t) : this.isTypingPaused && (this.isTypingPaused = !1, this.typing(t))), this }, wait: function(t) { return this.ignoreWait || (this.pauseTyping(), fl(this.textPlayer, t, this.resumeTyping, [], this)), this }, setIgnoreWait: function(t) { return void 0 === t && (t = !0), this.ignoreWait = t, this }, setSkipSpaceEnable: function(t) { return void 0 === t && (t = !0), this.skipSpaceEnable = t, this }, setSkipTypingAnimation: function(t) { if (void 0 === t && (t = !0), this.skipTypingAnimation = t)
                    for (var e = this.timeline.getTimers("anim"), i = 0, n = e.length; i < n; i++) e[i].seek(1); return this }, setSkipSoundEffect: function(t) { if (void 0 === t && (t = !0), this.skipSoundEffect = t) { var e = this.textPlayer._soundManager;
                    e && e.fadeOutAllSoundEffects(100, !0) } return this }, skipCurrentTypingDelay: function() { return this.typingTimer && this.typingTimer.seek(1), this } };
    Object.assign(Dl, Bl); var zl = Phaser.Utils.Objects.GetValue,
        Fl = function() {
            function i(t, e) { X(this, i), this.setEventEmitter(), this.textPlayer = t, this.isPageTyping = !1, this.typingTimer = void 0, this.pauseTypingTimer = void 0, this.inTypingProcessLoop = !1, this.isTypingPaused = !1, this.setIgnoreWait(!1), this.setSkipTypingAnimation(!1), this.setTypingStartCallback(zl(e, "onTypingStart", Xl)), this.setDefaultTypingSpeed(zl(e, "speed", 250)), this.setTypingSpeed(), this.setSkipSpaceEnable(zl(e, "skipSpace", !1)), this.setAnimationConfig(zl(e, "animation", void 0)), this.setMinSizeEnable(zl(e, "minSizeEnable", !1)) } return k(i, [{ key: "destroy", value: function() { this.destroyEventEmitter(), this.textPlayer = void 0, this.typingTimer = void 0, this.pauseTypingTimer = void 0, this.onTypeStart = void 0, this.animationConfig = void 0 } }, { key: "timeline", get: function() { return this.textPlayer.timeline } }, { key: "setTypingStartCallback", value: function(t) { return this.onTypeStart = t, this } }, { key: "setAnimationConfig", value: function(t) { return (t = t || {}).hasOwnProperty("duration") || (t.duration = 0), t.hasOwnProperty("onStart") || (t.onStart = Yl), this.animationConfig = t, this } }, { key: "setMinSizeEnable", value: function(t) { return void 0 === t && (t = !0), this.minSizeEnable = t, this } }, { key: "getNextChild", value: function() { var t = this.nextChild; return this.index = Math.min(this.index + 1, this.children.length), this._nextChild = void 0, t } }, { key: "nextChild", get: function() { return this._nextChild || (this._nextChild = this.children[this.index]), this._nextChild } }]), i }(),
        Yl = function(t) { t.setVisible && t.setVisible() },
        Xl = function(t) { for (var e = 0, i = t.length; e < i; e++) { var n = t[e];
                n.setVisible && n.setVisible(!1) } };
    Object.assign(Fl.prototype, ls, Dl); var Wl = function() { w(e, rh); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "playAnimation", value: function(t) { return this.gameObject.anims.timeScale = this.timeScale, this.gameObject.play(t), this } }, { key: "stopAnimation", value: function() { return this.gameObject.stop(), this } }, { key: "chainAnimation", value: function(t) { return this.gameObject.chain(t), this } }, { key: "pauseAnimation", value: function() { return this.gameObject.anims.pause(), this } }, { key: "setTimeScale", value: function(t) { return O(C(e.prototype), "setTimeScale", this).call(this, t), this.gameObject.anims && (this.gameObject.anims.timeScale = t), this } }]), e }(),
        Gl = {};
    Object.assign(Gl, { playAnimation: function(t, e) { return this.has(t) || this.add(t), this.get(t).playAnimation(e), this }, stopAnimation: function(t) { return this.has(t) && this.get(t).stopAnimation(), this }, chainAnimation: function(t, e) { return this.has(t) && this.get(t).chainAnimation(e), this }, pauseAnimation: function(t) { return this.has(t) && this.get(t).pauseAnimation(), this } }); var Vl = function() { w(n, Th); var i = T(n);

            function n(t, e) { return X(this, n), void 0 === e && (e = {}), e.BobClass = Wl, i.call(this, t, e) } return k(n, [{ key: "setCreateGameObjectCallback", value: function(t, e) { return t && "sprite" !== t ? "image" === t && (t = Hl) : t = Ul, O(C(n.prototype), "setCreateGameObjectCallback", this).call(this, t, e), this } }]), n }(),
        Ul = function(t, e, i) { return "string" != typeof i && "number" != typeof i && (i = void 0), t.add.sprite(0, 0, e, i) },
        Hl = function(t, e, i) { return "string" != typeof i && "number" != typeof i && (i = void 0), t.add.image(0, 0, e, i) };
    Object.assign(Vl.prototype, Gl);

    function Nl(t, e) { return 3 === t.length && t[0] === e && "play" === t[2] }

    function Jl(t, e) { return 2 === t.length && t[0] === e } var Kl = function(t) { var e, i, n, s = f(t, 3);
            e = s[0], i = s[1]; var r = (n = s[2]).shift(),
                o = this.getGameObjectManager(e);
            o.playAnimation(i, r), 0 < n.length && o.chainAnimation(i, n) },
        Zl = function(t) { var e, i, n = S(t);
            e = n[0], i = n.slice(1); var s = this.getGameObjectManager(e);
            s.stopAnimation.apply(s, M(i)) },
        ql = function(t) { var e, i, n = S(t);
            e = n[0], i = n.slice(1); var s = this.getGameObjectManager(e);
            s.pauseAnimation.apply(s, M(i)) },
        $l = function(t) { var e, i, n = S(t);
            e = n[0], i = n.slice(1); var s = this.getGameObjectManager(e);
            s.chainAnimation.apply(s, M(i)) },
        Ql = [function(o, a, t) { var h = t.name;
            a.on("+", function(t) { if (!a.skipEventFlag) { var e, i = t.split("."); if (Nl(i, h)) { e = i[1]; for (var n = arguments.length, s = new Array(1 < n ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r];
                        So.call(o, "".concat(h, ".play"), Kl, [h, e, s], o), a.skipEvent() } } }).on("+", function(t) { if (!a.skipEventFlag) { var e, i, n, s = t.split("."); if (n = h, 3 === (i = s).length && i[0] === n && "stop" === i[2]) e = s[1], So.call(o, "".concat(h, ".stop"), Zl, [h, e], o), a.skipEvent() } }).on("-", function(t) { if (!a.skipEventFlag) { var e, i = t.split(".");
                    Nl(i, h) && (e = i[1], So.call(o, "".concat(h, ".stop"), Zl, [h, e], o), a.skipEvent()) } }) }, function(r, o, t) { var a = t.name;
            o.on("+", function(t) { if (!o.skipEventFlag) { var e, i, n, s = t.split("."); if (n = a, 3 === (i = s).length && i[0] === n && "pause" === i[2]) e = s[1], So.call(r, "".concat(a, ".pause"), ql, [a, e], r), o.skipEvent() } }) }, function(o, a, t) { var h = t.name;
            a.on("+", function(t) { if (!a.skipEventFlag) { var e, i = t.split("."); if (s = h, 3 === (n = i).length && n[0] === s && "chain" === n[2]) { var n, s;
                        e = i[1]; var r = Array.prototype.slice.call(arguments, 1);
                        So.call(o, "".concat(h, ".chain"), $l, [h, e, r], o), a.skipEvent() } } }) }],
        tu = function(t) { var e, i, n = S(t);
            e = n[0], i = n.slice(1); var s = this.getGameObjectManager(e);
            s.add.apply(s, M(i)) },
        eu = function(t) { var e, i, n = S(t);
            e = n[0], i = n.slice(1); var s = this.getGameObjectManager(e);
            s.remove.apply(s, M(i)) },
        iu = function(t) { this.getGameObjectManager(t).removeAll() },
        nu = function(t) { var e, i, n, s, r = S(t);
            e = r[0], i = r[1], n = r[2], s = r.slice(3); var o = "".concat(e, ".").concat(n); if (this.emit.apply(this, [o, i].concat(M(s))), !(0 < this.listenerCount(o))) { var a = this.getGameObjectManager(e);
                a.hasMethod(i, n) ? a.call.apply(a, [i, n].concat(M(s))) : a.setProperty(i, n, s[0]) } },
        su = { to: !0, yoyo: !0, from: !0, toLeft: !0, toRight: !0, toUp: !0, toDown: !0, yoyoLeft: !0, yoyoRight: !0, yoyoUp: !0, yoyoDown: !0, fromLeft: !0, fromRight: !0, fromUp: !0, fromDown: !0 },
        ru = function(t) { var e, i, n, s, r, o, a, h, l = f(t, 8);
            e = l[0], i = l[1], n = l[2], s = l[3], r = l[4], o = l[5], a = l[6], h = l[7]; var u = this.getGameObjectManager(e),
                c = u.getProperty(i, n); if ("number" == typeof c) { h.endsWith("Left") || h.endsWith("Up") ? h.startsWith("to") || h.startsWith("yoyo") ? s = c - s : h.startsWith("from") && (u.setProperty(i, n, c - s), s = c) : h.endsWith("Right") || h.endsWith("Down") ? h.startsWith("to") || h.startsWith("yoyo") ? s = c + s : h.startsWith("from") && (u.setProperty(i, n, c + s), s = c) : "from" === h && (u.setProperty(i, n, s), s = c); var d = h.startsWith("yoyo");
                u.easeProperty(i, n, s, r, o, a, d) } },
        ou = [function(o, a, t) { var h = t.name;
            a.on("+", function(t) { if (!a.skipEventFlag) { var e, i = t.split("."); if (Jl(i, h)) { e = i[1]; for (var n = arguments.length, s = new Array(1 < n ? n - 1 : 0), r = 1; r < n; r++) s[r - 1] = arguments[r];
                        So.call(o, "".concat(h, ".add"), tu, [h, e].concat(s), o), a.skipEvent() } } }).on("-", function(t) { if (!a.skipEventFlag) { var e, i = t.split(".");
                    Jl(i, h) && (e = i[1], So.call(o, "".concat(h, ".remove"), eu, [h, e], o), a.skipEvent()) } }) }, function(e, i, t) { var n = t.name;
            i.on("-", function(t) { i.skipEventFlag || t === n && (So.call(e, "".concat(n, ".removeall"), iu, n, e), i.skipEvent()) }) }, function(l, u, t) { var c = t.name;
            u.on("+", function(t) { if (!u.skipEventFlag) { var e, i, n = t.split("."); if (r = c, 3 === (s = n).length && s[0] === r) { var s, r;
                        e = n[1], i = n[2]; for (var o = arguments.length, a = new Array(1 < o ? o - 1 : 0), h = 1; h < o; h++) a[h - 1] = arguments[h];
                        So.call(l, "".concat(c, ".call"), nu, [c, e, i].concat(a), l), u.skipEvent() } } }) }, function(c, d, t) { var f = t.name;
            c.getGameObjectManager(f), d.on("+", function(t, e, i, n, s) { if (!d.skipEventFlag) { var r, o, a, h, l, u = t.split("."); if (l = f, 4 === (h = u).length && h[0] === l && su[h[3]]) r = u[1], o = u[2], a = u[3], "number" == typeof n && (s = n, n = void 0), So.call(c, "".concat(f, ".ease"), ru, [f, r, o, e, i, n, s, a], c), d.skipEvent() } }) }],
        au = { addGameObjectManager: function(t, e) { void 0 === t && (t = {}), t.name || console.warn("Parameter 'name' is required in TextPlayer.addGameObjectManager(config) method"), Oh.call(this, t, e); for (var i = t.parseCallbacks, n = 0, s = (i = i ? [].concat(M(i), ou) : ou).length; n < s; n++) i[n](this, this.parser, t); return this } },
        hu = { play: function(t) { return this.isPlaying || (this.removeChildren(), this.parser.start(t), this.isPlaying = !0, this.once("complete", function() { this.isPlaying = !1 }, this), this.lastWrapResult = void 0, this.typingNextPage()), this }, playPromise: function(t) { var e = nl(this); return this.play(t), e } },
        lu = Phaser.Utils.Objects.GetValue,
        uu = { setClickTarget: function(t) { return (this.clickTarget = t) ? as(t) ? this.clickEE = t.input : this.clickEE = t.setInteractive() : this.clickEE = null, this }, setTargetCamera: function(t) { return this.camera = t, this }, setNextPageInput: function(s) { var r = this;
                this.nextPageInput = s ? "function" == typeof s ? function(t, e, i) { var n = sl(r, t, e, i);
                    s.call(r, n) } : function(t, e, i) { fl(r, s, t, e, i) } : null }, addImage: function(t, e) { return this.imageManager.add(t, e), this }, typingNextPage: function t() { if (!this.isPlaying || this.isPageTyping) return this; var e = lu(this.wrapConfig, "callback", this.runWordWrap); "string" == typeof e && (e = this[e]); var i = e.call(this, this.lastWrapResult);
                this.lastWrapResult = i, this.emit("page.start");

                function n() { this.emit(Ll), i.isLastPage ? this.emit("complete") : (this.emit("page.complete"), this.ignoreNextPageInput ? t.call(this) : this.nextPageInput && this.nextPageInput(t, [], this)) }
                this.once(Ll, function() { this.typeWriter.off("complete", n, this) }), this.typeWriter.once("complete", n, this).start(i.children) }, wait: function(t) { return this.typeWriter.wait(t), this }, setIgnoreWait: function(t) { return this.typeWriter.setIgnoreWait(t), this }, setIgnoreNextPageInput: function(t) { return void 0 === t && (t = !0), this.ignoreNextPageInput = t, this }, showPage: function() { if (!this.isPlaying || !this.isPageTyping) return this; var t = this.typeWriter.speed,
                    e = this.typeWriter.ignoreWait,
                    i = this.typeWriter.skipTypingAnimation,
                    n = this.typeWriter.skipSoundEffect; return this.typeWriter.once("complete", function() { this.typeWriter.setTypingSpeed(t).setIgnoreWait(e).setSkipTypingAnimation(i).setSkipSoundEffect(n) }, this).setTypingSpeed(0).skipCurrentTypingDelay().setIgnoreWait(!0).setSkipTypingAnimation(!0).setSkipSoundEffect(!0), this } };
    Object.assign(uu, au, hu, { pause: function() { return this.timeline.pause(), this }, pauseTyping: function() { return this.typeWriter.pauseTyping(), this } }, { resume: function() { return this.timeline.resume(), this }, resumeTyping: function(t) { return this.typeWriter.resumeTyping(t), this } }, { setDefaultTypingSpeed: function(t) { return this.defaultTypingSpeed = t, this }, setTypingSpeed: function(t) { return this.typingSpeed = t, this } }, { getSprite: function(t) { return this.getGameObject("sprite", t) }, addSprite: function(t, e) { return this.addGameObject("sprite", t, e), this } }, { setContentOutputEnable: function(t) { return this.parser.setContentOutputEnable(t), this }, setContentCallback: function(t, e) { return this.contentCallback = t, this.contentCallbackScope = e, this } }); var cu = Phaser.Utils.Objects.IsPlainObject,
        du = Phaser.Utils.Objects.GetValue,
        fu = function() { w(c, Ih(ya)); var u = T(c);

            function c(t, e, i, n, s, r) { var o;
                X(this, c), cu(e) ? r = e : cu(n) && (r = n), void 0 === r && (r = {}); var a = r.text;
                delete r.text, (o = u.call(this, t, e, i, n, s, r)).type = "rexTextPlayer", o.parser = new Rl(W(o), du(r, "parser", void 0)), o.typeWriter = new Fl(W(o), du(r, "typing", void 0)), o._imageManager = void 0; var h = du(r, "images", void 0);
                h && o.addImage(h), o.setTargetCamera(du(r, "camera", o.scene.sys.cameras.main)), o.initManagers(t, r); var l = du(r, "sprites"); return !1 !== l && null !== l && function(t) { void 0 === t && (t = {}), t.name = "sprite", t.parseCallbacks = Ql, this.addGameObjectManager(t, Vl) }.call(W(o), l), o.setIgnoreNextPageInput(du(r, "ignoreNextPageInput", !1)), o.setClickTarget(du(r, "clickTarget", W(o))), o.setNextPageInput(du(r, "nextPageInput", null)), o.isPlaying = !1, a && o.play(a), o } return k(c, [{ key: "imageManager", get: function() { return void 0 === this._imageManager && (this._imageManager = new fi(this.scene)), this._imageManager } }, { key: "spriteManager", get: function() { return this.getGameObjectManager("sprite") } }, { key: "destroy", value: function(t) { this.scene && (function(t) { for (var e = 0, i = Al.length; e < i; e++) t.emit(Al[e]) }(this), this.parser.destroy(), this.parser = void 0, this.typeWriter.destroy(t), this.typeWriter = void 0, this._imageManager && this._imageManager.destroy(t), this._imageManager = void 0, this.camera = void 0, this.clickEE = void 0, this.destroyManagers(t), O(C(c.prototype), "destroy", this).call(this, t)) } }, { key: "isPageTyping", get: function() { return this.typeWriter.isPageTyping } }, { key: "defaultTypingSpeed", get: function() { return this.typeWriter.defaultTypingSpeed }, set: function(t) { this.typeWriter.setDefaultTypingSpeed(t) } }, { key: "typingSpeed", get: function() { return this.typeWriter.speed }, set: function(t) { this.typeWriter.setTypingSpeed(t) } }, { key: "timeScale", get: function() { return this.getTimeScale() }, set: function(t) { this.setTimeScale(t) } }]), c }();
    Object.assign(fu.prototype, uu), p.register("textPlayer", function(t, e, i, n, s) { var r = new fu(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.TextPlayer", fu); var pu = function() { w(n, Ts); var i = T(n);

            function n(o, t) { var e; return X(this, n), void 0 === t && (t = {}), "number" === t.onUpdate && (t.onUpdate = Os), e = i.call(this, o, t), o.on("pointerdown", function(t, e, i, n) { var s = o.getNearestChild(e, i),
                        r = o.getCharIndex(s);
                    this.setCursorPosition(r) }, W(e)), e.on("open", function() { o.emit("open") }).on("close", function() { o.emit("close") }), e } return k(n, [{ key: "initText", value: function() { var t = this.parent; return this.prevCursorPosition = null, this.setText(t.text), this } }, { key: "updateText", value: function() { var t = this.parent,
                        e = this.text; if (this.onUpdateCallback) { var i = this.onUpdateCallback(e, t, this);
                        null != i && (e = i) }
                    t.setText(e); var n = this.isOpened ? this.cursorPosition : null; if (this.prevCursorPosition !== n) { if (null != this.prevCursorPosition && this.prevCursorPosition > e.length && (this.prevCursorPosition = null), null != this.prevCursorPosition) { var s = t.getCharChild(this.prevCursorPosition);
                            t.emit("cursorout", s, this.prevCursorPosition, t) } if (null != n) { s = t.getCharChild(n);
                            t.emit("cursorin", s, n, t) }
                        t.emit("movecursor", n, this.prevCursorPosition, t), this.prevCursorPosition = n } return this } }]), n }(),
        vu = Phaser.Utils.Objects.GetValue;

    function gu() {}

    function yu(t, e, i, n, s) { for (var r = 0, o = e.length, a = 0, h = 0; r < o; r++) { var l = e[r]; if (l.removed) { if (l.value = t.join(n.slice(h, h + l.count)), h += l.count, r && e[r - 1].added) { var u = e[r - 1];
                    e[r - 1] = e[r], e[r] = u } } else { if (!l.added && s) { var c = i.slice(a, a + l.count);
                    c = c.map(function(t, e) { var i = n[h + e]; return i.length > t.length ? i : t }), l.value = t.join(c) } else l.value = t.join(i.slice(a, a + l.count));
                a += l.count, l.added || (h += l.count) } } var d = e[o - 1]; return 1 < o && "string" == typeof d.value && (d.added || d.removed) && t.equals("", d.value) && (e[o - 2].value += d.value, e.pop()), e }
    gu.prototype = { diff: function(h, l, t) { var e = 2 < arguments.length && void 0 !== t ? t : {},
                i = e.callback; "function" == typeof e && (i = e, e = {}), this.options = e; var u = this;

            function c(t) { return i ? (setTimeout(function() { i(void 0, t) }, 0), !0) : t }
            h = this.castInput(h), l = this.castInput(l), h = this.removeEmpty(this.tokenize(h)); var d = (l = this.removeEmpty(this.tokenize(l))).length,
                f = h.length,
                p = 1,
                n = d + f;
            e.maxEditLength && (n = Math.min(n, e.maxEditLength)); var v = [{ newPos: -1, components: [] }],
                s = this.extractCommon(v[0], l, h, 0); if (v[0].newPos + 1 >= d && f <= s + 1) return c([{ value: this.join(l), count: l.length }]);

            function r() { for (var t = -1 * p; t <= p; t += 2) { var e = void 0,
                        i = v[t - 1],
                        n = v[t + 1],
                        s = (n ? n.newPos : 0) - t;
                    i && (v[t - 1] = void 0); var r = i && i.newPos + 1 < d,
                        o = n && 0 <= s && s < f; if (r || o) { if (!r || o && i.newPos < n.newPos ? (e = { newPos: (a = n).newPos, components: a.components.slice(0) }, u.pushComponent(e.components, void 0, !0)) : ((e = i).newPos++, u.pushComponent(e.components, !0, void 0)), s = u.extractCommon(e, l, h, t), e.newPos + 1 >= d && f <= s + 1) return c(yu(u, e.components, l, h, u.useLongestToken));
                        v[t] = e } else v[t] = void 0 } var a;
                p++ } if (i) ! function t() { setTimeout(function() { if (n < p) return i();
                    r() || t() }, 0) }();
            else
                for (; p <= n;) { var o = r(); if (o) return o } }, pushComponent: function(t, e, i) { var n = t[t.length - 1];
            n && n.added === e && n.removed === i ? t[t.length - 1] = { count: n.count + 1, added: e, removed: i } : t.push({ count: 1, added: e, removed: i }) }, extractCommon: function(t, e, i, n) { for (var s = e.length, r = i.length, o = t.newPos, a = o - n, h = 0; o + 1 < s && a + 1 < r && this.equals(e[o + 1], i[a + 1]);) o++, a++, h++; return h && t.components.push({ count: h }), t.newPos = o, a }, equals: function(t, e) { return this.options.comparator ? this.options.comparator(t, e) : t === e || this.options.ignoreCase && t.toLowerCase() === e.toLowerCase() }, removeEmpty: function(t) { for (var e = [], i = 0; i < t.length; i++) t[i] && e.push(t[i]); return e }, castInput: function(t) { return t }, tokenize: function(t) { return t.split("") }, join: function(t) { return t.join("") } }; var mu = new gu(); var ku = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,
        bu = /\S/,
        xu = new gu();
    xu.equals = function(t, e) { return this.options.ignoreCase && (t = t.toLowerCase(), e = e.toLowerCase()), t === e || this.options.ignoreWhitespace && !bu.test(t) && !bu.test(e) }, xu.tokenize = function(t) { for (var e = t.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), i = 0; i < e.length - 1; i++) !e[i + 1] && e[i + 2] && ku.test(e[i]) && ku.test(e[i + 2]) && (e[i] += e[i + 2], e.splice(i + 1, 2), i--); return e }; var Cu = new gu();
    Cu.tokenize = function(t) { var e = [],
            i = t.split(/(\n|\r\n)/);
        i[i.length - 1] || i.pop(); for (var n = 0; n < i.length; n++) { var s = i[n];
            n % 2 && !this.options.newlineIsToken ? e[e.length - 1] += s : (this.options.ignoreWhitespace && (s = s.trim()), e.push(s)) } return e }, (new gu()).tokenize = function(t) { return t.split(/(\S.+?[.!?])(?=\s+|$)/) }, (new gu()).tokenize = function(t) { return t.split(/([{}:;,]|\s+)/) }; var wu = Object.prototype.toString,
        Su = new gu();
    Su.useLongestToken = !0, Su.tokenize = Cu.tokenize, Su.castInput = function(t) { var e = this.options,
            i = e.undefinedReplacement,
            n = e.stringifyReplacer,
            s = void 0 === n ? function(t, e) { return void 0 === e ? i : e } : n; return "string" == typeof t ? t : JSON.stringify(function t(e, i, n, s, r) { i = i || [];
            n = n || [];
            s && (e = s(r, e)); var o; for (o = 0; o < i.length; o += 1)
                if (i[o] === e) return n[o];
            var a; if ("[object Array]" === wu.call(e)) { for (i.push(e), a = new Array(e.length), n.push(a), o = 0; o < e.length; o += 1) a[o] = t(e[o], i, n, s, r); return i.pop(), n.pop(), a }
            e && e.toJSON && (e = e.toJSON()); if ("object" === P(e) && null !== e) { i.push(e), a = {}, n.push(a); var h, l = []; for (h in e) e.hasOwnProperty(h) && l.push(h); for (l.sort(), o = 0; o < l.length; o += 1) h = l[o], a[h] = t(e[h], i, n, s, h);
                i.pop(), n.pop() } else a = e; return a }(t, null, null, s), s, "  ") }, Su.equals = function(t, e) { return gu.prototype.equals.call(Su, t.replace(/,([\r\n])/g, "$1"), e.replace(/,([\r\n])/g, "$1")) }; var Pu = new gu();
    Pu.tokenize = function(t) { return t.slice() }, Pu.join = Pu.removeEmpty = function(t) { return t };

    function Tu(t, e) { var i = t.text; if (e !== i) { for (var n, s, r, o = (n = i, s = e, mu.diff(n, s, r)), a = 0, h = 0, l = o.length; h < l; h++) { var u = o[h];
                u.removed ? t.removeText(a, u.count) : (u.added && t.insertText(a, u.value), a += u.count) }
            t.runWordWrap() } } var Ou = Phaser.Utils.Objects.GetValue,
        Mu = Phaser.Utils.Objects.IsPlainObject,
        Eu = function() { w(m, ya); var y = T(m);

            function m(t, e, i, n, s, r) { var o;
                X(this, m), Mu(e) ? r = e : Mu(n) && (r = n), void 0 === r && (r = {}); var a, h, l, u = Ou(r, "text", void 0);
                u && delete r.text, (o = y.call(this, t, e, i, n, s, r)).type = "rexCanvasInput", o.textEdit = (a = W(o), void 0 === (l = vu(h = r, "edit")) && (l = {}), fs(h, l, "inputType"), fs(h, l, "enterClose"), fs(h, l, "onOpen"), fs(h, l, "onFocus"), fs(h, l, "onClose"), fs(h, l, "onBlur"), fs(h, l, "onUpdate"), new pu(a, l)); var c = Ou(r, "onAddChar");
                c && o.on("addchar", c); var d = Ou(r, "onCursorOut");
                d && o.on("cursorout", d); var f = Ou(r, "onCursorIn");
                f && o.on("cursorin", f); var p, v, g = Ou(r, "onMoveCursor"); return g && o.on("movecursor", g), o.lastInsertCursor = (p = W(o), (v = p.createCharChild("|")).text = "", mo.call(p, v), v), u ? o.setText(u) : o.runWordWrap(), o } return k(m, [{ key: "addChild", value: function(t, e) { if (O(C(m.prototype), "addChild", this).call(this, t, e), Array.isArray(t))
                        for (var i = t, n = 0, s = i.length; n < s; n++) { t = i[n];
                            bo(t) && this.emit("addchar", t, e + n, this) } else bo(t) && this.emit("addchar", t, e, this); return this } }, { key: "setText", value: function(t) { return this.moveChildToLast(this.lastInsertCursor), Tu(this, t), this } }, { key: "appendText", value: function(t) { return this.setText(this.text + t), this } }, { key: "open", value: function(t) { return t && this.textEdit.once("close", t), this.textEdit.open(), this } }, { key: "close", value: function() { return this.textEdit.close(), this } }, { key: "isOpened", get: function() { return this.textEdit.isOpened } }]), m }();
    p.register("canvasInput", function(t, e, i, n, s) { var r = new Eu(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.CanvasInput", Eu); var _u = Phaser.Math.Linear,
        Ru = Phaser.Math.Percent,
        Bu = { setValue: function(t, e, i) { return null == t || (void 0 !== e && (t = Ru(t, e, i)), this.value = t), this }, addValue: function(t, e, i) { return void 0 !== e && (t = Ru(t, e, i)), this.value += t, this }, getValue: function(t, e) { var i = this.value; return void 0 !== t && (i = _u(t, e, i)), i } },
        Iu = Phaser.Utils.Objects.GetValue,
        Lu = Phaser.Math.Linear,
        Au = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(), i.boot(), i } return k(s, [{ key: "start", value: function(t) { if (this.timer.isRunning) return this; var e = this.target;
                    this.propertyKey = Iu(t, "key", "value"); var i = e[this.propertyKey]; return this.fromValue = Iu(t, "from", i), this.toValue = Iu(t, "to", i), this.setEase(Iu(t, "ease", this.ease)), this.setDuration(Iu(t, "duration", this.duration)), this.setRepeat(Iu(t, "repeat", 0)), this.setDelay(Iu(t, "delay", 0)), this.setRepeatDelay(Iu(t, "repeatDelay", 0)), this.timer.setDuration(this.duration).setRepeat(this.repeat).setDelay(this.delay).setRepeatDelay(this.repeatDelay), e[this.propertyKey] = this.fromValue, O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function(t, e) { var i = e.t;
                    i = this.easeFn(i), t[this.propertyKey] = Lu(this.fromValue, this.toValue, i) } }]), s }(),
        ju = Phaser.Math.Percent,
        Du = { setEaseValuePropName: function(t) { return this.easeValuePropName = t, this }, setEaseValueDuration: function(t) { return this.easeValueDuration = t, this }, setEaseValueFunction: function(t) { return this.easeFunction = t, this }, stopEaseValue: function() { return this.easeValueTask && this.easeValueTask.stop(), this }, easeValueTo: function(t, e, i) { return null == t || (void 0 !== e && (t = ju(t, e, i)), void 0 === this.easeValueTask && (this.easeValueTask = new Au(this, { eventEmitter: null })), this.easeValueTask.restart({ key: this.easeValuePropName, to: t, duration: this.easeValueDuration, ease: this.easeFunction })), this }, easeValueRepeat: function(t, e, i, n) { return void 0 === i && (i = -1), void 0 === n && (n = 0), void 0 === this.easeValueTask && (this.easeValueTask = new Au(this, { eventEmitter: null })), this.easeValueTask.restart({ key: this.easeValuePropName, from: t, to: e, duration: this.easeValueDuration, ease: this.easeFunction, repeat: i, repeatDelay: n }), this } },
        zu = Phaser.Utils.Objects.GetValue,
        Fu = Phaser.Math.Clamp;

    function Yu(i) { var t = function() { w(e, i); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "bootProgressBase", value: function(t) { this.eventEmitter = zu(t, "eventEmitter", this); var e = zu(t, "valuechangeCallback", null); if (null !== e) { var i = zu(t, "valuechangeCallbackScope", void 0);
                        this.eventEmitter.on("valuechange", e, i) } return this.setEaseValuePropName("value").setEaseValueDuration(zu(t, "easeValue.duration", 0)).setEaseValueFunction(zu(t, "easeValue.ease", "Linear")), this } }, { key: "value", get: function() { return this._value }, set: function(t) { t = Fu(t, 0, 1); var e = this._value,
                        i = e != t;
                    this.dirty = this.dirty || i, this._value = t, i && this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter) } }]), e }(); return Object.assign(t.prototype, Bu, Du), t }

    function Xu(t, e, i, n, s, r, o, a, h, l, u, c) { void 0 === l && (l = 0), void 0 === u && (u = 2 * Math.PI), void 0 === c && (c = !1), e.beginPath(), e.ellipse(i, n, s, r, 0, l, u, c), null != o && (e.fillStyle = o, e.fill()), null != a && (e.strokeStyle = a, e.lineWidth = h, e.stroke()) } var Wu = Phaser.Utils.Objects.GetValue,
        Gu = Phaser.Utils.Objects.IsPlainObject,
        Vu = Phaser.Math.Clamp,
        Uu = Phaser.Math.DegToRad(270),
        Hu = function() { w(c, Yu(Qt)); var u = T(c);

            function c(t, e, i, n, s, r, o) { var a;
                X(this, c), Gu(e) && (e = Wu(o = e, "x", 0), i = Wu(o, "y", 0), n = Wu(o, "radius", 1), s = Wu(o, "barColor", void 0), r = Wu(o, "value", 0)); var h = 2 * n;
                (a = u.call(this, t, e, i, h, h)).type = "rexCircularProgressCanvas", a.bootProgressBase(o), a.setRadius(n), a.setTrackColor(Wu(o, "trackColor", void 0)), a.setBarColor(s), a.setCenterColor(Wu(o, "centerColor", void 0)), a.setThickness(Wu(o, "thickness", .2)), a.setStartAngle(Wu(o, "startAngle", Uu)), a.setAnticlockwise(Wu(o, "anticlockwise", !1)), a.setTextColor(Wu(o, "textColor", void 0)), a.setTextStrokeColor(Wu(o, "textStrokeColor", void 0), Wu(o, "textStrokeThickness", void 0)); var l = Wu(o, "textFont", void 0); return l ? a.setTextFont(l) : a.setTextFont(Wu(o, "textSize", "16px"), Wu(o, "textFamily", "Courier"), Wu(o, "textStyle", "")), a.setTextFormatCallback(Wu(o, "textFormatCallback", void 0), Wu(o, "textFormatCallbackScope", void 0)), a.setValue(r), a } return k(c, [{ key: "resize", value: function(t, e) { return (t = Math.floor(Math.min(t, e))) === this.width || (O(C(c.prototype), "resize", this).call(this, t, t), this.setRadius(t / 2)), this } }, { key: "radius", get: function() { return this._radius }, set: function(t) { this.dirty = this.dirty || this._radius != t; var e = 2 * (this._radius = t);
                    this.resize(e, e) } }, { key: "setRadius", value: function(t) { return this.radius = t, this } }, { key: "trackColor", get: function() { return this._trackColor }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._trackColor != t, this._trackColor = t } }, { key: "setTrackColor", value: function(t) { return this.trackColor = t, this } }, { key: "barColor", get: function() { return this._barColor }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._barColor != t, this._barColor = t } }, { key: "setBarColor", value: function(t) { return this.barColor = t, this } }, { key: "startAngle", get: function() { return this._startAngle }, set: function(t) { this.dirty = this.dirty || this._startAngle != t, this._startAngle = t } }, { key: "setStartAngle", value: function(t) { return this.startAngle = t, this } }, { key: "anticlockwise", get: function() { return this._anticlockwise }, set: function(t) { this.dirty = this.dirty || this._anticlockwise != t, this._anticlockwise = t } }, { key: "setAnticlockwise", value: function(t) { return void 0 === t && (t = !0), this.anticlockwise = t, this } }, { key: "thickness", get: function() { return this._thickness }, set: function(t) { t = Vu(t, 0, 1), this.dirty = this.dirty || this._thickness != t, this._thickness = t } }, { key: "setThickness", value: function(t) { return this.thickness = t, this } }, { key: "centerColor", get: function() { return this._centerColor }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._centerColor != t, this._centerColor = t } }, { key: "centerColor2", get: function() { return this._centerColor2 }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._centerColor2 != t, this._centerColor2 = t } }, { key: "setCenterColor", value: function(t, e) { return this.centerColor = t, this.centerColor2 = e, this } }, { key: "textColor", get: function() { return this._textColor }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._textColor != t, this._textColor = t } }, { key: "setTextColor", value: function(t) { return this.textColor = t, this } }, { key: "textStrokeColor", get: function() { return this._textStrokeColor }, set: function(t) { t = ee(t, this.canvas, this.context), this.dirty = this.dirty || this._textStrokeColor != t, this._textStrokeColor = t } }, { key: "textStrokeThickness", get: function() { return this._textStrokeThickness }, set: function(t) { this.dirty = this.dirty || this._textStrokeThickness != t, this._textStrokeThickness = t } }, { key: "setTextStrokeColor", value: function(t, e) { return void 0 === e && (e = 2), this.textStrokeColor = t, this.textStrokeThickness = e, this } }, { key: "textFont", get: function() { return this._textFont }, set: function(t) { this.dirty = this.dirty || this._textFont != t, this._textFont = t } }, { key: "setTextFont", value: function(t, e, i) { var n; return n = void 0 === e ? t : i + " " + t + " " + e, this.textFont = n, this } }, { key: "setTextFormatCallback", value: function(t, e) { return this.textFormatCallback = t, this.textFormatCallbackScope = e, this } }, { key: "updateTexture", value: function() { return this.clear(),
                        function() { var t, e, i, n, s, r, o, a, h, l, u, c = this.radius,
                                d = this.thickness * this.radius,
                                f = this.radius - d / 2,
                                p = this.radius - d,
                                v = (this.canvas, this.context); if (this.trackColor && 0 < d && (v.save(), Xu(0, v, c, c, f, f, void 0, this.trackColor, d), v.restore()), this.barColor && 0 < f) { var g, y, m; if (1 === this.value) g = !1, y = 0, m = 2 * Math.PI;
                                else g = this.anticlockwise, y = this.startAngle, m = 2 * Math.PI * (g ? 1 - this.value : this.value) + y;
                                v.save(), Xu(0, v, c, c, f, f, void 0, this.barColor, d, y, m, g), v.restore() }
                            this.centerColor && 0 < p && (this.centerColor2 ? ((t = this.context.createRadialGradient(c, c, 0, c, c, p)).addColorStop(0, this.centerColor), t.addColorStop(1, this.centerColor2)) : t = this.centerColor, v.save(), Xu(0, v, c, c, p, p, t), v.restore());
                            this.textFormatCallback && (this.textColor || this.textStrokeColor) && (v.save(), e = v, n = i = c, s = this.getFormatText(), r = this.textFont, o = this.textColor, a = this.textStrokeColor, void 0 === (h = this.textStrokeThickness) && null != a && (h = 2), void 0 === (l = "center") && (l = "start"), void 0 === (u = "middle") && (u = "alphabetic"), e.font = r, e.textAlign = l, e.textBaseline = u, e.fillStyle = o, e.strokeStyle = a, e.lineWidth = h, e.lineCap = "round", e.lineJoin = "round", null != a && "none" !== a && 0 < h && e.strokeText(s, i, n), null != o && "none" !== o && e.fillText(s, i, n), v.restore()) }.call(this), O(C(c.prototype), "updateTexture", this).call(this), this } }, { key: "getFormatText", value: function(t) { return void 0 === t && (t = this.value), this.textFormatCallbackScope ? this.textFormatCallback(t) : this.textFormatCallback.call(this.textFormatCallbackScope, t) } }]), c }();
    p.register("circularProgressCanvas", function(t, e, i, n, s, r) { var o = new Hu(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), j(window, "RexPlugins.UI.CircularProgressCanvas", Hu); var Nu = Phaser.GameObjects.GetCalcMatrix,
        Ju = Phaser.Renderer.Canvas.SetTransform,
        Ku = { renderWebGL: function(t, e, i, n) { e.updateData(), i.addToRenderList(e); var s = t.pipelines.set(e.pipeline),
                    r = Nu(e, i, n),
                    o = s.calcMatrix.copyFrom(r.calc),
                    a = e._displayOriginX,
                    h = e._displayOriginY,
                    l = i.alpha * e.alpha;
                t.pipelines.preBatch(e); for (var u = e.geom, c = 0, d = u.length; c < d; c++) u[c].webglRender(s, o, l, a, h);
                t.pipelines.postBatch(e) }, renderCanvas: function(t, e, i, n) { e.updateData(), i.addToRenderList(e); var s = t.currentContext; if (Ju(t, s, e, i, n)) { for (var r = e._displayOriginX, o = e._displayOriginY, a = e.geom, h = 0, l = a.length; h < l; h++) a[h].canvasRender(s, r, o);
                    s.restore() } } },
        Zu = Phaser.GameObjects.Shape,
        qu = Phaser.Utils.Array.Remove,
        $u = function() { w(a, Zu); var o = T(a);

            function a(t, e, i, n, s) { var r; return X(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = n), (r = o.call(this, t, "rexShapes", []))._width = -1, r._height = -1, r.dirty = !0, r.isSizeChanged = !0, r.shapes = {}, r.setPosition(e, i), r.setSize(n, s), r.updateDisplayOrigin(), r } return k(a, [{ key: "width", get: function() { return this._width }, set: function(t) { this.setSize(t, this._height) } }, { key: "height", get: function() { return this._height }, set: function(t) { this.setSize(this._width, t) } }, { key: "setDirty", value: function(t) { return void 0 === t && (t = !0), this.dirty = t, this } }, { key: "setSize", value: function(t, e) { this.isSizeChanged = this.isSizeChanged || this._width !== t || this._height !== e, this.dirty = this.dirty || this.isSizeChanged, this._width = t, this._height = e, this.updateDisplayOrigin(); var i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this } }, { key: "resize", value: function(t, e) { return this.setSize(t, e), this } }, { key: "fillColor", get: function() { return this._fillColor }, set: function(t) { this.setFillStyle(t, this._fillAlpha) } }, { key: "fillAlpha", get: function() { return this._fillAlpha }, set: function(t) { this.setFillStyle(this._fillColor, t) } }, { key: "setFillStyle", value: function(t, e) { return void 0 === e && (e = 1), this.dirty = this.dirty || this.fillColor !== t || this.fillAlpha !== e, this._fillColor = t, this._fillAlpha = e, this } }, { key: "lineWidth", get: function() { return this._lineWidth }, set: function(t) { this.setStrokeStyle(t, this._strokeColor, this._strokeAlpha) } }, { key: "strokeColor", get: function() { return this._strokeColor }, set: function(t) { this.setStrokeStyle(this._lineWidth, t, this._strokeAlpha) } }, { key: "strokeAlpha", get: function() { return this._strokeAlpha }, set: function(t) { this.setStrokeStyle(this._lineWidth, this._strokeColor, t) } }, { key: "setStrokeStyle", value: function(t, e, i) { return void 0 === i && (i = 1), this.dirty = this.dirty || this.lineWidth !== t || this.strokeColor !== e || this.strokeAlpha !== i, this._lineWidth = t, this._strokeColor = e, this._strokeAlpha = i, this } }, { key: "updateShapes", value: function() {} }, { key: "updateData", value: function() { if (!this.dirty) return this;
                    this.updateShapes(); for (var t = this.geom, e = 0, i = t.length; e < i; e++) { var n = t[e];
                        n.dirty && n.updateData() } return this.isSizeChanged = !1, this.dirty = !1, this } }, { key: "clear", value: function() { return this.geom.length = 0, at(this.shapes), this } }, { key: "getShape", value: function(t) { return this.shapes[t] } }, { key: "getShapes", value: function() { return this.geom } }, { key: "addShape", value: function(t) { this.geom.push(t); var e = t.name; return e && (this.shapes[e] = t), this.dirty = !0, this } }, { key: "deleteShape", value: function(t) { var e = this.getShape(t); return e && (delete this.shapes[t], qu(this.geom, e)), this } }]), a }();
    Object.assign($u.prototype, Ku); var Qu = { fillStyle: function(t, e) { return null == t ? this.isFilled = !1 : (void 0 === e && (e = 1), this.isFilled = !0, this.fillColor = t, this.fillAlpha = e), this }, lineStyle: function(t, e, i) { return null == t || null == e ? this.isStroked = !1 : (void 0 === i && (i = 1), this.isStroked = !0, this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i), this } },
        tc = function() {
            function t() { X(this, t), this.name = void 0, this.dirty = !0, this.data = void 0, this.isFilled = !1, this.fillColor = void 0, this.fillAlpha = 1, this.isStroked = !1, this.lineWidth = 1, this.strokeColor = void 0, this.strokeAlpha = 1 } return k(t, [{ key: "setName", value: function(t) { return this.name = t, this } }, { key: "reset", value: function() { return this.fillStyle().lineStyle(), this } }, { key: "webglRender", value: function() {} }, { key: "canvasRender", value: function() {} }, { key: "updateData", value: function() { this.dirty = !1 } }]), t }();
    Object.assign(tc.prototype, Qu, ht);

    function ec(t, e, i, n, s, r) { for (var o = r.length, a = r[o - 2], h = r[o - 1], l = 1, u = s - 1; l <= u; l++) { var c = l / u;
            r.push(uc(c, a, t, i), uc(c, h, e, n)) } return r } var ic = Phaser.Geom.Polygon.Earcut,
        nc = function() { w(i, tc); var e = T(i);

            function i() { var t; return X(this, i), (t = e.call(this)).pathData = [], t.pathIndexes = [], t.closePath = !1, t } return k(i, [{ key: "updateData", value: function() { return this.pathIndexes = ic(this.pathData), O(C(i.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function(t, e, i, n, s) { this.isFilled && Pt(t, e, this, i, n, s), this.isStroked && Tt(t, this, i, n, s) } }, { key: "canvasRender", value: function(t, e, i) { var n = this.pathData,
                        s = n.length - 1,
                        r = n[0] - e,
                        o = n[1] - i;
                    t.beginPath(), t.moveTo(r, o), this.closePath || (s -= 2); for (var a = 2; a < s; a += 2) { var h = n[a] - e,
                            l = n[a + 1] - i;
                        t.lineTo(h, l) }
                    this.closePath && t.closePath(), this.isFilled && (Ot(t, this), t.fill()), this.isStroked && (Mt(t, this), t.stroke()) } }]), i }(),
        sc = Phaser.Math.DegToRad,
        rc = function() { w(u, nc); var l = T(u);

            function u(t, e, i, n, s, r, o, a) { var h; return X(this, u), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), void 0 === a && (a = !1), (h = l.call(this)).setCenterPosition(t, e), h.setRadius(i, n), h.setAngle(s, r, o), h.setPie(a), h.setIterations(32), h } return k(u, [{ key: "x", get: function() { return this._x }, set: function(t) { this.dirty = this.dirty || this._x !== t, this._x = t } }, { key: "y", get: function() { return this._y }, set: function(t) { this.dirty = this.dirty || this._y !== t, this._y = t } }, { key: "setCenterPosition", value: function(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this } }, { key: "radiusX", get: function() { return this._radiusX }, set: function(t) { this.dirty = this.dirty || this._radiusX !== t, this._radiusX = t } }, { key: "radiusY", get: function() { return this._radiusY }, set: function(t) { this.dirty = this.dirty || this._radiusY !== t, this._radiusY = t } }, { key: "setRadius", value: function(t, e) { return void 0 === e && (e = t), this.radiusX = t, this.radiusY = e, this } }, { key: "startAngle", get: function() { return this._startAngle }, set: function(t) { this.dirty = this.dirty || this._startAngle !== t, this._startAngle = t } }, { key: "endAngle", get: function() { return this._endAngle }, set: function(t) { this.dirty = this.dirty || this._endAngle !== t, this._endAngle = t } }, { key: "anticlockwise", get: function() { return this._anticlockwise }, set: function(t) { this.dirty = this.dirty || this._anticlockwise !== t, this._anticlockwise = t } }, { key: "setAngle", value: function(t, e, i) { return void 0 === i && (i = !1), this.startAngle = t, this.endAngle = e, this.anticlockwise = i, this } }, { key: "pie", get: function() { return this._pie }, set: function(t) { this.dirty = this.dirty || this._pie !== t, this._pie = t } }, { key: "setPie", value: function(t) { return void 0 === t && (t = !0), this.pie = t, this } }, { key: "iterations", get: function() { return this._iterations }, set: function(t) { this.dirty = this.dirty || this._iterations !== t, this._iterations = t } }, { key: "setIterations", value: function(t) { return this.iterations = t, this } }, { key: "updateData", value: function() { return this.pathData.length = 0, this.pie && this.pathData.push(this.x, this.y), St(this.x, this.y, this.radiusX, this.radiusY, this.startAngle, this.endAngle, this.anticlockwise, this.iterations, this.pathData), this.pie && this.pathData.push(this.x, this.y), this.pathData.push(this.pathData[0], this.pathData[1]), O(C(u.prototype), "updateData", this).call(this), this } }, { key: "canvasRender", value: function(t, e, i) { t.beginPath(); var n = this.x - e,
                        s = this.y - i,
                        r = sc(this.startAngle),
                        o = sc(this.endAngle);
                    this.pie && (t.moveTo(n, s), t.lineTo(n + Math.cos(r) * this.radiusX, s + Math.sin(r) * this.radiusY)), t.ellipse(n, s, this.radiusX, this.radiusY, 0, r, o, this.anticlockwise), this.pie && t.lineTo(n, s), this.isFilled && (Ot(t, this), t.fill()), this.isStroked && (Mt(t, this), t.stroke()) } }]), u }(),
        oc = function() { w(s, rc); var n = T(s);

            function s(t, e, i) { return X(this, s), n.call(this, t, e, i, i, 0, 360) } return k(s) }(),
        ac = function() { w(n, nc); var i = T(n);

            function n(t) { var e; return X(this, n), (e = i.call(this)).setCurve(t), e.setIterations(32), e } return k(n, [{ key: "curve", get: function() { return this._curve }, set: function(t) { this.dirty = this.dirty || this._curve !== t, this._curve = t } }, { key: "setCurve", value: function(t) { return this.curve = t, this } }, { key: "iterations", get: function() { return this._iterations }, set: function(t) { this.dirty = this.dirty || this._iterations !== t, this._iterations = t } }, { key: "setIterations", value: function(t) { return this.iterations = t, this } }, { key: "updateData", value: function() { this.pathData.length = 0; for (var t = this.curve.getPoints(this.iterations), e = 0, i = t.length; e < i; e++) this.pathData.push(t[e].x, t[e].y); return this.pathData.push(t[0].x, t[0].y), O(C(n.prototype), "updateData", this).call(this), this } }]), n }(),
        hc = function() { w(r, rc); var s = T(r);

            function r(t, e, i, n) { return X(this, r), s.call(this, t, e, i, n, 0, 360) } return k(r) }(),
        lc = function() { w(o, nc); var r = T(o);

            function o(t, e, i, n) { var s; return X(this, o), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), (s = r.call(this)).setP0(t, e), s.setP1(i, n), s } return k(o, [{ key: "x0", get: function() { return this._x0 }, set: function(t) { this.dirty = this.dirty || this._x0 !== t, this._x0 = t } }, { key: "y0", get: function() { return this._y0 }, set: function(t) { this.dirty = this.dirty || this._y0 !== t, this._y0 = t } }, { key: "setP0", value: function(t, e) { return this.x0 = t, this.y0 = e, this } }, { key: "x1", get: function() { return this._x1 }, set: function(t) { this.dirty = this.dirty || this._x1 !== t, this._x1 = t } }, { key: "y1", get: function() { return this._y1 }, set: function(t) { this.dirty = this.dirty || this._y1 !== t, this._y1 = t } }, { key: "setP1", value: function(t, e) { return this.x1 = t, this.y1 = e, this } }, { key: "updateData", value: function() { return this.pathData.length = 0, this.pathData.push(this.x0, this.y0), this.pathData.push(this.x1, this.y1), this.pathData.push(this.x0, this.y0), O(C(o.prototype), "updateData", this).call(this), this } }]), o }(),
        uc = Phaser.Math.Interpolation.QuadraticBezier,
        cc = Phaser.Math.RotateAround,
        dc = Phaser.Geom.Polygon,
        fc = Phaser.Math.DegToRad,
        pc = function() {
            function e(t) { X(this, e), void 0 === t && (t = []), this.pathData = t, this.closePath = !1, this.setIterations(32), this.lastPointX = void 0, this.lastPointY = void 0 } return k(e, [{ key: "setIterations", value: function(t) { return this.iterations = t, this } }, { key: "start", value: function() { return this.startAt(), this } }, { key: "startAt", value: function(t, e) { var i, n, s; return i = t, n = e, (s = this.pathData).length = 0, null != i && s.push(i, n), this.lastPointX = t, this.lastPointY = e, this } }, { key: "lineTo", value: function(t, e, i) { return void 0 === i && (i = !1), i && (t += this.lastPointX, e += this.lastPointY), wt(t, e, this.pathData), this.lastPointX = t, this.lastPointY = e, this } }, { key: "verticalLineTo", value: function(t, e) { return this.lineTo(t, this.lastPointY, e), this } }, { key: "horizontalLineTo", value: function(t, e) { return this.lineTo(this.lastPointX, t, e), this } }, { key: "ellipticalArc", value: function(t, e, i, n, s, r, o) { void 0 === o && (o = !1), St(t, e, i, n, s, r, o, this.iterations, this.pathData); var a = this.pathData.length; return this.lastPointX = this.pathData[a - 2], this.lastPointY = this.pathData[a - 1], this } }, { key: "arc", value: function(t, e, i, n, s, r) { return this.ellipticalArc(t, e, i, i, n, s, r), this } }, { key: "quadraticBezierTo", value: function(t, e, i, n) { return ec(t, e, i, n, this.iterations, this.pathData), this.lastPointX = i, this.lastPointY = n, this.lastCX = t, this.lastCY = e, this } }, { key: "smoothQuadraticBezierTo", value: function(t, e) { var i = 2 * this.lastPointX - this.lastCX,
                        n = 2 * this.lastPointY - this.lastCY; return this.quadraticBezierTo(i, n, t, e), this } }, { key: "cubicBezierCurveTo", value: function(t, e, i, n, s, r) { return ec(t, e, i, n, s, r, this.iterations, this.pathData), this.lastPointX = s, this.lastPointY = r, this.lastCX = i, this.lastCY = n, this } }, { key: "smoothCubicBezierCurveTo", value: function(t, e, i, n) { var s = 2 * this.lastPointX - this.lastCX,
                        r = 2 * this.lastPointY - this.lastCY; return this.cubicBezierCurveTo(s, r, t, e, i, n), this } }, { key: "close", value: function() { return this.closePath = !0, this } }, { key: "end", value: function() { return this.pathData.push(this.lastPointX, this.lastPointY), this } }, { key: "rotateAround", value: function(t, e, i) { if (0 === this.pathData.length) return this;! function(t, e, i, n) { for (var s = { x: 0, y: 0 }, r = 0, o = n.length - 1; r < o; r += 2) s.x = n[r], s.y = n[r + 1], cc(s, t, e, i), n[r] = s.x, n[r + 1] = s.y }(t, e, i = fc(i), this.pathData); var n = this.pathData.length; if (this.lastPointX = this.pathData[n - 2], this.lastPointY = this.pathData[n - 1], void 0 !== this.lastCX) { var s = { x: this.lastCX, y: this.lastCY };
                        PointRotateAround(s, t, e, i), this.lastCX = s.x, this.lastCY = s.y } return this } }, { key: "offset", value: function(t, e) { return function(t, e, i) { for (var n = 0, s = i.length - 1; n < s; n += 2) i[n] += t, i[n + 1] += e }(t, e, this.pathData), this } }, { key: "toPoints", value: function() { return function(t, e) { void 0 === e && (e = []); for (var i = 0, n = t.length - 1; i < n; i += 2) e.push({ x: t[i], y: t[i + 1] }); return e }(this.pathData) } }, { key: "toPolygon", value: function(t) { return e = this.pathData, void 0 === (i = t) && (i = new dc()), i.setTo(e), i; var e, i } }, { key: "draw", value: function(t, e, i) { var n = this.toPoints(); return e && t.fillPoints(n, this.closePath, this.closePath), i && t.strokePoints(n, this.closePath, this.closePath), this } }]), e }(),
        vc = function() { w(i, nc); var e = T(i);

            function i() { var t; return X(this, i), (t = e.call(this)).builder = new pc(t.pathData), t } return k(i, [{ key: "iterations", get: function() { return this.builder.iterations }, set: function(t) { this.dirty = this.dirty || this.builder.iterations !== t, this.builder.setIterations(t) } }, { key: "setIterations", value: function(t) { return this.iterations = t, this } }, { key: "lastPointX", get: function() { return this.builder.lastPointX } }, { key: "lastPointY", get: function() { return this.builder.lastPointY } }, { key: "start", value: function() { return this.builder.start(), this.dirty = !0, this } }, { key: "startAt", value: function(t, e) { return this.builder.startAt(t, e), this.dirty = !0, this } }, { key: "lineTo", value: function(t, e, i) { return this.builder.lineTo(t, e, i), this.dirty = !0, this } }, { key: "verticalLineTo", value: function(t, e) { return this.builder.verticalLineTo(t, e), this.dirty = !0, this } }, { key: "horizontalLineTo", value: function(t, e) { return this.builder.horizontalLineTo(t, e), this.dirty = !0, this } }, { key: "ellipticalArc", value: function(t, e, i, n, s, r, o) { return this.builder.ellipticalArc(t, e, i, n, s, r, o), this.dirty = !0, this } }, { key: "arc", value: function(t, e, i, n, s, r) { return this.builder.arc(t, e, i, n, s, r), this.dirty = !0, this } }, { key: "quadraticBezierTo", value: function(t, e, i, n) { return this.builder.quadraticBezierTo(t, e, i, n), this.dirty = !0, this } }, { key: "smoothQuadraticBezierTo", value: function(t, e) { return this.builder.smoothQuadraticBezierTo(t, e), this.dirty = !0, this } }, { key: "cubicBezierCurveTo", value: function(t, e, i, n, s, r) { return this.builder.cubicBezierCurveTo(t, e, i, n, s, r), this.dirty = !0, this } }, { key: "smoothCubicBezierCurveTo", value: function(t, e, i, n) { return this.builder.smoothCubicBezierCurveTo(t, e, i, n), this.dirty = !0, this } }, { key: "close", value: function() { return this.builder.close(), this.closePath = this.builder.closePath, this.dirty = !0, this } }, { key: "end", value: function() { return this.builder.end(), this.dirty = !0, this } }, { key: "rotateAround", value: function(t, e, i) { return this.builder.rotateAround(t, e, i), this.dirty = !0, this } }, { key: "offset", value: function(t, e) { return this.builder.offset(t, e), this.dirty = !0, this } }, { key: "toPolygon", value: function(t) { return this.builder.toPolygon(t) } }]), i }(),
        gc = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha,
        yc = function() { w(o, tc); var r = T(o);

            function o(t, e, i, n) { var s; return X(this, o), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = i), (s = r.call(this)).pathData = [], s.closePath = !0, s.setTopLeftPosition(t, e), s.setSize(i, n), s } return k(o, [{ key: "x", get: function() { return this._x }, set: function(t) { this.dirty = this.dirty || this._x !== t, this._x = t } }, { key: "y", get: function() { return this._y }, set: function(t) { this.dirty = this.dirty || this._y !== t, this._y = t } }, { key: "setTopLeftPosition", value: function(t, e) { return this.x = t, this.y = e, this } }, { key: "width", get: function() { return this._width }, set: function(t) { this.dirty = this.dirty || this._width !== t, this._width = t } }, { key: "height", get: function() { return this._height }, set: function(t) { this.dirty = this.dirty || this._height !== t, this._height = t } }, { key: "setSize", value: function(t, e) { return this.width = t, this.height = e, this } }, { key: "updateData", value: function() { this.pathData.length = 0; var t = this.x,
                        e = t + this.width,
                        i = this.y,
                        n = i + this.height; return this.pathData.push(t, i), this.pathData.push(e, i), this.pathData.push(e, n), this.pathData.push(t, n), this.pathData.push(t, i), O(C(o.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function(t, e, i, n, s) { if (this.isFilled) { var r = t.fillTint,
                            o = gc(this.fillColor, this.fillAlpha * i);
                        r.TL = o, r.TR = o, r.BL = o, r.BR = o, t.batchFillRect(-n + this.x, -s + this.y, this.width, this.height) }
                    this.isStroked && Tt(t, this, i, n, s) } }, { key: "canvasRender", value: function(t, e, i) { this.isFilled && (Ot(t, this), t.fillRect(-e, -i, this.width, this.height)), this.isStroked && (Mt(t, this), t.beginPath(), t.rect(-e, -i, this.width, this.height), t.stroke()) } }]), o }(),
        mc = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha,
        kc = function() { w(h, tc); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), (o = a.call(this)).pathData = [], o.closePath = !0, o.setP0(t, e), o.setP1(i, n), o.setP2(s, r), o } return k(h, [{ key: "x0", get: function() { return this._x0 }, set: function(t) { this.dirty = this.dirty || this._x0 !== t, this._x0 = t } }, { key: "y0", get: function() { return this._y0 }, set: function(t) { this.dirty = this.dirty || this._y0 !== t, this._y0 = t } }, { key: "setP0", value: function(t, e) { return this.x0 = t, this.y0 = e, this } }, { key: "x1", get: function() { return this._x1 }, set: function(t) { this.dirty = this.dirty || this._x1 !== t, this._x1 = t } }, { key: "y1", get: function() { return this._y1 }, set: function(t) { this.dirty = this.dirty || this._y1 !== t, this._y1 = t } }, { key: "setP1", value: function(t, e) { return this.x1 = t, this.y1 = e, this } }, { key: "x2", get: function() { return this._x2 }, set: function(t) { this.dirty = this.dirty || this._x2 !== t, this._x2 = t } }, { key: "y2", get: function() { return this._y2 }, set: function(t) { this.dirty = this.dirty || this._y2 !== t, this._y2 = t } }, { key: "setP2", value: function(t, e) { return this.dirty = this.dirty || this.x2 !== t || this.y2 !== e, this.x2 = t, this.y2 = e, this } }, { key: "updateData", value: function() { return this.pathData.length = 0, this.pathData.push(this.x0, this.y0), this.pathData.push(this.x1, this.y1), this.pathData.push(this.x2, this.y2), this.pathData.push(this.x0, this.y0), O(C(h.prototype), "updateData", this).call(this), this } }, { key: "webglRender", value: function(t, e, i, n, s) { if (this.isFilled) { var r = mc(this.fillColor, this.fillAlpha * i),
                            o = this.x0 - n,
                            a = this.y0 - s,
                            h = this.x1 - n,
                            l = this.y1 - s,
                            u = this.x2 - n,
                            c = this.y2 - s,
                            d = e.getX(o, a),
                            f = e.getY(o, a),
                            p = e.getX(h, l),
                            v = e.getY(h, l),
                            g = e.getX(u, c),
                            y = e.getY(u, c);
                        t.batchTri(d, f, p, v, g, y, r, r, r) }
                    this.isStroked && Tt(t, this, i, n, s) } }, { key: "canvasRender", value: function(t, e, i) { var n = this.x1 - e,
                        s = this.y1 - i,
                        r = this.x2 - e,
                        o = this.y2 - i,
                        a = this.x3 - e,
                        h = this.y3 - i;
                    t.beginPath(), t.moveTo(n, s), t.lineTo(r, o), t.lineTo(a, h), t.closePath(), this.isFilled && (Ot(t, this), t.fill()), this.isStroked && (Mt(t, this), t.stroke()) } }]), h }(),
        bc = Phaser.Math.RadToDeg,
        xc = Phaser.Utils.Objects.GetValue,
        Cc = Phaser.Utils.Objects.IsPlainObject,
        wc = Phaser.Math.Clamp,
        Sc = Phaser.Math.DegToRad(270),
        Pc = function() { w(u, Yu($u)); var l = T(u);

            function u(t, e, i, n, s, r, o) { var a;
                X(this, u), Cc(e) && (e = xc(o = e, "x", 0), i = xc(o, "y", 0), n = xc(o, "radius", 1), s = xc(o, "barColor", void 0), r = xc(o, "value", 0)); var h = 2 * n; return (a = l.call(this, t, e, i, h, h)).type = "rexCircularProgress", a.bootProgressBase(o), a.addShape((new oc()).setName("track")).addShape((new rc()).setName("bar")).addShape((new oc()).setName("center")), a.setRadius(n), a.setTrackColor(xc(o, "trackColor", void 0)), a.setBarColor(s), a.setCenterColor(xc(o, "centerColor", void 0)), a.setThickness(xc(o, "thickness", .2)), a.setStartAngle(xc(o, "startAngle", Sc)), a.setAnticlockwise(xc(o, "anticlockwise", !1)), a.setValue(r), a } return k(u, [{ key: "resize", value: function(t, e) { return (t = Math.floor(Math.min(t, e))) === this.width || (O(C(u.prototype), "resize", this).call(this, t, t), this.setRadius(t / 2)), this } }, { key: "radius", get: function() { return this._radius }, set: function(t) { this.dirty = this.dirty || this._radius != t; var e = 2 * (this._radius = t);
                    this.resize(e, e) } }, { key: "setRadius", value: function(t) { return this.radius = t, this } }, { key: "trackColor", get: function() { return this._trackColor }, set: function(t) { this.dirty = this.dirty || this._trackColor != t, this._trackColor = t } }, { key: "setTrackColor", value: function(t) { return this.trackColor = t, this } }, { key: "barColor", get: function() { return this._barColor }, set: function(t) { this.dirty = this.dirty || this._barColor != t, this._barColor = t } }, { key: "setBarColor", value: function(t) { return this.barColor = t, this } }, { key: "startAngle", get: function() { return this._startAngle }, set: function(t) { this.dirty = this.dirty || this._startAngle != t, this._startAngle = t } }, { key: "setStartAngle", value: function(t) { return this.startAngle = t, this } }, { key: "anticlockwise", get: function() { return this._anticlockwise }, set: function(t) { this.dirty = this.dirty || this._anticlockwise != t, this._anticlockwise = t } }, { key: "setAnticlockwise", value: function(t) { return void 0 === t && (t = !0), this.anticlockwise = t, this } }, { key: "thickness", get: function() { return this._thickness }, set: function(t) { t = wc(t, 0, 1), this.dirty = this.dirty || this._thickness != t, this._thickness = t } }, { key: "setThickness", value: function(t) { return this.thickness = t, this } }, { key: "centerColor", get: function() { return this._centerColor }, set: function(t) { this.dirty = this.dirty || this._centerColor != t, this._centerColor = t } }, { key: "setCenterColor", value: function(t) { return this.centerColor = t, this } }]), u }(),
        Tc = { updateShapes: function() { var t = this.radius,
                    e = this.thickness * this.radius,
                    i = this.radius - e / 2,
                    n = this.radius - e,
                    s = this.getShape("track");
                null != this.trackColor && 0 < e ? s.setCenterPosition(t, t).setRadius(i).lineStyle(e, this.trackColor) : s.reset(); var r = this.getShape("bar"); if (null != this.barColor && 0 < i) { var o, a, h; if (1 === this.value) o = !1, a = 0, h = 361;
                    else o = this.anticlockwise, a = bc(this.startAngle), h = 360 * (o ? 1 - this.value : this.value) + a;
                    r.setCenterPosition(t, t).setRadius(i).setAngle(a, h, o).lineStyle(e, this.barColor) } else r.reset(); var l = this.getShape("center");
                this.centerColor && 0 < n ? l.setCenterPosition(t, t).setRadius(n).fillStyle(this.centerColor) : l.reset() } };
    Object.assign(Pc.prototype, Tc), p.register("circularProgress", function(t, e, i, n, s, r) { var o = new Pc(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), j(window, "RexPlugins.UI.CircularProgress", Pc); var Oc = function(t, e, i, n, s, r) { return 0 <= r ? t.startAt(e + r, i).lineTo(n + r, i).lineTo(n, s).lineTo(e, s).lineTo(e + r, i) : t.startAt(e, i).lineTo(n, i).lineTo(n - r, s).lineTo(e - r, s).lineTo(e, i), t },
        Mc = Phaser.Utils.Objects.GetValue,
        Ec = Phaser.Utils.Objects.IsPlainObject,
        _c = function() { w(u, Yu($u)); var l = T(u);

            function u(t, e, i, n, s, r, o, a) { var h; return X(this, u), Ec(e) ? (e = Mc(a = e, "x", 0), i = Mc(a, "y", 0), n = Mc(a, "width", 2), s = Mc(a, "height", 2), r = Mc(a, "barColor", void 0), o = Mc(a, "value", 0)) : Ec(n) ? (n = Mc(a = n, "width", 2), s = Mc(a, "height", 2), r = Mc(a, "barColor", void 0), o = Mc(a, "value", 0)) : Ec(r) && (r = Mc(a = r, "barColor", void 0), o = Mc(a, "value", 0)), (h = l.call(this, t, e, i, n, s, a)).type = "rexLineProgress", h.bootProgressBase(a), h.addShape((new vc()).setName("trackFill")).addShape((new vc()).setName("bar")).addShape((new vc()).setName("trackStroke")), h.setTrackColor(Mc(a, "trackColor", void 0)), h.setBarColor(r), h.setTrackStroke(Mc(a, "trackStrokeThickness", 2), Mc(a, "trackStrokeColor", void 0)), h.setSkewX(Mc(a, "skewX", 0)), h.setRTL(Mc(a, "rtl", !1)), h.setValue(o), h } return k(u, [{ key: "trackColor", get: function() { return this._trackColor }, set: function(t) { this.dirty = this.dirty || this._trackColor != t, this._trackColor = t } }, { key: "setTrackColor", value: function(t) { return this.trackColor = t, this } }, { key: "trackStrokeColor", get: function() { return this._trackStrokeColor }, set: function(t) { this.dirty = this.dirty || this._trackStrokeColor != t, this._trackStrokeColor = t } }, { key: "trackStrokeThickness", get: function() { return this._trackStrokeThickness }, set: function(t) { this.dirty = this.dirty || this._trackStrokeThickness != t, this._trackStrokeThickness = t } }, { key: "setTrackStroke", value: function(t, e) { return this.trackStrokeThickness = t, this.trackStrokeColor = e, this } }, { key: "barColor", get: function() { return this._barColor }, set: function(t) { this.dirty = this.dirty || this._barColor != t, this._barColor = t } }, { key: "setBarColor", value: function(t) { return this.barColor = t, this } }, { key: "skewX", get: function() { return this._skewX }, set: function(t) { this.dirty = this.dirty || this._skewX != t, this._skewX = t } }, { key: "setSkewX", value: function(t) { return this.skewX = t, this } }, { key: "rtl", get: function() { return this._rtl }, set: function(t) { t = !!t, this.dirty = this.dirty || this._rtl != t, this._rtl = t } }, { key: "setRTL", value: function(t) { return void 0 === t && (t = !0), this.rtl = t, this } }]), u }(),
        Rc = { updateShapes: function() { var t = this.skewX,
                    e = this.width - Math.abs(t),
                    i = this.height,
                    n = this.getShape("trackFill");
                n.fillStyle(this.trackColor), n.isFilled && Oc(n, 0, 0, e, i, t).close(); var s, r, o = this.getShape("bar");
                o.fillStyle(this.barColor), o.isFilled && (r = this.rtl ? (s = e * (1 - this.value), e) : (s = 0, e * this.value), Oc(o, s, 0, r, i, this.skewX).close()); var a = this.getShape("trackStroke");
                a.lineStyle(this.trackStrokeThickness, this.trackStrokeColor), a.isStroked && Oc(a, 0, 0, e, i, t).end() } };
    Object.assign(_c.prototype, Rc), p.register("lineProgress", function(t, e, i, n, s, r, o) { var a = new _c(this.scene, t, e, i, n, s, r, o); return this.scene.add.existing(a), a }), j(window, "RexPlugins.UI.LineProgress", _c);

    function Bc(t) { return t.hasOwnProperty("rexSizer") || (t.rexSizer = {}), t.rexSizer } var Ic = Phaser.Display.Align,
        Lc = { center: Ic.CENTER, left: Ic.LEFT_CENTER, right: Ic.RIGHT_CENTER, top: Ic.TOP_CENTER, bottom: Ic.BOTTOM_CENTER, "left-top": Ic.TOP_LEFT, "left-center": Ic.LEFT_CENTER, "left-bottom": Ic.BOTTOM_LEFT, "center-top": Ic.TOP_CENTER, "center-center": Ic.CENTER, "center-bottom": Ic.BOTTOM_CENTER, "right-top": Ic.TOP_RIGHT, "right-center": Ic.RIGHT_CENTER, "right-bottom": Ic.BOTTOM_RIGHT },
        Ac = new Phaser.GameObjects.Zone({ sys: { queueDepthSort: _, events: { once: _ } } }, 0, 0, 1, 1);
    Ac.setOrigin(0);

    function jc(t) { var e = qs(t); return t.y + e - e * t.originY }

    function Dc(t) { var e = Zs(t); return t.x - e * t.originX + .5 * e }

    function zc(t, e) { var i = qs(t); return t.y = e - i + i * t.originY, t }

    function Fc(t, e) { var i = Zs(t),
            n = i * t.originX; return t.x = e + n - .5 * i, t }

    function Yc(t) { var e = Zs(t); return t.x - e * t.originX }

    function Xc(t, e) { var i = Zs(t); return t.x = e + i * t.originX, t }

    function Wc(t) { var e = Zs(t); return t.x + e - e * t.originX }

    function Gc(t, e) { var i = Zs(t); return t.x = e - i + i * t.originX, t }

    function Vc(t, e) { var i = qs(t),
            n = i * t.originY; return t.y = e + n - .5 * i, t }

    function Uc(t) { var e = qs(t); return t.y - e * t.originY + .5 * e }

    function Hc(t) { var e = qs(t); return t.y - e * t.originY }

    function Nc(t, e) { var i = qs(t); return t.y = e + i * t.originY, t } var Jc = 0,
        Kc = 1,
        Zc = 2,
        qc = 4,
        $c = 6,
        Qc = 8,
        td = 10,
        ed = 12,
        id = [];
    id[11] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Fc(t, Dc(e) + i), zc(t, jc(e) + n), t }, id[td] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Xc(t, Yc(e) - i), zc(t, jc(e) + n), t }, id[ed] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Gc(t, Wc(e) + i), zc(t, jc(e) + n), t }, id[$c] = function(t, e, i, n) { var s, r, o; return void 0 === i && (i = 0), void 0 === n && (n = 0), s = t, r = Dc(e) + i, o = Uc(e) + n, Fc(s, r), Vc(s, o), t }, id[qc] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Xc(t, Yc(e) - i), Vc(t, Uc(e) + n), t }, id[Qc] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Gc(t, Wc(e) + i), Vc(t, Uc(e) + n), t }, id[Kc] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Fc(t, Dc(e) + i), Nc(t, Hc(e) - n), t }, id[Jc] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Xc(t, Yc(e) - i), Nc(t, Hc(e) - n), t }, id[Zc] = function(t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Gc(t, Wc(e) + i), Nc(t, Hc(e) - n), t };

    function nd(t, e, i, n, s) { return id[i](t, e, n, s) }

    function sd(t, e, i, n, s, r) { Ac.setPosition(e, i).setSize(n, s), nd(t, Ac, r) }

    function rd(t, e) { return void 0 === e && (e = {}), "number" == typeof t ? (e.left = t, e.right = t, e.top = t, e.bottom = t) : (e.left = Fd(t, "left", 0), e.right = Fd(t, "right", 0), e.top = Fd(t, "top", 0), e.bottom = Fd(t, "bottom", 0)), e }

    function od(t) { return Yd.call(this, t), this.sizerEventsEnable && (t.emit("sizer.add", t, this), this.emit("add", t, this)), this }

    function ad(t, e) { return this.childrenMap[t] = e, this }

    function hd(t) { return void 0 === t && (t = Math.max(this.childrenWidth, this.minWidth)), t }

    function ld(t) { var e = Math.max(this.childrenHeight, this.minHeight); return void 0 === t && (t = e), t }

    function ud() { this._childrenWidth = void 0, this._childrenHeight = void 0; for (var t, e = this.getChildrenSizers(), i = 0, n = e.length; i < n; i++)(t = e[i]).ignoreLayout || t.preLayout() }

    function cd(t) { var e, i; for (var n in this.sizerChildren) !(e = this.sizerChildren[n]) || e.isRexSizer && e.ignoreLayout || !e.runWidthWrap || (i = this.getExpandedChildWidth(e, t), e.isRexSizer && (i = e.resolveWidth(i)), e.runWidthWrap(i)); return this }

    function dd(t, e, i, n, s) { var r, o; switch (void 0 === n && (n = "Cubic"), i) {
            case 0:
            case "x":
                r = { x: 0 }, o = { x: t.scaleX }; break;
            case 1:
            case "y":
                r = { y: 0 }, o = { y: t.scaleY }; break;
            default:
                r = 0, o = t.scale } var a = { mode: 0, start: r, end: o, duration: e, ease: n }; return void 0 === s ? s = new Kd(t, a) : s.resetFromJSON(a), s.restart(), s }

    function fd(t, e, i, n, s, r) { void 0 === n && (n = "Linear"), s instanceof Kd && (r = s, s = void 0), void 0 === s && (s = !0); var o = {}; switch (o.mode = s ? 1 : 0, i) {
            case 0:
            case "x":
                o.end = { x: 0 }; break;
            case 1:
            case "y":
                o.end = { y: 0 }; break;
            default:
                o.end = 0 } return o.duration = e, o.ease = n, void 0 === r ? r = new Kd(t, o) : r.resetFromJSON(o), r.restart(), r }

    function pd(e, t) { t.completeEventName = void 0, t.on("complete", function() { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function() { var t = e.getParentSizer();
            t && t.resetChildPositionState(e) }) }

    function vd(t, e, i, n) { var s, r;
        r = rf(i) ? (s = i.start, i.end) : i, void 0 === s && (s = 0), void 0 === r && (r = 1); var o = { mode: 0, start: s, end: r, duration: e }; return void 0 === n ? n = new nf(t, o) : n.resetFromJSON(o), n.restart(), n }

    function gd(t, e, i, n) { i instanceof nf && (n = i, i = void 0), void 0 === i && (i = !0); var s = { mode: i ? 1 : 0, end: 0, duration: e }; return void 0 === n ? n = new nf(t, s) : n.resetFromJSON(s), n.restart(), n }

    function yd(e, t) { t.completeEventName = void 0, t.on("complete", function() { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function() { var t = e.getParentSizer();
            t && t.resetChildAlphaState(e) }) }

    function md(t, e) { if ("number" == typeof t) return t; var i = t[0],
            n = parseFloat(t.substr(2)); switch (i) {
            case "+":
                return e + n;
            case "-":
                return e - n;
            case "*":
                return e * n;
            case "/":
                return e / n } }

    function kd(t, e, i, n, s, r, o) { r instanceof cf && (o = r, r = void 0), void 0 === r && (r = !1); var a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = t.x, a.endX = md(i, t.x)), void 0 !== n && (a.startY = t.y, a.endY = md(n, t.y)), a.duration = e, a.ease = void 0 === s ? "Linear" : s, void 0 === o ? o = new cf(t, a) : o.resetFromJSON(a), o.restart(), o }

    function bd(t, e, i, n, s, r, o) { r instanceof cf && (o = r, r = void 0), void 0 === r && (r = !1); var a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = md(i, t.x), a.endX = t.x), void 0 !== n && (a.startY = md(n, t.y), a.endY = t.y), a.duration = e, a.ease = void 0 === s ? "Linear" : s, void 0 === o ? o = new cf(t, a) : o.resetFromJSON(a), o.restart(), o }

    function xd(e, t) { t.completeEventName = void 0, t.on("complete", function() { t.completeEventName && (e.emit(t.completeEventName, e), t.completeEventName = void 0) }), t.on("update", function() { var t = e.getParentSizer();
            t && t.resetChildPositionState(e) }) }

    function Cd(t) { Pf(t, !1) }

    function wd(t) { Pf(t, !0) }

    function Sd(t) { return !!t && !Bc(t).hidden }

    function Pd(t, e, i, n, s) { return !(!t || !t.getBounds) && (!(n && !n(t, e, i)) && (!!$s(t, !0).contains(e, i) && !(s && !s(t, e, i)))) }

    function Td(t, e, i, n) { if (e) return Pd(t, e.worldX, e.worldY, i, n); for (var s = t.scene.input.manager, r = s.pointersTotal, o = s.pointers, a = 0; a < r; a++)
            if (e = o[a], Pd(t, e.worldX, e.worldY, i, n)) return !0;
        return !1 }

    function Od(t) { return t && "function" == typeof t }

    function Md(t) { return "[object Array]" === Object.prototype.toString.call(t) }

    function Ed(t, e, i, n, s) { return Pd(t, e, i, Of(n), Mf(s)) }

    function _d(t) { return !(t.rexSizer && t.rexSizer.hidden) }

    function Rd(t, e) { var i; if (void 0 === e) t.hasOwnProperty("rexContainer") && (i = t.rexContainer.parent) && !i.isRexSizer && (i = null);
        else
            for (i = Rd(t); i && i.name !== e;) i = Rd(i); return i }

    function Bd(t, e, i) {!t || void 0 === e && void 0 === i || (t.resize ? (void 0 === e && (e = t.width), void 0 === i && (i = t.height), t.resize(e, i)) : (void 0 !== e && (t.displayWidth = e), void 0 !== i && (t.displayHeight = i))) }

    function Id(t) { var e, i;
        this.sizerEventsEnable && (e = t, void 0 === (i = this.getChildPrevState(t)) ? i = {} : !0 === i && (i = _f), i.x = e.x, i.y = e.y, i.scaleX = e.scaleX, i.scaleY = e.scaleY, i.width = e.width, i.height = e.height, i.displayWidth = e.displayWidth, i.displayHeight = e.displayHeight, this.layoutedChildren.push(t)) }

    function Ld(t, e, i, n, s, r, o, a) { sd(t, e, i, n, s, r), void 0 !== o && (t.x += o), void 0 !== a && (t.y += a), this.resetChildPositionState(t), this.sizerEventsEnable && t.emit("sizer.postlayout", t, this) } var Ad = Phaser.Utils.Objects.GetValue,
        jd = Phaser.GameObjects.Group,
        Dd = function(t) { return t.add.text(0, 0, "") },
        zd = void 0,
        Fd = Phaser.Utils.Objects.GetValue,
        Yd = Kr.prototype.add,
        Xd = { addBackground: function(t, e, i) { return void 0 === this.backgroundChildren && (this.backgroundChildren = []), "string" == typeof e && (i = e, e = void 0), void 0 === e && (e = 0), od.call(this, t), this.backgroundChildren.push(t), this.getSizerConfig(t).padding = rd(e), void 0 !== i && this.addChildrenMap(i, t), this }, isBackground: function(t) { return void 0 !== this.backgroundChildren && -1 !== this.backgroundChildren.indexOf(t) } },
        Wd = /(\S+)\[(\d+)\]/i,
        Gd = { getInnerPadding: function(t) { return eo(this.space, t) }, setInnerPadding: function(t, e) { return io(this.space, t, e), this }, getOuterPadding: function(t) { return eo(this.getSizerConfig(this).padding, t) }, setOuterPadding: function(t, e) { return io(this.getSizerConfig(this).padding, t, e), this }, getChildOuterPadding: function(t, e) { return "string" == typeof t && (t = this.getElement(t)), eo(this.getSizerConfig(t).padding, e) }, setChildOuterPadding: function(t, e, i) { return "string" == typeof t && (t = this.getElement(t)), io(this.getSizerConfig(t).padding, e, i), this } },
        Vd = { getShownChildren: function(t) { void 0 === t && (t = []); for (var e, i = this.children, n = 0, s = i.length; n < s; n++)(e = i[n]).rexSizer && e.rexSizer.hidden || t.push(e); return t }, getAllShownChildren: function(t) { void 0 === t && (t = []); for (var e, i = this.children, n = 0, s = i.length; n < s; n++) { if (!(e = i[n]).rexSizer || !e.rexSizer.hidden)
                        if (t.push(e), e.hasOwnProperty("isRexContainerLite")) t.push.apply(t, M(e.getAllShownChildren())) } return t } },
        Ud = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, { eventEmitter: !1 })).viewport = void 0, i.resetFromJSON(e), i } return k(s, [{ key: "shutdown", value: function(t) { this.isShutdown || (this.autoAnchor(!1), this.viewport = void 0, this.onUpdateViewportCallback = void 0, this.onUpdateViewportCallbackScope = void 0, this.onResizeCallback = void 0, this.onResizeCallbackScope = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "resetFromJSON", value: function(t) { var e, i, n, s, r, o, a, h;
                    void 0 === t && (t = {}), void 0 !== t.x ? (e = null, i = t.x) : void 0 !== t.left ? (e = 0, i = t.left) : void 0 !== t.right ? (e = 1, i = t.right) : void 0 !== t.centerX && (e = .5, i = t.centerX), void 0 !== t.y ? (n = null, s = t.y) : void 0 !== t.top ? (n = 0, s = t.top) : void 0 !== t.bottom ? (n = 1, s = t.bottom) : void 0 !== t.centerY && (n = .5, s = t.centerY), void 0 !== i && (i = i.replace("left", "0%").replace("right", "100%").replace("center", "50%").split("%"), r = parseFloat(i[0]) / 100, o = "" === i[1] ? 0 : parseFloat(i[1])), void 0 !== s && (s = s.replace("top", "0%").replace("bottom", "100%").replace("center", "50%").split("%"), a = parseFloat(s[0]) / 100, h = "" === s[1] ? 0 : parseFloat(s[1])); var l, u, c = t.width;
                    void 0 !== c && (c = c.split("%"), l = parseFloat(c[0]) / 100, u = "" === c[1] ? 0 : parseFloat(c[1])); var d, f, p = t.height;
                    void 0 !== p && (p = p.split("%"), d = parseFloat(p[0]) / 100, f = "" === p[1] ? 0 : parseFloat(p[1])), this.setAlign(e, n), this.setPercentage(r, a), this.setOffset(o, h), this.setSizePercentage(l, d), this.setSizePadding(u, f); var v = t.onResizeCallback,
                        g = t.onResizeCallbackScope;
                    void 0 !== v && this.setResizeCallback(v, g); var y = t.onUpdateViewportCallback,
                        m = t.onUpdateViewportCallbackScope; return void 0 !== y && this.setUpdateViewportCallback(y, m), this.autoAnchor(t.enable), this } }, { key: "autoAnchor", value: function(t) { return void 0 === t && (t = !0), t = !!t, this.autoAnchorEnable === t || (t ? (this.scene.sys.scale.on("resize", this.anchor, this), this.anchor()) : this.scene.sys.scale.off("resize", this.anchor, this), this.autoAnchorEnable = t), this } }, { key: "setAlign", value: function(t, e) { return this.alignX = t, this.alignY = e, this } }, { key: "setPercentage", value: function(t, e) { return this.percentageX = t, this.percentageY = e, this } }, { key: "setOffset", value: function(t, e) { return this.offsetX = t, this.offsetY = e, this } }, { key: "setSizePercentage", value: function(t, e) { return this.percentageWidth = t, this.percentageHeight = e, this } }, { key: "setSizePadding", value: function(t, e) { return this.paddingWidth = t, this.paddingHeight = e, this } }, { key: "setResizeCallback", value: function(t, e) { return this.onResizeCallback = t, this.onResizeCallbackScope = e, this } }, { key: "setUpdateViewportCallback", value: function(t, e) { return this.onUpdateViewportCallback = t, this.onUpdateViewportCallbackScope = e, this } }, { key: "anchor", value: function() { return this.updateViewport(), this.updateSize(), this.updatePosition(), this } }, { key: "updateSize", value: function() { var t = this.onResizeCallback,
                        e = this.onResizeCallbackScope,
                        i = this.anchorWidth,
                        n = this.anchorHeight; if ((void 0 !== i || void 0 !== n) && t) { var s = this.parent;
                        void 0 === i && (i = s.width), void 0 === n && (n = s.height), e ? t.call(e, i, n, s, this) : t(i, n, s, this) } } }, { key: "updatePosition", value: function() { var t = this.parent; return null === this.alignX ? t.x = this.anchorX : void 0 !== this.alignX && (t.x = this.anchorX + t.displayWidth * (t.originX - this.alignX)), null === this.alignY ? t.y = this.anchorY : void 0 !== this.alignY && (t.y = this.anchorY + t.displayHeight * (t.originY - this.alignY)), this } }, { key: "anchorX", get: function() { return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX } }, { key: "anchorY", get: function() { return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY } }, { key: "anchorWidth", get: function() { if (void 0 !== this.percentageWidth) return this.viewport.width * this.percentageWidth + this.paddingWidth } }, { key: "anchorHeight", get: function() { if (void 0 !== this.percentageHeight) return this.viewport.height * this.percentageHeight + this.paddingHeight } }, { key: "updateViewport", value: function() { var t = this.parent.scene.cameras.main;
                    this.viewport = xh(this.scene, t, this.viewport); var e = this.viewport,
                        i = this.onUpdateViewportCallback,
                        n = this.onUpdateViewportCallbackScope;
                    i && (n ? i.call(n, e, this.parent, this) : i(e, this.parent, this)) } }]), s }(),
        Hd = Phaser.Utils.Objects.GetValue,
        Nd = Phaser.Utils.Objects.GetAdvancedValue,
        Jd = Phaser.Math.Linear,
        Kd = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).scaleStart = {}, i.scaleEnd = {}, i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(Hd(t, "mode", 0)), this.setScaleRange(Nd(t, "start", void 0), Nd(t, "end", 0)), this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = Zd[t]), this.mode = t, this } }, { key: "setScaleRange", value: function(t, e) { return "number" == typeof t ? (this.startX = t, this.startY = t) : (this.startX = Nd(t, "x", this.parent.scaleX), this.startY = Nd(t, "y", this.parent.scaleY)), "number" == typeof e ? (this.endX = e, this.endY = e) : (this.endX = Nd(e, "x", void 0), this.endY = Nd(e, "y", void 0)), this.hasScaleX = void 0 !== this.startX && void 0 !== this.endX, this.hasScaleY = void 0 !== this.startY && void 0 !== this.endY, this } }, { key: "start", value: function() { if (this.timer.isRunning) return this; var t = this.parent;
                    this.hasScaleX && (t.scaleX = this.startX), this.hasScaleY && (t.scaleY = this.startY); var e = this.repeat; return 2 === this.mode && -1 !== e && (e = 2 * (e + 1) - 1), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(e), O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function(t, e) { var i = e.t;
                    e.isOddIteration && (i = 1 - i), i = this.easeFn(i), this.hasScaleX && (t.scaleX = Jd(this.startX, this.endX, i)), this.hasScaleY && (t.scaleY = Jd(this.startY, this.endY, i)) } }, { key: "complete", value: function() { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(),
        Zd = { stop: 0, destroy: 1, yoyo: 2 },
        qd = Phaser.Utils.Objects.IsPlainObject,
        $d = { popUp: function(t, e, i) { if (qd(t)) { var n = t;
                    t = n.duration, e = n.orientation, i = n.ease } var s = void 0 === this._scale; return this._scale = dd(this, t, e, i, this._scale), s && pd(this, this._scale), this._scale.completeEventName = "popup.complete", this }, popUpPromise: function(t, e, i) { return this.popUp(t, e, i), nl(this._scale) }, scaleDownDestroy: function(t, e, i, n) { if (qd(t)) { var s = t;
                    t = s.duration, e = s.orientation, i = s.ease, n = s.destroy } var r = void 0 === this._scale; return this._scale = fd(this, t, e, i, n, this._scale), r && pd(this, this._scale), this._scale.completeEventName = "scaledown.complete", this }, scaleDownDestroyPromise: function(t, e, i, n) { return this.scaleDownDestroy(t, e, i, n), nl(this._scale) }, scaleDown: function(t, e, i) { return this.scaleDownDestroy(t, e, i, !1), this }, scaleDownPromise: function(t, e, i) { return this.scaleDown(t, e, i), nl(this._scale) }, scaleYoyo: function(t, e, i, n, s) { if (qd(t)) { var r = t;
                    t = r.duration, e = r.peakValue, i = r.repeat, n = r.orientation, s = r.ease } var o = void 0 === this._scale; return this._scale = function(t, e, i, n, s, r, o) { var a, h; switch (void 0 === i && (i = 1.2), void 0 === n && (n = 0), void 0 === r && (r = "Cubic"), s) {
                        case 0:
                        case "x":
                            a = { x: t.scaleX }, h = { x: i }; break;
                        case 1:
                        case "y":
                            a = { y: t.scaleX }, h = { y: i }; break;
                        default:
                            a = t.scaleX, h = i } var l = { mode: 2, start: a, end: h, duration: e / 2, ease: r, repeat: n }; return void 0 === o ? o = new Kd(t, l) : o.resetFromJSON(l), o.restart(), o }(this, t, e, i, n, s, this._scale), o && pd(this, this._scale), this._scale.completeEventName = "scaleyoyo.complete", this }, scaleYoyoPromise: function(t, e, i, n, s) { return this.scaleYoyo(t, e, i, n, s), nl(this._scale) } },
        Qd = Phaser.Utils.Objects.GetValue,
        tf = Phaser.Utils.Objects.GetAdvancedValue,
        ef = Phaser.Math.Linear,
        nf = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(Qd(t, "mode", 0)), this.setAlphaRange(tf(t, "start", this.parent.alpha), tf(t, "end", 0)), this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = sf[t]), this.mode = t, this } }, { key: "setAlphaRange", value: function(t, e) { return this.alphaStart = t, this.alphaEnd = e, this } }, { key: "start", value: function() { return this.timer.isRunning || (this.parent.setAlpha(this.alphaStart), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(2 === this.mode ? -1 : 0), O(C(s.prototype), "start", this).call(this)), this } }, { key: "updateGameObject", value: function(t, e) { var i = e.t;
                    e.isOddIteration && (i = 1 - i), t.alpha = ef(this.alphaStart, this.alphaEnd, i) } }, { key: "complete", value: function() { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(),
        sf = { stop: 0, destroy: 1, yoyo: 2 },
        rf = Phaser.Utils.Objects.IsPlainObject,
        of = Phaser.Utils.Objects.IsPlainObject,
        af = { fadeIn: function(t, e) { if (of(t)) { var i = t;
                    t = i.duration, e = i.alpha } var n = void 0 === this._fade; return this._fade = vd(this, t, e, this._fade), n && yd(this, this._fade), this._fade.completeEventName = "fadein.complete", this }, fadeInPromise: function(t, e) { return this.fadeIn(t, e), nl(this._fade) }, fadeOutDestroy: function(t, e) { if (of(t)) { var i = t;
                    t = i.duration, e = i.destroy } var n = void 0 === this._fade; return this._fade = gd(this, t, e, this._fade), n && yd(this, this._fade), this._fade.completeEventName = "fadeout.complete", this }, fadeOutDestroyPromise: function(t, e) { return this.fadeOutDestroy(t, e), nl(this._fade) }, fadeOut: function(t) { return this.fadeOutDestroy(t, !1), this }, fadeOutPromise: function(t) { return this.fadeOut(t), nl(this._fade) } },
        hf = Phaser.Utils.Objects.GetValue,
        lf = Phaser.Utils.Objects.GetAdvancedValue,
        uf = Phaser.Math.Linear,
        cf = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { if (O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setMode(hf(t, "mode", 0)), t && (t.hasOwnProperty("x") || t.hasOwnProperty("y"))) { var e = lf(t, "x", void 0),
                            i = lf(t, "y", void 0);
                        this.setTargetPosition(e, i) } else this.setTargetPosition(t); return this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = df[t]), this.mode = t, this } }, { key: "setTargetPosition", value: function(t, e) { if ("number" == typeof t || "number" == typeof e) this.startX = this.parent.x, this.startY = this.parent.y, this.endX = t, this.endY = e;
                    else { var i = t;
                        this.startX = lf(i, "startX", void 0), this.startY = lf(i, "startY", void 0), this.endX = lf(i, "endX", void 0), this.endY = lf(i, "endY", void 0) } return this.hasMoveX = void 0 !== this.startX && void 0 !== this.endX, this.hasMoveY = void 0 !== this.startY && void 0 !== this.endY, this } }, { key: "start", value: function() { if (this.timer.isRunning) return this; var t = this.parent; return this.hasMoveX && (t.x = this.startX), this.hasMoveY && (t.y = this.startY), this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(2 === this.mode ? -1 : 0), O(C(s.prototype), "start", this).call(this), this } }, { key: "updateGameObject", value: function(t, e) { var i = e.t;
                    e.isOddIteration && (i = 1 - i), i = this.easeFn(i), this.hasMoveX && (t.x = uf(this.startX, this.endX, i)), this.hasMoveY && (t.y = uf(this.startY, this.endY, i)) } }, { key: "complete", value: function() { return O(C(s.prototype), "complete", this).call(this), 1 === this.mode && this.parent.destroy(), this } }]), s }(),
        df = { stop: 0, destroy: 1, yoyo: 2 },
        ff = Phaser.Utils.Objects.IsPlainObject,
        pf = Phaser.Math.Distance.Between,
        vf = { moveFrom: function(t, e, i, n, s) { if (ff(t)) { var r = t;
                    e = r.x, i = r.y, t = r.hasOwnProperty("speed") ? 1e3 * pf(e, i, this.x, this.y) / r.speed : r.duration, n = r.ease } var o = void 0 === this._easeMove; return this._easeMove = bd(this, t, e, i, n, s, this._easeMove), o && xd(this, this._easeMove), this._easeMove.completeEventName = "movefrom.complete", this }, moveFromPromise: function(t, e, i, n, s) { return this.moveFrom(t, e, i, n, s), nl(this._easeMove) }, moveFromDestroy: function(t, e, i, n) { return this.moveFrom(t, e, i, n, !0), this }, moveFromDestroyPromise: function(t, e, i, n) { return this.moveFromDestroy(t, e, i, n), nl(this._easeMove) }, moveTo: function(t, e, i, n, s) { if (ff(t)) { var r = t;
                    e = r.x, i = r.y, t = r.hasOwnProperty("speed") ? 1e3 * pf(e, i, this.x, this.y) / r.speed : r.duration, n = r.ease } var o = void 0 === this._easeMove; return this._easeMove = kd(this, t, e, i, n, s, this._easeMove), o && xd(this, this._easeMove), this._easeMove.completeEventName = "moveto.complete", this }, moveToPromise: function(t, e, i, n, s) { return this.moveTo(t, e, i, n, s), nl(this._easeMove) }, moveToDestroy: function(t, e, i, n) { return this.moveTo(t, e, i, n, !0), this }, moveToDestroyPromise: function(t, e, i, n) { return this.moveToDestroy(t, e, i, n, !0), nl(this._easeMove) }, moveStop: function(t) { return this._easeMove && this._easeMove.stop(t), this } },
        gf = Phaser.Utils.Objects.GetValue,
        yf = function() { w(s, Ca); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).timer = new Ma(), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.timer.resetFromJSON(gf(t, "timer")), this.setEnable(gf(t, "enable", !0)), this.setMode(gf(t, "mode", 1)), this.isRunning = gf(t, "isRunning", !1), this.setMagnitudeMode(gf(t, "magnitudeMode", 1)), this.setDuration(gf(t, "duration", 500)), this.setMagnitude(gf(t, "magnitude", 10)), this.ox = gf(t, "ox", void 0), this.oy = gf(t, "oy", void 0), this } }, { key: "toJSON", value: function() { return { timer: this.timer.toJSON(), enable: this.enable, mode: this.mode, isRunning: this.isRunning, magnitudeMode: magnitudeMode, duration: this.duration, magnitude: this.magnitude, ox: this.ox, oy: this.oy } } }, { key: "shutdown", value: function(t) { this.isShutdown || (O(C(s.prototype), "shutdown", this).call(this, t), this.timer.destroy(), this.timer = void 0) } }, { key: "startTicking", value: function() { O(C(s.prototype), "startTicking", this).call(this), 0 === this.mode ? (this.scene.game.events.on("poststep", this.update, this), this.scene.game.events.on("prestep", this.backToOrigin, this)) : this.scene.sys.events.on("preupdate", this.update, this) } }, { key: "stopTicking", value: function() { O(C(s.prototype), "stopTicking", this).call(this), this.scene && (0 === this.mode ? (this.scene.game.events.off("poststep", this.update, this), this.scene.game.events.off("prestep", this.backToOrigin, this)) : this.scene.sys.events.off("preupdate", this.update, this)) } }, { key: "setEnable", value: function(t) { return null == t && (t = !0), this.enable = t, this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = mf[t]), this.mode = t, this } }, { key: "setMagnitudeMode", value: function(t) { return "string" == typeof t && (t = kf[t]), this.magnitudeMode = t, this } }, { key: "setDuration", value: function(t) { return this.duration = t, this } }, { key: "setMagnitude", value: function(t) { return this.magnitude = t, this } }, { key: "start", value: function(t, e) { if ("number" != typeof t) { var i = t;
                        e = gf(i, "magnitude", void 0), t = gf(i, "duration", void 0) } return void 0 !== e && this.setMagnitude(e), void 0 !== t && this.setDuration(t), this.timer.setDuration(this.duration).start(), O(C(s.prototype), "start", this).call(this), this } }, { key: "shake", value: function(t, e) { return this.start(t, e), this } }, { key: "update", value: function(t, e) { if (!this.isRunning || !this.enable) return this; var i = this.parent; if (!i.active) return this; if (this.timer.update(t, e), this.timer.isDone) this.backToOrigin(), this.complete();
                    else { void 0 === this.ox && (this.ox = i.x, this.oy = i.y); var n = this.magnitude;
                        1 === this.magnitudeMode && (n *= 1 - this.timer.t); var s = Math.random() * Math.PI * 2,
                            r = Math.cos(s) * n,
                            o = Math.sin(s) * n;
                        i.setPosition(this.ox + r, this.oy + o) } return this } }, { key: "backToOrigin", value: function() { if (!this.isRunning || !this.enable) return this; if (void 0 === this.ox) return this; var t = this.parent; return this.ox === t.x && this.oy === t.y || (t.setPosition(this.ox, this.oy), this.ox = void 0, this.oy = void 0), this } }]), s }(),
        mf = { effect: 0, behavior: 1 },
        kf = { constant: 0, decay: 1 },
        bf = Phaser.Utils.Objects.IsPlainObject,
        xf = { shake: function(t, e, i) { if (bf(t)) { var n = t;
                    t = n.duration, e = n.magnitude, i = n.magnitudeMode } var s; return void 0 === this._shake && (this._shake = new yf(this, { mode: 0, magnitudeMode: 1 }), (s = this)._shake.on("complete", function() { s.emit("shake.complete", s) })), void 0 !== t && this._shake.setDuration(t), void 0 !== e && this._shake.setMagnitude(e), void 0 !== i && this._shake.setMagnitudeMode(i), this._shake.shake(), this }, shakePromise: function(t, e) { return this.shake(t, e), nl(this._shake) } },
        Cf = Phaser.Utils.Objects.IsPlainObject,
        wf = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).parent.setDataEnabled(), i.easeTasks = {}, i } return k(s, [{ key: "complete", value: function(t) { this.emit("complete-".concat(t), this.parent, this), this.emit("complete", t, this.parent, this) } }, { key: "getEaseTask", value: function(t) { var e = this.easeTasks[t]; return void 0 === e && (e = new Au(this.parent), (this.easeTasks[t] = e).setTarget(this.parent.data.values).on("complete", function() { this.complete(t) }, this)), e } }, { key: "easeTo", value: function(t, e, i, n) { if (Cf(t)) { var s = t;
                        t = s.key, e = s.value, i = s.duration, n = s.ease; var r = s.speed;
                        void 0 === i && void 0 !== r && (i = Math.abs(e - this.parent.data.values[t]) / r * 1e3) } return void 0 === i && (i = 1e3), void 0 === n && (n = "Linear"), this.getEaseTask(t).restart({ key: t, to: e, duration: i, ease: n }), this } }, { key: "easeFrom", value: function(t, e, i, n) { if (Cf(t)) { var s = t;
                        t = s.key, e = s.value, i = s.duration, n = s.ease; var r = s.speed;
                        void 0 === i && void 0 !== r && (i = Math.abs(e - this.parent.data.values[t]) / r * 1e3) } return void 0 === i && (i = 1e3), void 0 === n && (n = "Linear"), this.getEaseTask(t).restart({ key: t, from: e, duration: i, ease: n }), this } }, { key: "stopEase", value: function(t, e) { void 0 === e && (e = !0); var i = this.easeTasks[t]; return i && i.stop(e), this } }, { key: "stopAll", value: function(t) { for (var e in void 0 === t && (t = !0), this.easeTasks) this.stopEase(e, t); return this } }]), s }(),
        Sf = { easeDataTo: function(t, e, i, n) { var s; return this._easeData || (this._easeData = new wf(this), (s = this)._easeData.on("complete", function(t) { s.emit("easedata.".concat(t, ".complete"), s), s.emit("easedata.complete", t, s) })), this._easeData.easeTo(t, e, i, n), this }, easeDataToPromise: function(t, e, i, n) { return this.easeDataTo(t, e, i, n), il(this._easeData, "complete-".concat(t)) }, stopEaseData: function(t, e) { return this._easeData && this._easeData.stopEase(t, e), this }, stopAllEaseData: function(t) { return this._easeData && this._easeData.stopAll(t), this } },
        Pf = function(t, e) { if (t) { Bc(t).hidden = e; var i = Fs(t);
                i ? i.setChildVisible(t, !e) : t.setVisible(!e) } },
        Tf = { show: function(t) { return void 0 === t && (t = this), Cd(t), this }, hide: function(t) { return void 0 === t && (t = this), wd(t), this }, isShow: function(t) { return void 0 === t && (t = this), Sd(t) } },
        Of = function(n) { return n ? function(t, e, i) { return !!_d(t) && (n(t, e, i), !0) } : _d },
        Mf = function(t) { return t },
        Ef = { getParentSizer: function(t, e) { return "string" == typeof t && (e = t, t = void 0), void 0 === t && (t = this), Rd(t, e) }, getTopmostSizer: function(t) { return void 0 === t && (t = this),
                    function(t) { for (var e = Rd(t); e;) e = Rd(t = e); return t }(t) } },
        _f = {},
        Rf = Phaser.Display.Align.CENTER,
        Bf = Phaser.Utils.Objects.GetValue,
        If = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e))._enable = void 0, t.setInteractive(Bf(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.pointer = void 0, this.lastClickTime = void 0, this.setEnable(Bf(t, "enable", !0)), this.setMode(Bf(t, "mode", 1)), this.setClickInterval(Bf(t, "clickInterval", 100)), this.setDragThreshold(Bf(t, "threshold", void 0)), this } }, { key: "boot", value: function() { var t = this.parent;
                    t.on("pointerdown", this.onPress, this), t.on("pointerup", this.onRelease, this), t.on("pointerout", this.onPointOut, this), t.on("pointermove", this.onMove, this), t.on("pointerover", this.onOver, this), t.on("pointeroutr", this.onOut, this) } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.pointer = null, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) { t || this.cancel(); var e = (this._enable = t) ? "enable" : "disable";
                        this.emit(e, this, this.parent) } } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = Lf[t]), this.mode = t, this } }, { key: "setClickInterval", value: function(t) { return this.clickInterval = t, this } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }, { key: "onPress", value: function(t, e, i, n) { void 0 === this.pointer && (this.pointer = t, 0 === this.mode && this.click(t.downTime, t, n)) } }, { key: "onRelease", value: function(t, e, i, n) { this.pointer === t && (1 === this.mode && this.click(t.upTime, t, n), this.pointer = void 0) } }, { key: "onPointOut", value: function(t) { this.pointer === t && this.cancel() } }, { key: "onMove", value: function(t) { this.pointer === t && void 0 !== this.dragThreshold && t.getDistance() >= this.dragThreshold && this.cancel() } }, { key: "click", value: function(t, e, i) { if (!this.enable) return this; if (void 0 === t) return this.emit("click", this, this.parent, e, i), this;
                    this.pointer = void 0; var n = this.lastClickTime; return void 0 !== n && t - n <= this.clickInterval || (this.lastClickTime = t, this.emit("click", this, this.parent, e, i)), this } }, { key: "cancel", value: function() { return this.pointer = void 0, this } }, { key: "onOver", value: function(t, e, i, n) { return this.enable && this.emit("over", this, this.parent, t, n), this } }, { key: "onOut", value: function(t, e) { return this.enable && this.emit("out", this, this.parent, t, e), this } }]), s }(),
        Lf = { press: 0, pointerdown: 0, release: 1, pointerup: 1 },
        Af = { onClick: function(t, e, i) { return t && (void 0 === this._click && (this._click = new If(this, i)), this._click.on("click", t, e)), this }, offClick: function(t, e) { return void 0 === this._click || this._click.off("click", t, e), this }, enableClick: function(t) { return void 0 === this._click || this._click.setEnable(t), this }, disableClick: function() { return void 0 === this._click || this._click.setEnable(!1), this } },
        jf = Phaser.Utils.Objects.GetValue,
        Df = function() { w(r, ds); var s = T(r);

            function r(t, e) { var i;
                X(this, r), (i = s.call(this, t, e))._enable = void 0; var n = jf(e, "inputConfig", void 0); return n && t.setInteractive(n), i.resetFromJSON(e), i.boot(), i } return k(r, [{ key: "resetFromJSON", value: function(t) { return this.setEnable(jf(t, "enable", !0)), this.setMode(jf(t, "mode", 1)), this.setClickInterval(jf(t, "clickInterval", 100)), this } }, { key: "boot", value: function() { var t = this.parent.scene;
                    t.input.on("pointerdown", this.onPress, this), t.input.on("pointerup", this.onRelease, this) } }, { key: "shutdown", value: function(t) { if (!this.isShutdown) { var e = this.parent.scene;
                        e.input.off("pointerdown", this.onPress, this), e.input.off("pointerup", this.onRelease, this), O(C(r.prototype), "shutdown", this).call(this, t) } } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) { var e = (this._enable = t) ? "enable" : "disable";
                        this.emit(e, this, this.parent) } } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "setMode", value: function(t) { return "string" == typeof t && (t = zf[t]), this.mode = t, this } }, { key: "setClickInterval", value: function(t) { return this.clickInterval = t, this } }, { key: "isPointerInside", value: function(t) { var e = this.parent; return (e.input ? ps : Td)(e, t) } }, { key: "onPress", value: function(t) { if (0 === this.mode) { if (!this.parent.willRender(t.camera)) return;
                        this.isPointerInside(t) || this.click(t.downTime, t) } } }, { key: "onRelease", value: function(t) { if (1 === this.mode) { if (!this.parent.willRender(t.camera)) return;
                        this.isPointerInside(t) || this.click(t.upTime, t) } } }, { key: "click", value: function(t, e) { if (!this.enable) return this; if (void 0 === t) return this.emit("clickoutside", this, this.parent, e), this; var i = this.lastClickTime; return void 0 !== i && t - i <= this.clickInterval || (this.lastClickTime = t, this.emit("clickoutside", this, this.parent, e)), this } }]), r }(),
        zf = { press: 0, pointerdown: 0, release: 1, pointerup: 1 },
        Ff = { onClickOutside: function(t, e, i) { return t && (void 0 === this._clickOutside && (this._clickOutside = new Df(this, i)), this._clickOutside.on("clickoutside", t, e)), this }, offClickOutside: function(t, e) { return void 0 === this._clickOutside || this._clickOutside.off("clickoutside", t, e), this }, enableClickOutside: function(t) { return void 0 === this._clickOutside || this._clickOutside.setEnable(t), this }, disableClickOutside: function() { return void 0 === this._clickOutside || this._clickOutside.setEnable(!1), this } },
        Yf = function() {
            function o(t) { X(this, o); var e = ot(t, "states", void 0);
                e && this.addStates(e); var i = ot(t, "extend", void 0); if (i)
                    for (var n in i) this.hasOwnProperty(n) && void 0 !== this[n] || (this[n] = i[n]); var s = ot(t, "eventEmitter", void 0),
                    r = ot(t, "EventEmitterClass", void 0);
                this.setEventEmitter(s, r), this._stateLock = !1, this.resetFromJSON(t) } return k(o, [{ key: "shutdown", value: function() { this.destroyEventEmitter() } }, { key: "destroy", value: function() { this.shutdown() } }, { key: "resetFromJSON", value: function(t) { this.setEnable(ot(t, "enable", !0)), this.start(ot(t, "start", void 0)); var e = ot(t, "init", void 0); return e && e.call(this), this } }, { key: "toJSON", value: function() { return { curState: this.state, prevState: this.prevState, enable: this.enable, start: this._start } } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "state", get: function() { return this._state }, set: function(t) { if (this.enable && !this._stateLock && this._state !== t) { if (this._prevState = this._state, this._state = t, this._stateLock = !0, this.emit("statechange", this), null != this._prevState) { var e = "exit_" + this._prevState,
                                i = this[e];
                            i && i.call(this), this.emit(e, this) } if (this._stateLock = !1, null != this._state) { var n = "enter_" + this._state,
                                s = this[n];
                            s && s.call(this), this.emit(n, this) } } } }, { key: "prevState", get: function() { return this._prevState } }, { key: "start", value: function(t) { return this._start = t, this._prevState = void 0, this._state = t, this } }, { key: "goto", value: function(t) { return null != t && (this.state = t), this } }, { key: "next", value: function() { var t, e = this["next_" + this.state]; return e && (t = "string" == typeof e ? e : e.call(this)), this.goto(t), this } }, { key: "addState", value: function(t, e) { "string" != typeof t && (t = (e = t).name); var i = e.next;
                    i && (this["next_" + t] = i); var n = e.exit;
                    n && (this["exit_" + t] = n); var s = e.enter; return s && (this["enter_" + t] = s), this } }, { key: "addStates", value: function(t) { if (Array.isArray(t))
                        for (var e = 0, i = t.length; e < i; e++) this.addState(t[e]);
                    else
                        for (var n in t) this.addState(n, t[n]); return this } }, { key: "runMethod", value: function(t, e, i, n, s, r) { var o = this[t + "_" + this.state]; if (o) { var a = arguments.length; switch (a) {
                            case 1:
                                return o.call(this);
                            case 2:
                                return o.call(this, e);
                            case 3:
                                return o.call(this, e, i);
                            case 4:
                                return o.call(this, e, i, n);
                            case 5:
                                return o.call(this, e, i, n, s);
                            case 6:
                                return o.call(this, e, i, n, s, r) } for (var h = new Array(a - 1), l = 1; l < a; l++) h[l - 1] = arguments[l]; return o.apply(this, h) } } }, { key: "update", value: function(t, e) { this.runMethod("update", t, e) } }, { key: "preupdate", value: function(t, e) { this.runMethod("preupdate", t, e) } }, { key: "postupdate", value: function(t, e) { this.runMethod("postupdate", t, e) } }]), o }();
    Object.assign(Yf.prototype, ls);

    function Xf(t, e, i) { for (var n, s = 0, r = t.length; s < r; s++)
            if (n = t[s], Ed(n, e, i)) return n.pointToChild(e, i);
        return null }

    function Wf(t, e, i, n, s, r, o) { var a;
        (a = void 0 === s ? n : Xf(i, n, s)) && t.emit(e, a, r, o) } var Gf = function() { w(i, Yf); var e = T(i);

            function i() { var t; return X(this, i), (t = e.call(this, { eventEmitter: !1 })).goto("IDLE"), t } return k(i, [{ key: "setCooldownTime", value: function(t) { return this.cooldownTime = t, this.cooldownMode = void 0 !== t, this } }, { key: "request", value: function() { return this.runMethod("request") } }, { key: "update_IDLE", value: function() { this.compensationTime = 0 } }, { key: "request_IDLE", value: function() { return this.next(), !0 } }, { key: "next_IDLE", value: function() { if (this.cooldownMode) return "COOLDOWN" } }, { key: "enter_COOLDOWN", value: function() { this.remainderTime = this.cooldownTime + this.compensationTime } }, { key: "update_COOLDOWN", value: function(t, e) { this.remainderTime -= e, this.remainderTime < 0 && (this.compensationTime = this.cooldownTime > e ? -this.remainderTime : 0, this.goto("IDLE")) } }, { key: "request_COOLDOWN", value: function() { return !1 } }]), i }(),
        Vf = Phaser.Utils.Objects.GetValue,
        Uf = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e))._enable = void 0, i.cooldown = new Gf(), i.parent.setInteractive(Vf(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.pointer = void 0, this.isInTouching = !1, this.setEnable(Vf(t, "enable", !0)), this.setCooldown(Vf(t, "cooldown", void 0)), this } }, { key: "boot", value: function() { var t = this.parent;
                    t.on("pointerdown", this.onPointIn, this), t.on("pointerover", this.onPointIn, this), t.on("pointerup", this.onPointOut, this), t.on("pointerout", this.onPointOut, this), this.scene.sys.events.on("preupdate", this.preupdate, this) } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this.preupdate, this), this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) return t || (this.isInTouching = !1, this.pointer = void 0), this._enable = t, this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "cooldownTime", get: function() { return this.cooldown.cooldownTime }, set: function(t) { this.cooldown.setCooldownTime(t) } }, { key: "setCooldown", value: function(t) { return this.cooldownTime = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "onPointIn", value: function(t) { this.enable && t.isDown && void 0 === this.pointer && (this.pointer = t, this.isInTouching = !0) } }, { key: "onPointOut", value: function(t) { this.enable && this.pointer === t && (this.pointer = void 0, this.isInTouching = !1) } }, { key: "preupdate", value: function(t, e) { this.cooldown.update(t, e), this.isInTouching && this.cooldown.request() && this.emit("intouch", this, this.parent, this.pointer) } }]), s }(),
        Hf = { onTouching: function(t, e, i) { return t && (void 0 === this._inTouching && (this._inTouching = new Uf(this, i)), this._inTouching.on("intouch", t, e)), this }, offTouching: function(t, e) { return void 0 === this._inTouching || this._inTouching.off("intouch", t, e), this }, enableTouching: function(t) { return void 0 === this._inTouching || this._inTouching.setEnable(t), this }, disableTouching: function() { return void 0 === this._inTouching || this._inTouching.setEnable(!1), this } },
        Nf = Phaser.Utils.Objects.GetValue,
        Jf = function(t, e, i, n) { var s = this._childrenInteractive;
            Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "down"), s.targetSizers, t.worldX, t.worldY, t, n) },
        Kf = Phaser.Utils.Objects.GetValue,
        Zf = function(t, e, i, n) { var s = this._childrenInteractive;
            Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "up"), s.targetSizers, t.worldX, t.worldY, t, n) },
        qf = Phaser.Utils.Objects.GetValue,
        $f = function(t, e, i, n) { var s = this._childrenInteractive,
                r = Xf(s.targetSizers, t.worldX, t.worldY),
                o = s.lastOverChild;
            r && o && r === o || (s.lastOverChild = r, Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "out"), s.targetSizers, o, void 0, t, n), Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "over"), s.targetSizers, r, void 0, t, n)) },
        Qf = function(t, e) { var i = this._childrenInteractive,
                n = i.lastOverChild;
            i.lastOverChild = null, Wf(i.eventEmitter, "".concat(i.eventNamePrefix, "out"), i.targetSizers, n, void 0, t, e) },
        tp = Phaser.Utils.Objects.GetValue,
        ep = Phaser.Utils.Objects.GetValue,
        ip = function() { w(r, Ca); var s = T(r);

            function r(t, e) { var i;
                X(this, r); var n = hs(t); return n === t && (t = void 0), ((i = s.call(this, n, e)).gameObject = t) && t.setInteractive(ep(e, "inputConfig", void 0)), i._enable = void 0, i.resetFromJSON(e), i.boot(), i } return k(r, [{ key: "resetFromJSON", value: function(t) { return this.setEnable(ep(t, "enable", !0)), this.setDetectBounds(), void 0 === this.gameObject ? this.setDetectBounds(ep(t, "bounds", void 0)) : this.setDetectBounds(), this.tracerState = np, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, this.isTouchingAnyObject = !1, this } }, { key: "boot", value: function() { O(C(r.prototype), "boot", this).call(this), this.gameObject ? this.gameObject.on("pointerdown", this.onPointerDown, this) : this.scene.input.on("pointerdown", this.onPointerDown, this), this.scene.input.on("pointerup", this.onPointerUp, this), this.scene.input.on("gameout", this.dragCancel, this), this.scene.input.on("pointermove", this.onPointerMove, this), this.scene.sys.events.once("shutdown", this.destroy, this) } }, { key: "shutdown", value: function(t) { this.scene && (this.gameObject || this.scene.input.off("pointerdown", this.onPointerDown, this), this.scene.input.off("pointerup", this.onPointerUp, this), this.scene.input.off("gameout", this.dragCancel, this), this.scene.input.off("pointermove", this.onPointerMove, this), this.scene.sys.events.off("shutdown", this.destroy, this), this.gameObject = void 0, this.bounds = void 0, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, O(C(r.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setDetectBounds", value: function(t) { return this.bounds = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "onPointerDown", value: function(t, e) { this.enable && void 0 === this.pointer && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer === t || (this.pointer = t, this.lastPointer = t, this.movedState = !1, this.tracerState = sp, void 0 === this.gameObject && (this.isTouchingAnyObject = 0 < e.length), this.onDragStart())) } }, { key: "onPointerUp", value: function(t) { this.enable && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer !== t || (this.pointer = void 0, this.movedState = !1, this.tracerState = np, this.onDragEnd())) } }, { key: "onPointerMove", value: function(t) { if (this.enable && t.isDown) { var e = !this.bounds || this.bounds.contains(t.x, t.y),
                            i = this.pointer === t;!i && e || (i && !e ? this.onPointerUp(t) : (this.movedState || (this.movedState = t.x !== t.downX || t.y !== t.downY), this.movedState && this.onDrag())) } } }, { key: "dragCancel", value: function() { return this.tracerState === sp && this.onDragEnd(), this.pointer = void 0, this.tracerState = np, this } }, { key: "onDragStart", value: function() { this.emit("dragstart", this) } }, { key: "onDragEnd", value: function() { this.emit("dragend", this) } }, { key: "onDrag", value: function() { this.emit("drag", this) } }, { key: "preUpdate", value: function() {} }, { key: "postUpdate", value: function() {} }, { key: "startTicking", value: function() { O(C(r.prototype), "startTicking", this).call(this), this.scene.sys.events.on("preupdate", this.preUpdate, this), this.scene.sys.events.on("postupdate", this.postUpdate, this) } }, { key: "stopTicking", value: function() { O(C(r.prototype), "stopTicking", this).call(this), this.scene && (this.scene.sys.events.off("preupdate", this.preUpdate, this), this.scene.sys.events.off("postupdate", this.postUpdate, this)) } }, { key: "setRecongizedStateObject", value: function(t) { return this.recongizedState = t, this } }, { key: "state", get: function() { return this.recongizedState.state }, set: function(t) { this.recongizedState.state = t } }, { key: "cancel", value: function() { return this.state = rp, this } }]), r }(),
        np = 0,
        sp = 1,
        rp = "IDLE",
        op = Phaser.Utils.Objects.GetValue,
        ap = Phaser.Math.Distance.Between,
        hp = function() { w(o, ip); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: { enter: function() { n.stop(), n.tapsCount = 0, n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function() { var t = n.lastPointer;
                                    n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function() { n.start(), n.tapsCount = 0, n.emit("tappingstart", n, n.gameObject, n.lastPointer) } }, RECOGNIZED: { enter: function() { n.start(), n.emit("tap", n, n.gameObject, n.lastPointer), n.emit("".concat(n.tapsCount, "tap"), n, n.gameObject, n.lastPointer) } } }, init: function() { this.state = lp }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i } return k(o, [{ key: "resetFromJSON", value: function(t) { O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setHoldTime(op(t, "time", 250)), this.setTapInterval(op(t, "tapInterval", 200)), this.setDragThreshold(op(t, "threshold", 9)), this.setTapOffset(op(t, "tapOffset", 10)); var e = op(t, "taps", void 0); return void 0 !== e ? this.setTaps(e) : (this.setMaxTaps(op(t, "maxTaps", void 0)), this.setMinTaps(op(t, "minTaps", void 0))), this } }, { key: "onDragStart", value: function() { switch (this.state) {
                        case lp:
                            this.state = up; break;
                        case up:
                            var t = this.lastPointer;
                            ap(t.upX, t.upY, t.x, t.y) > this.tapOffset && (this.state = cp, this.state = up); break;
                        case cp:
                            this.state = up } } }, { key: "onDragEnd", value: function() { this.state === up && (this.tapsCount++, this.emit("tapping", this, this.gameObject, this.lastPointer), void 0 !== this.maxTaps && this.tapsCount === this.maxTaps && (this.state = cp)) } }, { key: "onDrag", value: function() { this.state !== lp && this.pointer.getDistance() > this.dragThreshold && (this.state = lp) } }, { key: "preUpdate", value: function(t) { if (this.isRunning && this.enable && this.state === up) { var e = this.lastPointer; if (e.isDown) t - e.downTime > this.holdTime && (this.state = lp);
                        else t - e.upTime > this.tapInterval && (void 0 === this.minTaps || this.tapsCount >= this.minTaps ? this.state = cp : this.state = lp) } } }, { key: "postUpdate", value: function() { this.isRunning && this.enable && this.state === cp && (this.state = lp) } }, { key: "isTapped", get: function() { return this.state === cp } }, { key: "setHoldTime", value: function(t) { return this.holdTime = t, this } }, { key: "setTapInterval", value: function(t) { return this.tapInterval = t, this } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }, { key: "setTapOffset", value: function(t) { return this.tapOffset = t, this } }, { key: "setMaxTaps", value: function(t) { return this.maxTaps = t, this } }, { key: "setMinTaps", value: function(t) { return this.minTaps = t, this } }, { key: "setTaps", value: function(t, e) { return void 0 === e && (e = t), this.setMinTaps(t).setMaxTaps(e), this } }]), o }(),
        lp = "IDLE",
        up = "BEGIN",
        cp = "RECOGNIZED",
        dp = Phaser.Utils.Objects.GetValue,
        fp = function() { w(o, ip); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: { enter: function() { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function() { var t = n.lastPointer;
                                    n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function() { n.start() }, exit: function() { n.stop() } }, RECOGNIZED: { enter: function() { n.emit("pressstart", n, n.gameObject, n.lastPointer) }, exit: function() { n.emit("pressend", n, n.gameObject, n.lastPointer) } } }, init: function() { this.state = pp }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i } return k(o, [{ key: "resetFromJSON", value: function(t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(dp(t, "threshold", 9)), this.setHoldTime(dp(t, "time", 251)), this } }, { key: "onDragStart", value: function() { this.state = vp, 0 === this.holdTime && (this.state = gp) } }, { key: "onDragEnd", value: function() { this.state = pp } }, { key: "onDrag", value: function() { this.state !== pp && this.pointer.getDistance() > this.dragThreshold && (this.state = pp) } }, { key: "preUpdate", value: function(t) { this.isRunning && this.enable && this.state === vp && t - this.pointer.downTime >= this.holdTime && (this.state = gp) } }, { key: "isPressed", get: function() { return this.state === gp } }, { key: "setHoldTime", value: function(t) { return this.holdTime = t, this } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }]), o }(),
        pp = "IDLE",
        vp = "BEGIN",
        gp = "RECOGNIZED",
        yp = Phaser.Utils.Objects.GetValue,
        mp = function() { w(o, ip); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: {}, BEGIN: { enter: function() { var t = n.pointer;
                                    n.startX = t.x, n.startY = t.y, n.startWorldX = t.worldX, n.startWorldY = t.worldY } }, RECOGNIZED: { enter: function() { n.emit("panstart", n, n.gameObject, n.lastPointer) }, exit: function() { var t = n.lastPointer;
                                    n.endX = t.x, n.endY = t.y, n.endWorldX = t.worldX, n.endWorldY = t.worldY, n.emit("panend", n, n.gameObject, n.lastPointer) } } }, init: function() { this.state = kp }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i } return k(o, [{ key: "resetFromJSON", value: function(t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(yp(t, "threshold", 10)), this } }, { key: "onDragStart", value: function() { this.state = bp, 0 === this.dragThreshold && (this.state = xp) } }, { key: "onDragEnd", value: function() { this.state = kp } }, { key: "onDrag", value: function() { switch (this.state) {
                        case bp:
                            this.pointer.getDistance() >= this.dragThreshold && (this.state = xp); break;
                        case xp:
                            var t = this.pointer.position,
                                e = this.pointer.prevPosition;
                            this.dx = t.x - e.x, this.dy = t.y - e.y; var i = this.pointer;
                            this.x = i.x, this.y = i.y, this.worldX = i.worldX, this.worldY = i.worldY, this.emit("pan", this, this.gameObject, this.lastPointer) } } }, { key: "isPanned", get: function() { return this.state === xp } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }]), o }(),
        kp = "IDLE",
        bp = "BEGIN",
        xp = "RECOGNIZED",
        Cp = Phaser.Math.Distance.Between,
        wp = Phaser.Math.Angle.Between,
        Sp = { getDt: function() { return Es(this.scene) }, getVelocity: function() { var t = this.pointer.position,
                    e = this.pointer.prevPosition; return Cp(e.x, e.y, t.x, t.y) / (.001 * this.getDt()) }, getVelocityX: function() { var t = this.pointer.position,
                    e = this.pointer.prevPosition; return Math.abs(t.x - e.x) / (.001 * this.getDt()) }, getVelocityY: function() { var t = this.pointer.position,
                    e = this.pointer.prevPosition; return Math.abs(t.y - e.y) / (.001 * this.getDt()) }, getVelocityAngle: function() { var t = this.pointer.position,
                    e = this.pointer.prevPosition; return wp(e.x, e.y, t.x, t.y) } },
        Pp = { "up&down": 0, "left&right": 1, "4dir": 2, "8dir": 3 },
        Tp = {},
        Op = Phaser.Utils.Objects.GetValue,
        Mp = Phaser.Math.RadToDeg,
        Ep = function() { w(o, ip); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: { enter: function() { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0 }, exit: function() { var t = n.lastPointer;
                                    n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY } }, BEGIN: { enter: function() { n.validDrag = !1 } }, RECOGNIZED: { enter: function() { n.start(), n.updateDirectionStates(), n.emit("swipe", n, n.gameObject, n.lastPointer) }, exit: function() { n.stop(), n.clearDirectionStates() } } }, init: function() { this.state = _p }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i.clearDirectionStates(), i } return k(o, [{ key: "resetFromJSON", value: function(t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(Op(t, "threshold", 10)), this.setVelocityThreshold(Op(t, "velocityThreshold", 1e3)), this.setDirectionMode(Op(t, "dir", "8dir")), this } }, { key: "onDragStart", value: function() { this.state = Rp } }, { key: "onDragEnd", value: function() { this.state = _p } }, { key: "onDrag", value: function() { this.state === Rp && (this.validDrag || (this.validDrag = 0 === this.dragThreshold || this.pointer.getDistance() >= this.dragThreshold), this.validDrag && this.dragVelocity > this.velocityThreshold && (this.state = Bp)) } }, { key: "postUpdate", value: function() { this.isRunning && this.enable && this.state === Bp && (this.state = _p) } }, { key: "isSwiped", get: function() { return this.state === Bp } }, { key: "dragVelocity", get: function() { var t; switch (this.dirMode) {
                        case 0:
                            t = this.getVelocityY(); break;
                        case 1:
                            t = this.getVelocityX(); break;
                        default:
                            t = this.getVelocity() } return t } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }, { key: "setVelocityThreshold", value: function(t) { return this.velocityThreshold = t, this } }, { key: "setDirectionMode", value: function(t) { return "string" == typeof t && (t = Pp[t]), this.dirMode = t, this } }, { key: "updateDirectionStates", value: function() { return function(t, e, i) { switch (void 0 === i ? i = {} : !0 === i && (i = Tp), i.left = !1, i.right = !1, i.up = !1, i.down = !1, t = (t + 360) % 360, e) {
                            case 0:
                                t < 180 ? i.down = !0 : i.up = !0; break;
                            case 1:
                                90 < t && t <= 270 ? i.left = !0 : i.right = !0; break;
                            case 2:
                                45 < t && t <= 135 ? i.down = !0 : 135 < t && t <= 225 ? i.left = !0 : 225 < t && t <= 315 ? i.up = !0 : i.right = !0; break;
                            case 3:
                                22.5 < t && t <= 67.5 ? (i.down = !0, i.right = !0) : 67.5 < t && t <= 112.5 ? i.down = !0 : 112.5 < t && t <= 157.5 ? (i.down = !0, i.left = !0) : 157.5 < t && t <= 202.5 ? i.left = !0 : 202.5 < t && t <= 247.5 ? (i.left = !0, i.up = !0) : 247.5 < t && t <= 292.5 ? i.up = !0 : (292.5 < t && t <= 337.5 && (i.up = !0), i.right = !0) } }(Mp(this.getVelocityAngle()), this.dirMode, this), this } }, { key: "clearDirectionStates", value: function() { return this.left = !1, this.right = !1, this.up = !1, this.down = !1, this } }]), o }();
    Object.assign(Ep.prototype, Sp); var _p = "IDLE",
        Rp = "BEGIN",
        Bp = "RECOGNIZED",
        Ip = Phaser.Utils.Objects.GetValue,
        Lp = Phaser.Utils.Array.SpliceOne,
        Ap = Phaser.Math.Distance.Between,
        jp = Phaser.Math.Angle.Between,
        Dp = function() {
            function n(t, e) { X(this, n); var i = t.input.manager.pointersTotal - 1;
                i < 2 && t.input.addPointer(2 - i), this.scene = t, this.setEventEmitter(Ip(e, "eventEmitter", void 0)), this._enable = void 0, this.pointers = [], this.movedState = {}, this.resetFromJSON(e), this.boot() } return k(n, [{ key: "resetFromJSON", value: function(t) { return this.setEnable(Ip(t, "enable", !0)), this.bounds = Ip(t, "bounds", void 0), this.tracerState = Yp, this.pointers.length = 0, at(this.movedState), this } }, { key: "boot", value: function() { this.scene.input.on("pointerdown", this.onPointerDown, this), this.scene.input.on("pointerup", this.onPointerUp, this), this.scene.input.on("gameout", this.dragCancel, this), this.scene.input.on("pointermove", this.onPointerMove, this), this.scene.sys.events.once("shutdown", this.destroy, this) } }, { key: "shutdown", value: function() { this.scene && (this.destroyEventEmitter(), this.pointers.length = 0, at(this.movedState), this.scene.input.off("pointerdown", this.onPointerDown, this), this.scene.input.off("pointerup", this.onPointerUp, this), this.scene.input.off("gameout", this.dragCancel, this), this.scene.input.off("pointermove", this.onPointerMove, this), this.scene.sys.events.off("shutdown", this.destroy, this), this.scene = void 0) } }, { key: "destroy", value: function() { this.shutdown() } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "onPointerDown", value: function(t) { if (this.enable && (2 !== this.pointers.length && (!this.bounds || this.bounds.contains(t.x, t.y)) && -1 === this.pointers.indexOf(t))) switch (this.movedState[t.id] = !1, this.pointers.push(t), this.tracerState) {
                        case Yp:
                            this.tracerState = Xp, this.onDrag1Start(); break;
                        case Xp:
                            this.tracerState = Wp, this.onDrag2Start() } } }, { key: "onPointerUp", value: function(t) { if (this.enable && (!this.bounds || this.bounds.contains(t.x, t.y))) { var e = this.pointers.indexOf(t); if (-1 !== e) switch (delete this.movedState[t.id], Lp(this.pointers, e), this.tracerState) {
                            case Xp:
                                this.tracerState = Yp, this.onDrag1End(); break;
                            case Wp:
                                this.tracerState = Xp, this.onDrag2End(), this.onDrag1Start() } } } }, { key: "onPointerMove", value: function(t) { if (this.enable && t.isDown) { var e = !this.bounds || this.bounds.contains(t.x, t.y),
                            i = -1 !== this.pointers.indexOf(t); if (i || !e)
                            if (i && !e) this.onPointerUp(t);
                            else if (this.movedState[t.id] || (this.movedState[t.id] = t.x !== t.downX || t.y !== t.downY), this.movedState[t.id]) switch (this.tracerState) {
                            case Xp:
                                this.onDrag1(); break;
                            case Wp:
                                this.onDrag2() } } } }, { key: "dragCancel", value: function() { return this.tracerState === Wp && this.onDrag2End(), this.pointers.length = 0, at(this.movedState), this.tracerState = Yp, this } }, { key: "onDrag1Start", value: function() { this.emit("drag1start", this) } }, { key: "onDrag1End", value: function() { this.emit("drag1end", this) } }, { key: "onDrag1", value: function() { this.emit("drag1", this) } }, { key: "onDrag2Start", value: function() { this.emit("drag2start", this) } }, { key: "onDrag2End", value: function() { this.emit("drag2end", this) } }, { key: "onDrag2", value: function() { this.emit("drag2", this) } }, { key: "distanceBetween", get: function() { if (this.tracerState !== Wp) return 0; var t = this.pointers[0],
                        e = this.pointers[1]; return Ap(t.x, t.y, e.x, e.y) } }, { key: "angleBetween", get: function() { if (this.tracerState !== Wp) return 0; var t = this.pointers[0],
                        e = this.pointers[1]; return jp(t.x, t.y, e.x, e.y) } }, { key: "drag1Vector", get: function() { var t = this.pointers[0]; if (t && this.movedState[t.id]) { var e = t.position,
                            i = t.prevPosition;
                        Fp.x = e.x - i.x, Fp.y = e.y - i.y } else Fp.x = 0, Fp.y = 0; return Fp } }, { key: "centerX", get: function() { if (this.tracerState !== Wp) return 0; var t = this.pointers[0].position,
                        e = this.pointers[1].position; return (t.x + e.x) / 2 } }, { key: "centerY", get: function() { if (this.tracerState !== Wp) return 0; var t = this.pointers[0].position,
                        e = this.pointers[1].position; return (t.y + e.y) / 2 } }, { key: "prevCenterX", get: function() { if (this.tracerState !== Wp) return 0; var t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position,
                        e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.x + e.x) / 2 } }, { key: "prevCenterY", get: function() { if (this.tracerState !== Wp) return 0; var t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position,
                        e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.y + e.y) / 2 } }, { key: "movementCenterX", get: function() { return this.centerX - this.prevCenterX } }, { key: "movementCenterY", get: function() { return this.centerY - this.prevCenterY } }, { key: "setRecongizedStateObject", value: function(t) { return this.recongizedState = t, this } }, { key: "state", get: function() { return this.recongizedState.state }, set: function(t) { this.recongizedState.state = t } }, { key: "cancel", value: function() { return this.state = Gp, this } }]), n }();
    Object.assign(Dp.prototype, ls);

    function zp(t, e, i, n) { return Kp(t, e, i, n), t.rotation += n, t } var Fp = {},
        Yp = 0,
        Xp = 1,
        Wp = 2,
        Gp = "IDLE",
        Vp = Phaser.Utils.Objects.GetValue,
        Up = function() { w(o, Dp); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: { enter: function() { n.prevDistance = void 0, n.scaleFactor = 1 } }, BEGIN: {}, RECOGNIZED: { enter: function() { n.emit("pinchstart", n) }, exit: function() { n.emit("pinchend", n) } } }, init: function() { this.state = Hp }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i } return k(o, [{ key: "resetFromJSON", value: function(t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(Vp(t, "threshold", 0)), this } }, { key: "onDrag2Start", value: function() { this.scaleFactor = 1, this.prevDistance = this.distanceBetween, this.state = Np, 0 === this.dragThreshold && (this.state = Jp) } }, { key: "onDrag2End", value: function() { this.state = Hp } }, { key: "onDrag2", value: function() { switch (this.state) {
                        case Np:
                            if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = this.distanceBetween;
                                this.scaleFactor = t / this.prevDistance, this.prevDistance = t, this.state = Jp } break;
                        case Jp:
                            t = this.distanceBetween;
                            this.scaleFactor = t / this.prevDistance, this.emit("pinch", this), this.prevDistance = t } } }, { key: "isPinched", get: function() { return this.state === Jp } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }]), o }(),
        Hp = "IDLE",
        Np = "BEGIN",
        Jp = "RECOGNIZED",
        Kp = Phaser.Math.RotateAround,
        Zp = {},
        qp = Phaser.Utils.Objects.GetValue,
        $p = Phaser.Math.Angle.WrapDegrees,
        Qp = Phaser.Math.Angle.ShortestBetween,
        tv = Phaser.Math.RadToDeg,
        ev = Phaser.Math.DegToRad,
        iv = function() { w(o, Dp); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = W(i = r.call(this, t, e)),
                    s = { states: { IDLE: { enter: function() { n.prevAngle = void 0, n.angle = 0 } }, BEGIN: {}, RECOGNIZED: { enter: function() { n.emit("rotatestart", n) }, exit: function() { n.emit("rotateend", n) } } }, init: function() { this.state = rv }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Yf(s)), i } return k(o, [{ key: "resetFromJSON", value: function(t) { return O(C(o.prototype), "resetFromJSON", this).call(this, t), this.setDragThreshold(qp(t, "threshold", 0)), this } }, { key: "onDrag2Start", value: function() { this.prevAngle = $p(tv(this.angleBetween)), this.state = ov, 0 === this.dragThreshold && (this.state = av) } }, { key: "onDrag2End", value: function() { this.state = rv } }, { key: "onDrag2", value: function() { switch (this.state) {
                        case ov:
                            if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = $p(tv(this.angleBetween));
                                this.angle = Qp(this.prevAngle, t), this.prevAngle = t, this.state = av } break;
                        case av:
                            t = $p(tv(this.angleBetween));
                            this.angle = Qp(this.prevAngle, t), this.prevAngle = t, this.emit("rotate", this) } } }, { key: "isRotated", get: function() { return this.state === av } }, { key: "rotation", get: function() { return ev(this.angle) } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }]), o }(),
        nv = { spinObject: function(t, e) { if (!this.isRotation) return this;
                void 0 === e && (e = this.pointers[0].camera); var i, n, s, r = this.movementCenterX,
                    o = this.movementCenterY,
                    a = (i = this.centerX, n = this.centerY, void 0 === (s = !0) ? s = {} : !0 === s && (s = Zp), e.getWorldPoint(i, n, s), s),
                    h = a.x,
                    l = a.y,
                    u = this.rotation; if (Array.isArray(t))
                    for (var c = t, d = 0, f = c.length; d < f; d++)(t = c[d]).x += r, t.y += o, zp(t, h, l, u);
                else t.x += r, t.y += o, zp(t, h, l, u); return this } };
    Object.assign(iv.prototype, nv);

    function sv(t, e) { return t.setInteractive(), t._childrenInteractive = { targetSizers: cv(e, "targets", [t]), eventEmitter: cv(e, "eventEmitter", t), eventNamePrefix: cv(e, "inputEventPrefix", "child.") },
            function(t) {!1 !== Nf(t, "down", void 0) && this.on("pointerdown", Jf, this) }.call(t, e),
            function(t) {!1 !== Kf(t, "up", void 0) && this.on("pointerup", Zf, this) }.call(t, e),
            function(t) {!1 !== qf(t, "over", void 0) && this.on("pointermove", $f, this).on("pointerover", $f, this).on("pointerout", Qf, this) }.call(t, e),
            function(t) { var e = tp(t, "click", void 0); if (!1 !== e) { void 0 === e && (e = {}), e.hasOwnProperty("threshold") || (e.threshold = 10); var s = this._childrenInteractive;
                    this._click = new If(this, e), this._click.on("click", function(t, e, i, n) { Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "click"), s.targetSizers, i.worldX, i.worldY, i, n) }, this) } }.call(t, e),
            function(t) { var e = hv(t, "tap", void 0); if (!1 !== e) { var n = this._childrenInteractive;
                    this._tap = new hp(this, e), this._tap.on("tap", function(t, e, i) { Wf(n.eventEmitter, "".concat(n.eventNamePrefix).concat(t.tapsCount, "tap"), n.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e),
            function(t) { var e = lv(t, "press", void 0); if (!1 !== e) { var n = this._childrenInteractive;
                    this._press = new fp(this, e), this._press.on("pressstart", function(t, e, i) { Wf(n.eventEmitter, "".concat(n.eventNamePrefix, "pressstart"), n.targetSizers, t.worldX, t.worldY, i) }, this).on("pressend", function(t, e, i) { Wf(n.eventEmitter, "".concat(n.eventNamePrefix, "pressend"), n.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e),
            function(t) { var e = uv(t, "swipe", void 0); if (!1 !== e) { void 0 === e && (e = {}), e.hasOwnProperty("dir") || (e.dir = "4dir"); var s = this._childrenInteractive;
                    this._swipe = new Ep(this, e), this._swipe.on("swipe", function(t, e, i) { var n = t.left ? "left" : t.right ? "right" : t.up ? "up" : "down";
                        Wf(s.eventEmitter, "".concat(s.eventNamePrefix, "swipe").concat(n), s.targetSizers, t.worldX, t.worldY, i) }, this) } }.call(t, e), t } var rv = "IDLE",
        ov = "BEGIN",
        av = "RECOGNIZED",
        hv = Phaser.Utils.Objects.GetValue,
        lv = Phaser.Utils.Objects.GetValue,
        uv = Phaser.Utils.Objects.GetValue,
        cv = Phaser.Utils.Objects.GetValue,
        dv = { getSizerConfig: Bc, getChildPrevState: function(t) { var e = Bc(t); return e.hasOwnProperty("prevState") || (e.prevState = {}), e.prevState }, pushIntoBounds: function(t) { return void 0 === t && (t = xh(this.scene)), this.left = Math.max(this.left, t.left), this.right = Math.min(this.right, t.right), this.top = Math.max(this.top, t.top), this.bottom = Math.min(this.bottom, t.bottom), this }, drawBounds: function(t, e) { var i, n, s, r, o, a = t.scene; if ("number" == typeof e) i = e;
                else { i = Ad(e, "color"), n = Ad(e, "lineWidth"); var h = Ad(e, "name", !1);
                    h && (s = Ad(h, "createTextCallback", Dd), r = Ad(h, "createTextCallbackScope", void 0), "string" == typeof(o = Ad(h, "align", "left-top")) && (o = Lc[o])) } if (void 0 === i && (i = 16777215), void 0 === n && (n = 1), s && !t.children) { t.children = new jd(a), t.once("destroy", function(t, e) { t.children.destroy(!e), t.children = void 0 }); var l = t.clear.bind(t);
                    t.clear = function() { l(), t.children.clear(!1, !0) } } for (var u, c, d = this.getAllShownChildren([this]), f = 0, p = d.length; f < p; f++)((u = d[f]).getBounds || void 0 !== u.width && void 0 !== u.height) && (zd = $s(u, zd), null != i && t.lineStyle(n, i).strokeRectShape(zd), u.name && s && (c = r ? s.call(r, a) : s(a)) && (c.setText(u.name), t.children.add(c), sd(c, zd.x, zd.y, zd.width, zd.height, o))); return this }, resolveWidth: hd, resolveChildrenWidth: function(t) { var e, i; for (var n in this.sizerChildren)(e = this.sizerChildren[n]) && e.isRexSizer && !e.ignoreLayout && (i = this.getExpandedChildWidth(e, t), i = e.resolveWidth(i), e.resolveChildrenWidth(i)) }, resolveHeight: ld, getChildWidth: function(t) { return t.isRexSizer ? Math.max(t.minWidth, t.childrenWidth) : void 0 !== t.minWidth ? t.minWidth : Zs(t) }, getChildHeight: function(t) { return t.isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : void 0 !== t.minHeight ? t.minHeight : qs(t) }, getExpandedChildWidth: function(t, e) { return e }, getExpandedChildHeight: function(t, e) { return e }, getChildrenWidth: function() { return 0 }, getChildrenHeight: function() { return 0 }, addChildrenMap: ad, addElement: ad, removeChildrenMap: function(t) { if ("object" === P(t)) { var e = t; for (var t in this.childrenMap)
                        if (this.childrenMap[t] === e) return delete this.childrenMap[t], this } return delete this.childrenMap[t], this }, getElement: function(t, e) { if ("string" == typeof t && (t = t.split(".")), 0 !== t.length) { var i = t.shift(),
                        n = null; if ("#" === i.charAt(0)) i = i.substring(1), n = this.getByName(i, e);
                    else if (-1 === i.indexOf("[")) this.childrenMap && (n = this.childrenMap[i]);
                    else { var s = i.match(Wd); if (null != s && this.childrenMap) { var r = this.childrenMap[s[1]];
                            r && (n = r[s[2]]) } } return 0 === t.length ? n : n && n.childrenMap ? n.getElement(t) : null } }, getAllChildrenSizers: function(t) { void 0 === t && (t = []); for (var e = t.length, i = this.getChildrenSizers(t), n = t.length, s = e; s < n; s++) i[s].getAllChildrenSizers(t); return t }, getChildrenSizers: function(t) { return void 0 === t && (t = []), t }, preLayout: ud, layout: function() { var t = this.scaleX,
                    e = this.scaleY,
                    i = 1 === t && 1 === e; return i || this.setScale(1), this.runLayout(), i || this.setScale(t, e), this }, runLayout: function(t, e, i) { if (this.ignoreLayout) return this; var n = !t; return n && this.preLayout(), e = this.resolveWidth(e), n && (this.resolveChildrenWidth(e), this.runWidthWrap(e)), i = this.resolveHeight(i), this.resize(e, i), this.sizerEventsEnable && void 0 === this.layoutedChildren && (this.layoutedChildren = []), this.layoutChildren(), this.layoutBackgrounds(), this.sizerEventsEnable && (this.emit("postlayout", this.layoutedChildren, this), this.layoutedChildren.length = 0), this.postLayout() }, layoutChildren: function() {}, runWidthWrap: cd, layoutBackgrounds: function() { if (void 0 !== this.backgroundChildren)
                    for (var t, e, i, n, s, r, o, a = this.backgroundChildren, h = this.left, l = this.top, u = this.width, c = this.height, d = 0, f = a.length; d < f; d++)(e = (t = a[d]).rexSizer).hidden || (i = e.padding, Id.call(this, t), n = h + i.left, s = l + i.top, r = u - i.left - i.right, o = c - i.top - i.bottom, Bd(t, r, o), Ld.call(this, t, n, s, r, o, Rf)) }, postLayout: function() { return this._anchor && this._anchor.updatePosition(), this }, setAnchor: function(t) { void 0 === t && (t = {}); var n = t.hasOwnProperty("width"),
                    s = t.hasOwnProperty("height"),
                    e = t.hasOwnProperty("onResizeCallback"); return !n && !s || e || (t.onResizeCallback = function(t, e, i) { n && i.setMinWidth(t), s && i.setMinHeight(e), i.layout() }), void 0 === this._anchor ? this._anchor = new Ud(this, t) : this._anchor.resetFromJSON(t), this }, isInTouching: function(t, e) { return void 0 === e && (e = this), Td(e, t) }, pointToChild: function(t, e, i, n, s) { if (Od(i) || (s = i, n = i = void 0), void 0 === s && (s = this.sizerChildren ? this.sizerChildren : this.children), Md(s)) { for (var r, o = 0, a = s.length; o < a; o++)
                        if (r = s[o], Ed(r, t, e, i, n)) return r } else
                    for (var h in s)
                        if (r = s[h], Ed(r, t, e, i, n)) return r; return null }, setDraggable: function(s, t) { var e = P(s); return "string" === e ? s = this.getElement(s) : void 0 !== s && "object" == e || (t = s, s = this), void 0 === t && (t = !0), s.input && s.input.hasOwnProperty("draggable") ? s.input.draggable = t : t && (s.setInteractive(), s.scene.input.setDraggable(s), s.on("drag", function(t, e, i) { var n = this.getTopmostSizer();
                    n.x += e - s.x, n.y += i - s.y, n.emit("sizer.drag", t, e, i) }, this).on("dragstart", function(t, e, i) { this.getTopmostSizer().emit("sizer.dragstart", t, e, i) }, this).on("dragend", function(t, e, i, n) { this.getTopmostSizer().emit("sizer.dragend", t, e, i, n) }, this)), this }, setChildrenInteractive: function(t) { return sv(this, t), this }, broadcastEvent: function() { for (var t = this.getAllChildren([this]), e = 0, i = t.length; e < i; e++) { var n = t[e];
                    n.emit.apply(n, arguments) } return this } };
    Object.assign(dv, Gd, Xd, { removeFromParentSizer: function() { var t = this.getParentSizer(); return t && t.remove(this), this } }, Ef, $d, af, vf, xf, Sf, Af, Ff, Hf, Tf, Vd); var fv = Phaser.Utils.Objects.GetValue,
        pv = function() { w(l, Kr); var h = T(l);

            function l(t, e, i, n, s, r) { var o;
                X(this, l), (o = h.call(this, t, e, i, 2, 2)).isRexSizer = !0, o.setMinSize(n, s), o.setName(fv(r, "name", "")), o.rexSizer = {}, o.space = {}, o.backgroundChildren = void 0, o.sizerChildren = void 0, o.childrenMap = {}, o.layoutedChildren = void 0; var a = fv(r, "anchor", void 0); return a && o.setAnchor(a), o.setInnerPadding(fv(r, "space", 0)), o.setDraggable(fv(r, "draggable", !1)), o.setSizerEventsEnable(fv(r, "sizerEvents", !1)), o.setDirty(!0), fv(r, "enableLayer", !1) && o.enableLayer(), o } return k(l, [{ key: "destroy", value: function(t) { if (this.scene) { if (t)
                            for (var e = this.getAllChildrenSizers([this]), i = 0, n = e.length; i < n; i++) e[i].sizerEventsEnable = !1;
                        O(C(l.prototype), "destroy", this).call(this, t), at(this.backgroundChildren), at(this.sizerChildren), this.childrenMap = void 0, this.space = void 0, this.rexSizer = void 0, this.layoutedChildren = void 0 } } }, { key: "setMinSize", value: function(t, e) { return this.setMinWidth(t).setMinHeight(e), this } }, { key: "setMinWidth", value: function(t) { return null == t && (t = 0), this.minWidth = t, this } }, { key: "setMinHeight", value: function(t) { return null == t && (t = 0), this.minHeight = t, this } }, { key: "setDirty", value: function(t) { return void 0 === t && (t = !0), this.dirty = t, this } }, { key: "setSizerEventsEnable", value: function(t) { return void 0 === t && (t = !0), this.sizerEventsEnable = t, this } }, { key: "ignoreLayout", get: function() { return this.rexSizer.hidden || !this.dirty } }, { key: "childrenWidth", get: function() { return void 0 === this._childrenWidth && (this._childrenWidth = this.getChildrenWidth()), this._childrenWidth } }, { key: "childrenHeight", get: function() { return void 0 === this._childrenHeight && (this._childrenHeight = this.getChildrenHeight()), this._childrenHeight } }, { key: "left", get: function() { return this.x - Zs(this) * this.originX }, set: function(t) { this.x += t - this.left } }, { key: "alignLeft", value: function(t) { return this.left = t, this } }, { key: "right", get: function() { return this.left + Zs(this) }, set: function(t) { this.x += t - this.right } }, { key: "alignRight", value: function(t) { return this.right = t, this } }, { key: "centerX", get: function() { return this.left + Zs(this) / 2 }, set: function(t) { this.x += t - this.centerX } }, { key: "alignCenterX", value: function(t) { return this.centerX = t, this } }, { key: "top", get: function() { return this.y - qs(this) * this.originY }, set: function(t) { this.y += t - this.top } }, { key: "alignTop", value: function(t) { return this.top = t, this } }, { key: "bottom", get: function() { return this.top + qs(this) }, set: function(t) { this.y += t - this.bottom } }, { key: "alignBottom", value: function(t) { return this.bottom = t, this } }, { key: "centerY", get: function() { return this.top + qs(this) / 2 }, set: function(t) { this.y += t - this.centerY } }, { key: "alignCenterY", value: function(t) { return this.centerY = t, this } }, { key: "innerLeft", get: function() { return this.left + this.space.left } }, { key: "innerRight", get: function() { return this.right - this.space.right } }, { key: "innerTop", get: function() { return this.top + this.space.top } }, { key: "innerBottom", get: function() { return this.bottom - this.space.bottom } }, { key: "innerWidth", get: function() { return this.width - this.space.left - this.space.right } }, { key: "innerHeight", get: function() { return this.height - this.space.top - this.space.bottom } }, { key: "minInnerWidth", get: function() { var t = this.minWidth - this.space.left - this.space.right; return Math.max(t, 0) } }, { key: "minInnerHeight", get: function() { var t = this.minHeight - this.space.top - this.space.bottom; return Math.max(t, 0) } }]), l }();
    Object.assign(pv.prototype, dv);

    function vv(t, e) { t.width < t.childrenWidth && console.warn("Layout width error: Parent=".concat(e.constructor.name, ", Child=").concat(t.constructor.name)), t.height < t.childrenHeight && console.warn("Layout height error: Parent=".concat(e.constructor.name, ", Child=").concat(t.constructor.name)) }

    function gv(t, e) { return this.isBackground(t) && wv(this.backgroundChildren, t), Sv.call(this, t, e), !e && this.sizerEventsEnable && (t.emit("sizer.remove", t, this), this.emit("remove", t, this)), this }

    function yv(t) { this.backgroundChildren && (this.backgroundChildren.length = 0); var e, i = !t && this.sizerEventsEnable; if (i && (e = this.getChildren([])), Pv.call(this, t), i)
            for (var n, s = 0, r = e.length; s < r; s++)(n = e[s]).emit("sizer.remove", n, this), this.emit("remove", n, this); return this } var mv = Phaser.Utils.Objects.IsPlainObject,
        kv = Phaser.Utils.Objects.GetValue,
        bv = Phaser.Display.Align.CENTER,
        xv = Phaser.Utils.String.UUID,
        Cv = { add: function(t, e, i, n, s, r, o, a, h) { od.call(this, t), mv(e) && (e = kv(l = e, "key", void 0), i = kv(l, "align", bv), a = kv(l, "offsetX", 0), h = kv(l, "offsetY", 0), n = kv(l, "padding", 0), s = kv(l, "expand", !0), t.isRexSizer || (r = kv(l, "minWidth", t._minWidth), o = kv(l, "minHeight", t._minHeighted))); var l, u = void 0 !== e; return u || (e = xv()), "string" == typeof i && (i = Lc[i]), void 0 === i && (i = bv), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === n && (n = 0), void 0 === s && (s = !0), t.isRexSizer || (void 0 === r && (r = t._minWidth), void 0 === o && (o = t._minHeight)), (l = this.getSizerConfig(t)).align = i, l.alignOffsetX = a, l.alignOffsetY = h, l.padding = rd(n), mv(s) ? (l.expandWidth = kv(s, "width", !1), l.expandHeight = kv(s, "height", !1)) : (l.expandWidth = s, l.expandHeight = s), t.isRexSizer || (l.expandWidth && (t.minWidth = void 0 === r ? Zs(t) : r), l.expandHeight && (t.minHeight = void 0 === o ? qs(t) : o)), this.sizerChildren.hasOwnProperty(e) && this.sizerChildren[e].destroy(), this.sizerChildren[e] = t, u && this.addChildrenMap(e, t), this } },
        wv = Phaser.Utils.Array.Remove,
        Sv = Kr.prototype.remove,
        Pv = Kr.prototype.clear,
        Tv = { remove: function(t, e) { var i; if ("string" == typeof t) { if (i = t, !(t = this.sizerChildren[i])) return this } else { if (this.getParentSizer(t) !== this) return this;
                    i = this.childToKey(t) } return i && (delete this.sizerChildren[i], this.childrenMap.hasOwnProperty(i) && delete this.childrenMap[i]), gv.call(this, t, e), this }, removeAll: function(t) { for (var e in this.sizerChildren) this.remove(e, t); return this }, clear: function(t) { for (var e in this.sizerChildren) delete this.sizerChildren[e], this.childrenMap.hasOwnProperty(e) && delete this.childrenMap[e]; return yv.call(this, t), this } },
        Ov = { getChildrenWidth: function() { if (this.rexSizer.hidden) return 0; var t, e, i, n = 0,
                    s = this.sizerChildren; for (var r in s) e = (t = s[r]).rexSizer.padding, i = this.getChildWidth(t) + e.left + e.right, n = Math.max(i, n); return n + this.space.left + this.space.right }, getChildrenHeight: function() { if (this.rexSizer.hidden) return 0; var t, e, i, n = 0,
                    s = this.sizerChildren; for (var r in s) i = (t = s[r]).isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : void 0 !== t.minHeight ? t.minHeight : qs(t), i += (e = t.rexSizer.padding).top + e.bottom, n = Math.max(i, n); return n + this.space.top + this.space.bottom }, getExpandedChildWidth: function(t, e) { var i;
                void 0 === e && (e = this.width); var n = t.rexSizer; if (n.expandWidth) { var s = e - this.space.left - this.space.right,
                        r = n.padding;
                    i = s - r.left - r.right } return i }, getExpandedChildHeight: function(t, e) { var i;
                void 0 === e && (e = this.height); var n = t.rexSizer; if (n.expandHeight) { var s = e - this.space.top - this.space.bottom,
                        r = n.padding;
                    i = s - r.top - r.bottom } return i }, getChildrenSizers: function(t) { void 0 === t && (t = []); var e, i = this.sizerChildren; for (var n in i)(e = i[n]).isRexSizer && t.push(e); return t }, layoutChildren: function() { var t, e, i, n, s, r, o, a, h, l = this.innerLeft,
                    u = this.innerTop,
                    c = this.innerWidth,
                    d = this.innerHeight,
                    f = this.sizerChildren; for (var p in f)(t = f[p]).rexSizer.hidden || (i = (e = t.rexSizer).padding, Id.call(this, t), t.isRexSizer ? (t.runLayout(this, this.getExpandedChildWidth(t), this.getExpandedChildHeight(t)), vv(t, this)) : (h = a = void 0, e.expandWidth && (a = c - i.left - i.right), e.expandHeight && (h = d - i.top - i.bottom), Bd(t, a, h)), n = l + i.left, r = c - i.left - i.right, s = u + i.top, o = d - i.top - i.bottom, Ld.call(this, t, n, s, r, o, e.align, e.alignOffsetX, e.alignOffsetY)) } };
    Object.assign(Ov, Cv, Tv);

    function Mv(t, e) { if (Array.isArray(t)) return t.indexOf(e); for (var i in t)
            if (t[i] === e) return i;
        return null } var Ev = Phaser.Utils.Objects.IsPlainObject,
        _v = Phaser.Utils.Objects.GetValue,
        Rv = function() { w(h, pv); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), Ev(e) ? (e = _v(r = e, "x", 0), i = _v(r, "y", 0), n = _v(r, "width", void 0), s = _v(r, "height", void 0)) : Ev(n) && (n = _v(r = n, "width", void 0), s = _v(r, "height", void 0)), (o = a.call(this, t, e, i, n, s, r)).type = "rexOverlapSizer", o.sizerChildren = {}, o.addChildrenMap("items", o.sizerChildren), o } return k(h, [{ key: "childToKey", value: function(t) { if ("string" != typeof t) return Mv(this.sizerChildren, t); var e = t; return this.sizerChildren.hasOwnPropery(e) ? e : null } }]), h }();
    Object.assign(Rv.prototype, Ov);

    function Bv(t, e, i) { var n = t.width / 2; return zv(n, n, e, i) <= n }

    function Iv(t, e, i) { if (this.enable && t.isDown) { var n = this.sizerChildren.knob; if (Bv(n, e, i)) { var s = n.width / 2,
                    r = n.startAngle,
                    o = Fv(s, s, e, i),
                    a = n.anticlockwise ? r - o : o - r,
                    h = Yv(a) / (2 * Math.PI);
                this.stopEaseValue(), 0 === this.easeValueDuration || Math.abs(this.value - h) < .1 ? this.value = h : this.easeValueTo(h) } } }

    function Lv(t, e, i) { if (this.enable && !this.panPointer) { var n = this.sizerChildren.knob;
            Bv(n, e, i) && Gv.call(this, t) } }

    function Av(t, e, i) { if (this.enable && t.isDown) { var n = this.sizerChildren.knob; switch (this.panState) {
                case Hv:
                    Bv(n, e, i) && Gv.call(this, t); break;
                case Nv:
                    Bv(n, e, i) ? Uv.call(this) : Vv.call(this) } } }

    function jv(t) { this.enable && this.panPointer === t && Vv.call(this) }

    function Dv(t) { return void 0 === t && (t = this.value), this.textFormatCallbackScope ? this.textFormatCallback(t) : this.textFormatCallback.call(this.textFormatCallbackScope, t) } var zv = Phaser.Math.Distance.Between,
        Fv = Phaser.Math.Angle.Between,
        Yv = Phaser.Math.Angle.Normalize,
        Xv = Phaser.Math.Angle.Between,
        Wv = Phaser.Math.Angle.Wrap,
        Gv = function(t) { this.panPointer = t, this.panState = Nv },
        Vv = function() { this.panPointer = void 0, this.panState = Hv },
        Uv = function() { var t = this.panPointer.prevPosition,
                e = this.panPointer.position,
                i = this.sizerChildren.knob,
                n = Xv(i.x, i.y, t.x, t.y),
                s = Xv(i.x, i.y, e.x, e.y),
                r = i.anticlockwise ? n - s : s - n,
                o = Wv(r) / (2 * Math.PI);
            this.stopEaseValue(), this.value += o },
        Hv = 0,
        Nv = 1,
        Jv = { setTextFormatCallback: function(t, e) { return this.textFormatCallback = t, this.textFormatCallbackScope = e, this }, getFormatText: Dv, updateText: function(t) { var e = this.sizerChildren.text; return e && this.textFormatCallback && (e.setText(Dv.call(this, t)), e.layout && e.layout()), this } },
        Kv = Phaser.Utils.Objects.GetValue,
        Zv = Phaser.Math.Snap.To,
        qv = function() { w(h, Yu(Rv)); var a = T(h);

            function h(t, e) { var i;
                X(this, h), void 0 === e && (e = {}), (i = a.call(this, t, e)).type = "rexKnob", i.bootProgressBase(e); var n = Kv(e, "background", void 0),
                    s = Kv(e, "text", void 0);
                n && i.addBackground(n), s && (e.textColor = void 0, e.textStrokeColor = void 0, i.setTextFormatCallback(Kv(e, "textFormatCallback", void 0), Kv(e, "textFormatCallbackScope", void 0))); var r = new Pc(t, e);
                r.setDepth(Kv(e, "knobDepth", 0)), r._value = -1, t.add.existing(r), i.add(r, "knob"), s && (i.add(s, "text", "center", 0, !1), t.children.moveBelow(r, s)), i.addChildrenMap("background", n), i.addChildrenMap("knob", r), i.addChildrenMap("text", s), i.setEnable(Kv(e, "enable", void 0)), i.setGap(Kv(e, "gap", void 0)), i.setValue(Kv(e, "value", 0), Kv(e, "min", void 0), Kv(e, "max", void 0)); var o = Kv(e, "input", 0); switch ("string" == typeof o && (o = $v[o]), o) {
                    case 0:
                        (function() { this.sizerChildren.knob.on("pointerdown", Lv, this).on("pointermove", Av, this).on("pointerup", jv, this).setInteractive(), this.panPointer = void 0, this.panState = Hv }).call(W(i)); break;
                    case 1:
                        (function() { this.sizerChildren.knob.on("pointerdown", Iv, this).on("pointermove", Iv, this).setInteractive() }).call(W(i)) } return i } return k(h, [{ key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setGap", value: function(t) { return this.gap = t, this } }, { key: "value", get: function() { return this.sizerChildren.knob.value }, set: function(t) { void 0 !== this.gap && (t = Zv(t, this.gap)); var e = this.value;
                    this.sizerChildren.knob.value = t; var i = this.value;
                    e !== i && (this.updateText(), this.eventEmitter.emit("valuechange", i, e, this.eventEmitter)) } }]), h }(),
        $v = { pan: 0, drag: 0, click: 1, none: -1 };
    Object.assign(qv.prototype, Jv), p.register("knob", function(t) { var e = new qv(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Knob", qv);

    function Qv() { for (var t = this.getShapes(), e = 0, i = t.length; e < i; e++) t[e].lineStyle().fillStyle() } var tg = { arc: rc, circle: oc, curve: ac, ellipse: hc, line: lc, lines: vc, rectangle: yc, triangle: kc },
        eg = Phaser.Utils.Objects.GetValue,
        ig = Phaser.Utils.Objects.IsPlainObject,
        ng = { createShape: function(t, e) { var i = new tg[t](); return e && i.setName(e), i }, buildShapes: function(t) { var e = eg(t, "create", void 0); if (ig(e)) { var i = e; for (var n in i) { var s = i[n]; switch (P(s)) {
                            case "number":
                                for (var r = 0; r < s; r++) this.addShape(this.createShape(n)); break;
                            case "string":
                                this.addShape(this.createShape(n, s)); break;
                            default:
                                for (var o = s, a = (r = 0, o.length); r < a; r++) this.addShape(this.createShape(n, o[r])) } } } else if (Array.isArray(e))
                    for (r = 0, a = (i = e).length; r < a; r++) { var h = i[r];
                        this.addShape(this.createShape(h.type, h.name)) } else "function" == typeof e && e.call(this);
                this.setUpdateShapesCallback(eg(t, "update")) }, setUpdateShapesCallback: function(t) { return void 0 === t && (t = Qv), this.dirty = this.dirty || this.updateCallback !== t, this.updateCallback = t, this }, updateShapes: function() { this.updateCallback.call(this) } },
        sg = Phaser.Utils.Objects.GetValue,
        rg = Phaser.Utils.Objects.IsPlainObject,
        og = function() { w(h, $u); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), rg(e) && (e = sg(r = e, "x", 0), i = sg(r, "y", 0), n = sg(r, "width", 2), s = sg(r, "height", 2)), (o = a.call(this, t, e, i, n, s)).type = sg(r, "type", "rexCustomShapes"), o.buildShapes(r), o } return k(h) }();
    Object.assign(og.prototype, ng), p.register("customShapes", function(t, e, i, n, s) { var r = new og(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.CustomShapes", og); var ag = Phaser.Utils.Objects.GetValue,
        hg = Phaser.Utils.Objects.IsPlainObject,
        lg = function() { w(h, Yu(og)); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), hg(e) && (e = ag(r = e, "x", 0), i = ag(r, "y", 0), n = ag(r, "width", 2), s = ag(r, "height", 2)), void 0 === r && (r = {}), r.type || (r.type = "rexCustomProgress"), (o = a.call(this, t, e, i, n, s, r)).bootProgressBase(r), o.setValue(value), o } return k(h, [{ key: "centerX", get: function() { return this.width / 2 } }, { key: "centerY", get: function() { return this.height / 2 } }, { key: "radius", get: function() { return Math.min(this.centerX, this.centerY) } }]), h }();
    p.register("customProgress", function(t, e, i, n, s) { var r = new lg(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.CustomProgress", lg);

    function ug(t, e, i, n, s) { switch (this.clear().fillStyle(16777215), this.shape) {
            case 1:
                var r = Math.min(t, e) / 2;
                this.fillCircle(-t * (n - .5), -e * (s - .5), r + i); break;
            default:
                this.fillRect(-t * n - i, -e * s - i, t + 2 * i, e + 2 * i) } }

    function cg(t, e, i, n, s, r) { var o, a;
        null == i && (i = "__BASE"), r || (void 0 === (a = r) && (a = ","), r = "__BASE" === (o = i) ? function(t, e) { return "".concat(t).concat(a).concat(e) } : function(t, e) { return "".concat(o, "_").concat(t).concat(a).concat(e) }); for (var h, l, u, c = t.sys.textures.get(e), d = c.source[0].isRenderTexture, f = "object" === P(i) ? i : c.get(i), p = f.width, v = f.height, g = p / n, y = v / s, m = 0, k = 0, b = 0; b < s; b++) { for (var x = m = 0; x < n; x++) u = r(x, b), h = m + f.cutX, l = d ? v - k - y + f.cutY : k + f.cutY, c.add(u, 0, h, l, g, y), m += g;
            k += y } return { getFrameNameCallback: r, cellWidth: g, cellHeight: y, columns: n, rows: s } } var dg = Phaser.Utils.Objects.IsPlainObject,
        fg = Phaser.Utils.Objects.GetValue,
        pg = { out: 0, in: 1 },
        vg = { setTransitionDirection: function(t) { return "string" == typeof t && (t = pg[t]), this.dir = t, this }, setDuration: function(t) { return this.duration = t, this }, setEaseFunction: function(t) { return this.easeFunction = t, this }, setNextTexture: function(t, e) { return this.nextImage.setTexture(t, e), this }, transit: function(t, e) { if (this.isRunning && (this.ignoreCompleteEvent = !0, this.stop(), this.ignoreCompleteEvent = !1), dg(t)) { var i = t;
                    t = fg(i, "key", void 0), e = fg(i, "frame", void 0), this.setDuration(fg(i, "duration", this.duration)).setEaseFunction(fg(i, "ease", this.easeFunction)).setTransitionDirection(fg(i, "dir", this.dir)); var n = fg(i, "mask", void 0);
                    n && this.setMaskGameObject(n), this.setMaskEnable(!0 === n); var s = fg(i, "onStart", void 0),
                        r = fg(i, "onProgress", void 0),
                        o = fg(i, "onComplete", void 0);
                    void 0 === s && void 0 === r && void 0 === o || this.setTransitionStartCallback(s, fg(i, "onStartScope", void 0)).setTransitionProgressCallback(r, fg(i, "onProgressScope", void 0)).setTransitionCompleteCallback(o, fg(i, "onCompleteScope", void 0)) } return this.setNextTexture(t, e), this.start(), this }, start: function() { return void 0 === this.easeValueTask && (this.easeValueTask = new Au(this, { eventEmitter: null })), this.easeValueTask.restart({ key: "t", from: 0, to: 1, duration: this.duration, ease: this.easeFunction }), this }, pause: function() { return this.easeValueTask && this.easeValueTask.pause(), this }, resume: function() { return this.easeValueTask && this.easeValueTask.resume(), this }, stop: function() { return this.easeValueTask && this.easeValueTask.stop(), this.setT(1), this } },
        gg = Phaser.GameObjects.Graphics,
        yg = function() { w(r, gg); var s = T(r);

            function r(t, e, i) { var n; return X(this, r), void 0 === e && (e = 0), "string" == typeof e && (e = mg[e]), void 0 === i && (i = 0), (n = s.call(this, t.scene)).parent = t, n.shape = e, n.padding = i, n.setPosition().resize().setVisible(!1), n } return k(r, [{ key: "destroy", value: function() { return this.parent = void 0, O(C(r.prototype), "destroy", this).call(this), this } }, { key: "setPosition", value: function(t, e) { var i = this.parent; return void 0 === t && (t = i.x), void 0 === e && (e = i.y), O(C(r.prototype), "setPosition", this).call(this, t, e), this } }, { key: "resize", value: function(t, e, i) { var n = this.parent; return void 0 === t && (t = n.width), void 0 === e && (e = n.height), void 0 === i && (i = this.padding), this.widthSave === t && this.heightSave === e && this.paddingSave === i || (this.widthSave = t, this.heightSave = e, this.paddingSave = i, this.originXSave = n.originX, this.originYSave = n.originY, ug.call(this, t, e, i, n.originX, n.originY)), this } }, { key: "setOrigin", value: function(t, e) { void 0 === e && (e = t); var i = this.parent; return void 0 === t && (t = i.originX), void 0 === e && (e = i.originY), this.originXSave === t && this.originYSave === e || (this.originXSave = t, this.originYSave = e, ug.call(this, this.widthSave, this.heightSave, this.paddingSave, t, e)), this } }]), r }(),
        mg = { rectangle: 0, circle: 1 },
        kg = { setMaskGameObject: function(t) { if (!t) return this.removeMaskGameObject(), this; if (this.maskGameObject) { if (!0 === t && this.maskGameObject instanceof yg) return this; if (this.maskGameObject === t) return this;
                    this.removeMaskGameObject() } return !0 === t && (t = new yg(this)), this.maskGameObject = t, this.maskGameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(!1), this.addLocal(this.maskGameObject), this.childrenMask = this.maskGameObject.createGeometryMask(), this }, removeMaskGameObject: function() { return this.backImage.clearMask(), this.frontImage.clearMask(), this.childrenMask = void 0, this.remove(this.maskGameObject, !0), this.maskGameObject = void 0, this }, setImageMaskEnable: function(t, e, i) { return void 0 === e && (e = !0), this.childrenMask || this.setMaskGameObject(!0), e ? (t.setMask(this.childrenMask), i && this.childrenMask.setInvertAlpha()) : t.clearMask(), this }, setCurrentImageMaskEnable: function(t, e) { return this.setImageMaskEnable(this.currentImage, t, e), this }, setNextImageMaskEnable: function(t, e) { return this.setImageMaskEnable(this.nextImage, t, e), this }, setCellImagesMaskEnable: function(t, e) { for (var i = this.getCellImages(), n = 0, s = i.length; n < s; n++) this.setImageMaskEnable(i[n], t, e); return this }, setMaskEnable: function(t, e) { return this.setImageMaskEnable(this.backImage, t, e), this.setImageMaskEnable(this.frontImage, t, e), this.setCellImagesMaskEnable(t, e), this } },
        bg = Phaser.Utils.Objects.GetValue,
        xg = Phaser.GameObjects.Image,
        Cg = Phaser.Utils.Objects.IsPlainObject,
        wg = Phaser.Math.RotateAround,
        Sg = { gridCutImage: function(t, e, i, n) { void 0 === n && (n = {}), n.objectPool = this.imagesPool; for (var s, r = function(t, e, i, n) { Cg(e) && (e = bg(n = e, "columns", 1), i = bg(n, "rows", 1)); var s = bg(n, "onCreateImage"); if (!s) { var r = bg(n, "ImageClass", xg);
                            s = function(t, e, i) { return new r(t, 0, 0, e, i) } } for (var o = bg(n, "originX", .5), a = bg(n, "originY", .5), h = bg(n, "add", !0), l = bg(n, "align", h), u = bg(n, "objectPool", void 0), c = t.scene, d = t.texture, f = t.frame, p = cg(c, d, f, e, i), v = p.getFrameNameCallback, g = t.scaleX, y = t.scaleY, m = t.rotation, k = t.getTopLeft(), b = k.x, x = k.y, C = [], w = p.cellWidth * g, S = p.cellHeight * y, P = 0; P < i; P++)
                            for (var T = 0; T < e; T++) { var O, M = v(T, P);
                                O = u && 0 < u.length ? u.pop().setTexture(d, M) : s(c, d, M), h && c.add.existing(O); var E = b + w * T + o * w,
                                    _ = x + S * P + a * S;
                                l && (O.setOrigin(o, a).setPosition(E, _).setScale(g, y).setRotation(m), wg(O, b, x, m)), C.push(O) }
                        return C }(t, e, i, n), o = 0, a = r.length; o < a; o++)(s = r[o]).setVisible(!0), this.add(s); return this.cellImages = r, this.setChildLocalVisible(t, !1), r }, gridCutCurrentImage: function(t, e, i) { return this.gridCutImage(this.currentImage, t, e, i) }, gridCutNextImage: function(t, e, i) { return this.gridCutImage(this.nextImage, t, e, i) }, getCellImages: function() { return this.cellImages }, freeCellImages: function() { var t; if (0 === this.cellImages.length) return this; for (var e, i, n = this.cellImages[0].texture, s = this.cellImages, r = 0, o = s.length; r < o; r++) e = s[r], this.setChildLocalAlpha(e, 1).setChildLocalScale(e, 1).setChildLocalVisible(e, !1), e.clearMask(), i = e.frame.name, e.setTexture(), n.remove(i); return (t = this.imagesPool).push.apply(t, M(s)), s.length = 0, this } },
        Pg = {};
    Object.assign(Pg, { setTransitionStartCallback: function(t, e) { return this.onStartCallback = t, this.onStartCallbackScope = e, this }, setTransitionProgressCallback: function(t, e) { return this.onProgressCallback = t, this.onProgressCallbackScope = e, this }, setTransitionCompleteCallback: function(t, e) { return this.onCompleteCallback = t, this.onCompleteCallbackScope = e, this } }, vg, kg, Sg, { setFlipX: function(t) { return this.flipX = t, this }, setFlipY: function(t) { return this.flipY = t, this }, toggleFlipX: function() { return this.flipX = !this.flipX, this }, toggleFlipY: function() { return this.flipY = !this.flipY, this }, setFlip: function(t, e) { return this.flipX = t, this.flipY = e, this }, resetFlip: function() { return this.flipX = !1, this.flipY = !1, this } });

    function Tg() {}

    function Og(t, e, i, n) { t.setChildLocalAlpha(e, 1 - n).setChildLocalAlpha(i, n) }

    function Mg(t, e) { t.setChildLocalAlpha(e, 1) } var Eg = Phaser.Utils.Objects.IsPlainObject,
        _g = Phaser.Utils.Objects.GetValue,
        Rg = Phaser.Math.Clamp,
        Bg = function() { w(y, Kr); var g = T(y);

            function y(t, e, i, n, s, r) { var o;
                X(this, y), Eg(e) ? (e = _g(r = e, "x", 0), i = _g(r, "y", 0), n = _g(r, "key", void 0), s = _g(r, "frame", void 0)) : Eg(s) && (r = s, s = void 0); var a = _g(r, "back", void 0),
                    h = _g(r, "front", void 0);
                a = a || t.add.image(e, i, n, s), h = h || t.add.image(e, i, n, s); var l = _g(r, "width", h.width),
                    u = _g(r, "height", h.height);
                o = g.call(this, t, e, i, l, u), a.setVisible(!1), o.addMultiple([a, h]), o.type = "rexTransitionImage", o.backImage = a, o.frontImage = h, o.maskGameObject = void 0, o.cellImages = [], o.imagesPool = []; var c = _g(r, "onStart", void 0),
                    d = _g(r, "onProgress", void 0),
                    f = _g(r, "onComplete", void 0),
                    p = _g(r, "dir", 0);
                void 0 === c && void 0 === d && void 0 === f && (c = Tg, d = Og, f = Mg, p = 0), o.setTransitionStartCallback(c, _g(r, "onStartScope", void 0)).setTransitionProgressCallback(d, _g(r, "onProgressScope", void 0)).setTransitionCompleteCallback(f, _g(r, "onCompleteScope", void 0)).setTransitionDirection(p).setDuration(_g(r, "duration", 1e3)).setEaseFunction(_g(r, "ease", "Linear")); var v = _g(r, "mask", void 0); return v && o.setMaskGameObject(v), o.setMaskEnable(!1), o.ignoreCompleteEvent = !1, o } return k(y, [{ key: "destroy", value: function(t) { this.scene && (this.childrenMask && (this.childrenMask.destroy(), this.childrenMask = void 0), this.backImage = void 0, this.frontImage = void 0, this.maskGameObject = void 0, this.cellImages.length = 0, this.imagesPool.length = 0, O(C(y.prototype), "destroy", this).call(this, t), this.onStartCallback = void 0, this.onStartCallbackScope = void 0, this.onProgressCallback = void 0, this.onProgressCallbackScope = void 0, this.onCompleteCallback = void 0, this.onCompleteCallbackScope = void 0, this.easeValueTask = void 0) } }, { key: "currentImage", get: function() { return 0 === this.dir ? this.frontImage : this.backImage } }, { key: "nextImage", get: function() { return 0 === this.dir ? this.backImage : this.frontImage } }, { key: "texture", get: function() { return this.nextImage.texture } }, { key: "frame", get: function() { return this.nextImage.frame } }, { key: "flipX", get: function() { return this._flipX }, set: function(t) { this._flipX !== t && (this._flipX = t, this.backImage.setFlipX(t), this.frontImage.setFlipX(t)) } }, { key: "flipY", get: function() { return this._flipY }, set: function(t) { this._flipY !== t && (this._flipY = t, this.backImage.setFlipY(t), this.frontImage.setFlipY(t)) } }, { key: "t", get: function() { return this._t }, set: function(t) { if (t = Rg(t, 0, 1), this._t !== t) { this._t = t; var e = this.currentImage,
                            i = this.nextImage; if (0 === t && (this.setChildVisible(this.frontImage, !0).setChildVisible(this.backImage, !0), Ig(this.onStartCallback, this.onStartCallbackScope, this, e, i, t)), Ig(this.onProgressCallback, this.onProgressCallbackScope, this, e, i, t), 1 === t) { Ig(this.onCompleteCallback, this.onCompleteCallbackScope, this, e, i, t); var n = i.texture.key,
                                s = i.frame.name;
                            this.frontImage.setTexture(n, s), this.backImage.setTexture(n, s), this.setChildVisible(this.frontImage, !0).setChildVisible(this.backImage, !1).setMaskEnable(!1).freeCellImages() }
                        1 !== t || this.ignoreCompleteEvent || this.emit("complete") } } }, { key: "setT", value: function(t) { return this.t = t, this } }, { key: "isRunning", get: function() { return !!this.easeValueTask && this.easeValueTask.isRunning } }, { key: "setOrigin", value: function(t, e) { return O(C(y.prototype), "setOrigin", this).call(this, t, e), this.backImage.setOrigin(t, e), this.frontImage.setOrigin(t, e), this.maskGameObject && this.maskGameObject.setOrigin(t, e), this } }, { key: "setTexture", value: function(t, e) { return this.frontImage.setTexture(t, e), this.backImage.setTexture(t, e).setVisible(!1), this } }]), y }(),
        Ig = function(t, e, i, n, s, r) { t && (e ? t.call(e, i, n, s, r) : t(i, n, s, r)) };
    Object.assign(Bg.prototype, Pg), p.register("transitionImage", function(t, e, i, n, s) { var r = new Bg(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.TransitionImage", Bg); var Lg = Phaser.GameObjects.Rectangle,
        Ag = function() { w(r, Lg); var s = T(r);

            function r(t, e, i) { var n; return X(this, r), (n = s.call(this, t, 0, 0, 2, 2, e, 1)).setAlpha(i), n.setScrollFactor(0), n.boot(), n } return k(r, [{ key: "boot", value: function() { this.scene.sys.events.on("prerender", this.resize, this) } }, { key: "destroy", value: function(t) { this.scene && (this.scene.sys.events.off("prerender", this.resize, this), O(C(r.prototype), "destroy", this).call(this, t)) } }, { key: "tint", get: function() { return this.fillColor }, set: function(t) { this.setFillStyle(t, this.fillAlpha) } }, { key: "resize", value: function() { var t = this.scene,
                        e = t.sys.scale.gameSize,
                        i = t.sys.cameras.main,
                        n = e.width,
                        s = e.height,
                        r = 1 / i.zoom,
                        o = n / 2,
                        a = s / 2,
                        h = n * r,
                        l = s * r;
                    this.x === o && this.y === a || this.setPosition(o, a), this.width === h && this.height === l || this.setSize(h, l).setOrigin(.5) } }]), r }();
    p.register("fullWindowRectangle", function(t, e) { var i = new Ag(this.scene, t, e); return this.scene.add.existing(i), i }), j(window, "RexPlugins.UI.FullWindowRectangle", Ag); var jg = Phaser.Utils.Objects.GetValue,
        Dg = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, { eventEmitter: !1 })).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.setHitAreaMode(jg(t, "hitAreaMode", 0)), this.setEnable(jg(t, "enable", !0)), this } }, { key: "boot", value: function() { this.parent.on("pointerdown", function(t, e, i, n) { n.stopPropagation() }).on("pointerup", function(t, e, i, n) { n.stopPropagation() }).on("pointermove", function(t, e, i, n) { n.stopPropagation() }).on("pointerover", function(t, e, i, n) { n.stopPropagation() }).on("pointerout", function(t, e) { e.stopPropagation() }) } }, { key: "setHitAreaMode", value: function(t) { "string" == typeof t && (t = zg[t]); var e = this.parent; return e.input && e.removeInteractive(), 0 === t ? e.setInteractive() : e.setInteractive({ hitArea: {}, hitAreaCallback: function() { return !0 } }), this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), t ? this.parent.setInteractive() : this.parent.disableInteractive(), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }]), s }(),
        zg = { default: 0, fullWindow: 1 },
        Fg = Phaser.Utils.Objects.GetValue,
        Yg = function() { w(o, Ag); var r = T(o);

            function o(t, e) { var i;
                X(this, o); var n = Fg(e, "color", 0),
                    s = Fg(e, "alpha", .8); return (i = r.call(this, t, n, s)).touchEventStop = new Dg(W(i), { hitAreaMode: 1 }), i } return k(o) }();
    p.register("cover", function(t) { var e = new Yg(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Cover", Yg); var Xg = function(e, t) { void 0 === t && (t = {}), void 0 === t.options && (t.options = {}); var i = t.options;
            i.responsive = !1, i.maintainAspectRatio = !1, i.hasOwnProperty("devicePixelRatio") || (i.devicePixelRatio = 1); var n = !1;
            void 0 === i.animation ? i.animation = {} : !1 === i.animation && (n = !0, i.animation = {}); var s = i.animation;
            n && (s.duration = 0); var r = s.onProgress;
            s.onProgress = function(t) { r && r(t), e.needRedraw() }; var o = s.onComplete; return s.onComplete = function(t) { o && o(t), e.needRedraw() }, t },
        Wg = function() { w(h, Qt); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), (o = a.call(this, t, e, i, n, s)).type = "rexChart", (o.chart = void 0) !== r && o.setChart(r), o } return k(h, [{ key: "destroy", value: function(t) { this.scene && (this.chart && (this.chart.destroy(), this.chart = void 0), O(C(h.prototype), "destroy", this).call(this, t)) } }, { key: "resize", value: function(t, e) { if (t === this.width && e === this.height) return this; if (O(C(h.prototype), "resize", this).call(this, t, e), this.chart) { var i = this.chart;
                        i.height = this.canvas.height, i.width = this.canvas.width, i.aspectRatio = i.height ? i.width / i.height : null, i.update() } return this } }]), h }(),
        Gg = { setChart: function(t) { if (window.Chart) return this.chart && this.chart.destroy(), this.chart = new Chart(this.context, Xg(this, t)), this; return console.error("Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.8.0/Chart.min.js');"), this }, getChartDataset: function(t) { if (void 0 !== this.chart) { if ("string" != typeof t) return this.chart.data.datasets[t]; for (var e, i = this.chart.data.datasets, n = 0, s = i.length; n < s; n++)
                        if ((e = i[n]).label === t) return e } }, getChartData: function(t, e) { var i = this.getChartDataset(t); if (void 0 !== i) { if ("string" == typeof e)
                        if (-1 === (e = this.chart.data.labels.indexOf(e))) return;
                    return i.data[e] } }, setChartData: function(t, e, i) { if (void 0 === this.chart) return this; var n = this.getChartDataset(t); if ("string" == typeof e && -1 === (e = this.chart.data.labels.indexOf(e))) return this; return n.data[e] = i, this }, updateChart: function() { return void 0 === this.chart || this.chart.update(), this } };
    Object.assign(Wg.prototype, Gg), p.register("chart", function(t, e, i, n, s) { var r = new Wg(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.Chart", Wg);

    function Vg(t, e, i, n, s, r, o, a, h) { od.call(this, t); var l = t.isRexSpace,
            u = P(e); if (null === e) return this; if ("number" !== u)
            if ("string" === u) e = qg[e];
            else if (Jg(e)) { var c;
            e = Kg(c = e, "proportion", void 0), i = Kg(c, "align", Zg), n = Kg(c, "padding", 0), s = Kg(c, "expand", !1), r = Kg(c, "key", void 0), o = Kg(c, "index", void 0), t.isRexSizer || (a = Kg(c, "minWidth", void 0), h = Kg(c, "minHeight", void 0)) } return "string" == typeof i && (i = Lc[i]), void 0 === e && (e = l ? 1 : 0), void 0 === i && (i = Zg), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === a && (l ? a = 0 : t.isRexSizer || (a = t._minWidth)), void 0 === h && (l ? h = 0 : t.isRexSizer || (h = t._minHeight)), (c = this.getSizerConfig(t)).proportion = e, c.align = i, c.padding = rd(n), c.expand = s, void 0 === o || o >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(o, 0, t), t.isRexSizer || (0 < e && (0 === this.orientation ? t.minWidth = void 0 === a ? Zs(t) : a : t.minHeight = void 0 === h ? qs(t) : h), s && (0 === this.orientation ? t.minHeight = h : t.minWidth = a)), void 0 !== r && this.addChildrenMap(r, t), this } var Ug = Phaser.Math.Wrap,
        Hg = Phaser.GameObjects.Zone,
        Ng = function() { w(n, Hg); var i = T(n);

            function n(t) { var e; return X(this, n), (e = i.call(this, t, 0, 0, 1, 1)).isRexSpace = !0, e } return k(n) }(),
        Jg = Phaser.Utils.Objects.IsPlainObject,
        Kg = Phaser.Utils.Objects.GetValue,
        Zg = Phaser.Display.Align.CENTER,
        qg = { min: 0, full: -1 },
        $g = { add: Vg, addSpace: function(t) { return this.insertSpace(void 0, t), this }, insertSpace: function(t, e) { return void 0 === e && (e = 1), Vg.call(this, new Ng(this.scene), { proportion: e, minWidth: 0, minHeight: 0, index: t }), this }, insert: function(t, e, i, n, s, r, o, a) { return Jg(i) && (i.index = t), Vg.call(this, e, i, n, s, r, o, t, a), this }, insertAtPosition: function(t, e, i, n, s, r, o, a, h) { var l = function(t, e) { var i = this.sizerChildren; if (0 === i.length) return -1; for (var n = -1, s = 1 / 0, r = 0, o = i.length; r < o; r++) { var a = i[r];
                        (h = 0 === this.orientation ? Math.abs(a.left - t) : Math.abs(a.top - e)) < s && (s = h, n = r) } var h;
                    a = i[i.length - 1]; return (h = 0 === this.orientation ? Math.abs(a.right - t) : Math.abs(a.bottom - e)) < s && (s = h, n = r + 1), n }.call(this, t, e); return -1 === l && (l = void 0), this.insert(l, i, n, s, r, o, a, h), this } },
        Qg = Phaser.Utils.Array.Remove,
        ty = { remove: function(t, e) { return this.getParentSizer(t) !== this || (Qg(this.sizerChildren, t), gv.call(this, t, e)), this }, removeAll: function(t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--) this.remove(this.sizerChildren[e], t); return this }, clear: function(t) { return this.sizerChildren.length = 0, yv.call(this, t), this } },
        ey = { getChildrenWidth: function(t) { if (this.rexSizer.hidden) return 0;
                void 0 === t && (t = !0); var e, i, n, s = 0,
                    r = this.sizerChildren; if (0 === this.orientation)
                    for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (n = 0 === e.rexSizer.proportion || t ? this.getChildWidth(e) : 0, n += (i = e.rexSizer.padding).left + i.right, 0 < o && (n += this.space.item), s += n);
                else
                    for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty("rexSizer") && (e.rexSizer.hidden || (i = e.rexSizer.padding, n = this.getChildWidth(e) + i.left + i.right, s = Math.max(n, s))); return s + this.space.left + this.space.right }, getChildrenHeight: function(t) { if (this.rexSizer.hidden) return 0;
                void 0 === t && (t = !0); var e, i, n, s = 0,
                    r = this.sizerChildren; if (0 === this.orientation)
                    for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (i = e.rexSizer.padding, n = this.getChildHeight(e) + i.top + i.bottom, s = Math.max(n, s));
                else
                    for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty("rexSizer") && (e.rexSizer.hidden || (n = 0 === e.rexSizer.proportion || t ? this.getChildHeight(e) : 0, n += (i = e.rexSizer.padding).top + i.bottom, 0 < o && (n += this.space.item), s += n)); return s + this.space.top + this.space.bottom }, getExpandedChildWidth: function(t, e) { var i;
                void 0 === e && (e = this.width); var n = t.rexSizer,
                    s = n.padding;
                0 === this.orientation ? 0 < n.proportion && 0 < this.proportionLength && (i = n.proportion * this.proportionLength) : n.expand && (i = e - this.space.left - this.space.right - s.left - s.right); return i }, getExpandedChildHeight: function(t, e) { var i;
                void 0 === e && (e = this.height); var n = t.rexSizer,
                    s = n.padding;
                0 === this.orientation ? n.expand && (i = e - this.space.top - this.space.bottom - s.top - s.bottom) : 0 < n.proportion && 0 < this.proportionLength && (i = n.proportion * this.proportionLength); return i }, getChildrenSizers: function(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]).isRexSizer && t.push(e); return t }, preLayout: function() { return this._childrenProportion = void 0, this.proportionLength = void 0, ud.call(this), this }, layoutChildren: function() { for (var t, e, i, n, s, r, o, a, h, l, u = this.sizerChildren, c = this.innerLeft, d = this.innerTop, f = this.innerWidth, p = this.innerHeight, v = c, g = d, y = this.startChildIndex, m = 0, k = u.length; m < k; m++) l = 0 === y ? m : Ug(m + y, 0, k), this.rtl && (l = k - l - 1), (t = u[l]).rexSizer.hidden || (i = (e = t.rexSizer).padding, Id.call(this, t), h = t.isRexSpace ? a = 0 : (a = this.getExpandedChildWidth(t), this.getExpandedChildHeight(t)), t.isRexSizer ? (t.runLayout(this, a, h), vv(t, this)) : Bd(t, a, h), void 0 === a && (a = Zs(t)), void 0 === h && (h = qs(t)), o = 0 === this.orientation ? (n = v + i.left, r = 0 === e.proportion || 0 === this.proportionLength ? a : e.proportion * this.proportionLength, s = g + i.top, p - i.top - i.bottom) : (n = v + i.left, r = f - i.left - i.right, s = g + i.top, 0 === e.proportion || 0 === this.proportionLength ? h : e.proportion * this.proportionLength), Ld.call(this, t, n, s, r, o, e.align), 0 === this.orientation ? v += r + i.left + i.right + this.space.item : g += o + i.top + i.bottom + this.space.item) }, resolveWidth: function(t) { t = hd.call(this, t); if (void 0 === this.proportionLength && 0 === this.orientation) { var e = t - this.childrenWidth;
                    0 < e ? (e = t - this.getChildrenWidth(!1), this.proportionLength = e / this.childrenProportion) : this.proportionLength = 0 } return t }, resolveHeight: function(t, e) { e = ld.call(this, t, e); if (void 0 === this.proportionLength && 1 === this.orientation) { var i = e - this.childrenHeight;
                    0 < i ? (i = e - this.getChildrenHeight(!1), this.proportionLength = i / this.childrenProportion) : this.proportionLength = 0 } return e } };
    Object.assign(ey, $g, ty);

    function iy(t) { return "string" == typeof t && (t = ny[t]), t } var ny = { x: 0, h: 0, horizontal: 0, "left-to-right": 0, y: 1, v: 1, vertical: 1, "top-to-bottom": 1 },
        sy = Phaser.Utils.Objects.IsPlainObject,
        ry = Phaser.Utils.Objects.GetValue,
        oy = function() { w(l, pv); var h = T(l);

            function l(t, e, i, n, s, r, o) { var a; return X(this, l), sy(e) ? (e = ry(o = e, "x", 0), i = ry(o, "y", 0), n = ry(o, "width", void 0), s = ry(o, "height", void 0), r = ry(o, "orientation", 0)) : sy(n) ? (n = ry(o = n, "width", void 0), s = ry(o, "height", void 0), r = ry(o, "orientation", 0)) : sy(r) && (r = ry(o = r, "orientation", 0)), void 0 === r && (r = 0), (a = h.call(this, t, e, i, n, s, o)).type = "rexSizer", a.sizerChildren = [], a.setOrientation(r), a.setItemSpacing(ry(o, "space.item", 0)), a.setStartChildIndex(ry(o, "startChildIndex", 0)), a.setRTL(ry(o, "rtl", !1)), a.addChildrenMap("items", a.sizerChildren), a } return k(l, [{ key: "setOrientation", value: function(t) { return this.orientation = iy(t), this } }, { key: "setItemSpacing", value: function(t) { return this.space.item = t, this } }, { key: "setStartChildIndex", value: function(t) { return this.startChildIndex = t, this } }, { key: "setRTL", value: function(t) { return void 0 === t && (t = !0), this.rtl = t, this } }, { key: "childrenProportion", get: function() { return void 0 === this._childrenProportion && (this._childrenProportion = function() { for (var t, e, i = 0, n = this.sizerChildren, s = 0, r = n.length; s < r; s++)(t = n[s]).rexSizer.hidden || 0 < (e = t.rexSizer.proportion) && (i += e); return i }.call(this)), this._childrenProportion } }]), l }();
    Object.assign(oy.prototype, ey), p.register("sizer", function(t, e, i, n, s, r) { var o = new oy(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o }), j(window, "RexPlugins.UI.Sizer", oy);

    function ay() { return Array.prototype.reduce.call(arguments, dy, 0) }

    function hy(t, e, i, n, s) { if ("number" == typeof t || "number" == typeof e)
            if (void 0 === t) { for (var r = 0; r < n; r++)
                    if (!i[o = e * n + r]) return o } else if (void 0 === e) { for (r = 0; r < s; r++)
                if (!i[o = r * n + t]) return o } else { if (!i[o = e * n + t]) return o } else if (!0 === e) { var o; for (r = 0; r < n; r++)
                for (var a = 0; a < s; a++)
                    if (!i[o = a * n + r]) return o } else { r = 0; for (var h = i.length; r < h; r++)
                if (!i[r]) return r } return null }

    function ly(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = t.length - 1); for (var s = i; s <= n; s++) t[s] = e; return t }

    function uy(t, e, i) { void 0 === e && (e = this.rowProportions[0] || 0), void 0 === i && (i = this.space.row[0] || 0), this.rowCount += 1, this.gridCount += this.columnCount; for (var n = [t * this.columnCount, 0], s = 0; s < this.columnCount; s++) n.push(null); return this.sizerChildren.splice.apply(this.sizerChildren, n), this.rowProportions.push(e), this.rowHeight.length += 1, this.space.row.splice(t, 0, i), this }

    function cy(t, e, i) { void 0 === e && (e = this.columnProportions[0] || 0), void 0 === i && (i = this.space.column[0] || 0), this.columnCount += 1, this.gridCount += this.rowCount; for (var n = this.rowCount - 1; 0 <= n; n--) { var s = n * this.columnCount + t;
            this.sizerChildren.splice(s, 0, null) } return this.columnProportions.push(e), this.columnWidth.length += 1, this.space.column.splice(t, 0, i), this } var dy = function(t, e) { return t + e },
        fy = Phaser.Utils.Objects.IsPlainObject,
        py = Phaser.Utils.Objects.GetValue,
        vy = Phaser.Display.Align.CENTER,
        gy = { add: function(t, e, i, n, s, r, o) { od.call(this, t), fy(e) && (e = py(a = e, "column", void 0), i = py(a, "row", void 0), n = py(a, "align", vy), s = py(a, "padding", 0), r = py(a, "expand", !1), o = py(a, "key", void 0)); var a, h = hy(e, i, this.sizerChildren, this.columnCount, this.rowCount); if (null === h) { if ("number" == typeof e && "number" == typeof i) return this;!0 === i || "number" == typeof i ? this.addEmptyColumn() : this.addEmptyRow(), h = hy(e, i, this.sizerChildren, this.columnCount, this.rowCount) } return "string" == typeof n && (n = Lc[n]), void 0 === n && (n = vy), void 0 === s && (s = 0), void 0 === r && (r = !0), (a = this.getSizerConfig(t)).align = n, a.padding = rd(s), a.expand = r, this.sizerChildren[h] = t, void 0 !== o && this.addChildrenMap(o, t), this } },
        yy = { remove: function(t, e) { if (this.getParentSizer(t) !== this) return this; var i = this.sizerChildren.indexOf(t); return -1 !== i && (this.sizerChildren[i] = null), gv.call(this, t, e), this }, removeAt: function(t, e, i) { var n = this.getChildAt(t, e); return n && this.remove(n, i), this }, removeAll: function(t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--) { var i = this.sizerChildren[e];
                    i && this.remove(i, t) } return this }, clear: function(t) { return ly(this.sizerChildren, null), yv.call(this, t), this } },
        my = Phaser.Utils.Objects.GetValue,
        ky = { getChildrenWidth: function(t) { if (this.rexSizer.hidden) return 0;
                void 0 === t && (t = !0); for (var e, i, n, s, r = 0, o = this.sizerChildren, a = 0; a < this.columnCount; a++) { if ((e = 0) === this.columnProportions[a] || t) { for (var h = 0; h < this.rowCount; h++)(i = o[h * this.columnCount + a]) && (i.rexSizer.hidden || (n = i.rexSizer.padding, s = this.getChildWidth(i) + n.left + n.right, e = Math.max(e, s)));
                        r += e }
                    this.columnWidth[a] = e } var l = this.space,
                    u = Math.max(l.indentLeftOdd, l.indentLeftEven); return r + ay.apply(void 0, [l.left, u].concat(M(l.column), [l.right])) }, getChildrenHeight: function(t) { if (this.rexSizer.hidden) return 0;
                void 0 === t && (t = !0); for (var e, i, n, s, r = 0, o = this.sizerChildren, a = 0; a < this.rowCount; a++) { if ((e = 0) === this.rowProportions[a] || t) { for (var h = 0; h < this.columnCount; h++)(i = o[a * this.columnCount + h]) && (i.rexSizer.hidden || (s = i.isRexSizer ? Math.max(i.minHeight, i.childrenHeight) : i.hasOwnProperty("minHeight") ? i.minHeight : qs(i), s += (n = i.rexSizer.padding).top + n.bottom, e = Math.max(e, s)));
                        r += e }
                    this.rowHeight[a] = e } var l = this.space,
                    u = Math.max(l.indentTopOdd, l.indentTopEven); return r + ay.apply(void 0, [l.top, u].concat(M(l.row), [l.bottom])) }, getExpandedChildWidth: function(t, e) { var i, n = t.rexSizer; if (n.expand) { var s = n.padding;
                    i = e - s.left - s.right } return i }, getExpandedChildHeight: function(t, e) { var i, n = t.rexSizer; if (n.expand) { var s = n.padding;
                    i = e - s.top - s.bottom } return i }, getChildrenSizers: function(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]) && e.isRexSizer && t.push(e); return t }, preLayout: function() { return this._totalColumnProportions = void 0, this._totalRowProportions = void 0, this.proportionWidthLength = void 0, this.proportionHeightLength = void 0, ud.call(this), this }, layoutChildren: function() { for (var t, e, i, n, s, r, o, a, h, l, u, c, d = this.innerLeft, f = this.innerTop, p = this.space.column, v = this.space.row, g = this.space.indentLeftOdd, y = this.space.indentLeftEven, m = this.space.indentTopOdd, k = this.space.indentTopEven, b = 0; b < this.rowCount; b++) { c = this.getRowHeight(b), n = d + (b % 2 ? y : g); for (var x = 0; x < this.columnCount; x++) u = this.getColumnWidth(x), (t = this.getChildAt(x, b)) && !t.rexSizer.hidden && (Id.call(this, t), h = this.getExpandedChildWidth(t, u), l = this.getExpandedChildHeight(t, c), t.isRexSizer ? (t.runLayout(this, h, l), vv(t, this)) : Bd(t, h, l), s = n + (i = (e = t.rexSizer).padding).left, o = u - i.left - i.right, r = f + (x % 2 ? k : m) + i.top, a = c - i.top - i.bottom, Ld.call(this, t, s, r, o, a, e.align)), n += u + p[x];
                    f += c + v[b] } }, resolveWidth: function(t) { t = hd.call(this, t); if (void 0 === this.proportionWidthLength) { var e = this.totalColumnProportions; if (0 < e) { var i = t - this.getChildrenWidth(!1);
                        0 <= i && (this.proportionWidthLength = i / e) } else this.proportionWidthLength = 0 } return t }, resolveHeight: function(t, e) { e = ld.call(this, t, e); if (void 0 === this.proportionHeightLength) { var i = this.totalRowProportions; if (0 < i) { var n = e - this.getChildrenHeight(!1);
                        0 <= n && (this.proportionHeightLength = n / i) } else this.proportionHeightLength = 0 } return e }, resolveChildrenWidth: function() { var t, e, i; for (var n in this.sizerChildren)(t = this.sizerChildren[n]) && t.isRexSizer && !t.ignoreLayout && (i = this.getColumnWidth(parseInt(n) % this.columnCount), e = this.getExpandedChildWidth(t, i), e = t.resolveWidth(e), t.resolveChildrenWidth(e)) }, runWidthWrap: function() { var t, e, i; for (var n in this.sizerChildren) !(t = this.sizerChildren[n]) || t.isRexSizer && t.ignoreLayout || !t.runWidthWrap || (i = this.getColumnWidth(parseInt(n) % this.columnCount), e = this.getExpandedChildWidth(t, i), t.isRexSizer && (e = t.resolveWidth(e)), t.runWidthWrap(e)); return this }, resetGrid: function(t, e, i, n, s) { if (void 0 === i && (i = 0), void 0 === n && (n = 0), this.columnCount = t, this.rowCount = e, this.gridCount = t * e, void 0 === this.sizerChildren ? this.sizerChildren = [] : this.removeAll(), this.sizerChildren.length = t * e, ly(this.sizerChildren, null), this.columnProportions = [], this.columnProportions.length = t, "number" == typeof i) ly(this.columnProportions, i);
                else
                    for (var r = 0; r < t; r++) this.columnProportions[r] = i[r] || 0; if (this.rowProportions = [], this.rowProportions.length = e, "number" == typeof n) ly(this.rowProportions, n);
                else
                    for (r = 0; r < e; r++) this.rowProportions[r] = n[r] || 0;
                this.columnWidth = [], this.columnWidth.length = t, this.rowHeight = [], this.rowHeight.length = e, this.space.column = [], this.space.column.length = t - 1; var o = my(s, "column", 0); if ("number" == typeof o) ly(this.space.column, o);
                else { r = 0; for (var a = this.space.column.length; r < a; r++) this.space.column[r] = o[r] || 0 }
                this.space.row = [], this.space.row.length = e - 1; var h = my(s, "row", 0); if ("number" == typeof h) ly(this.space.row, h);
                else
                    for (r = 0, a = this.space.row.length; r < a; r++) this.space.row[r] = h[r] || 0; return this }, inseryEmptyRow: uy, addEmptyRow: function(t, e) { return uy.call(this, this.rowCount, t, e), this }, insertEmptyColumn: cy, addEmptyColumn: function(t, e) { return cy.call(this, this.columnCount, t, e), this } };
    Object.assign(ky, gy, yy); var by = Phaser.Utils.Objects.IsPlainObject,
        xy = Phaser.Utils.Objects.GetValue,
        Cy = function() { w(y, pv); var g = T(y);

            function y(t, e, i, n, s, r, o, a, h, l) { var u;
                X(this, y), by(e) ? (e = xy(l = e, "x", 0), i = xy(l, "y", 0), n = xy(l, "width", void 0), s = xy(l, "height", void 0), r = xy(l, "column", l.col || 0), o = xy(l, "row", 0), a = xy(l, "columnProportions", 0), h = xy(l, "rowProportions", 0)) : by(n) ? (n = xy(l = n, "width", void 0), s = xy(l, "height", void 0), r = xy(l, "column", l.col || 0), o = xy(l, "row", 0), a = xy(l, "columnProportions", 0), h = xy(l, "rowProportions", 0)) : by(r) ? (r = xy(l = r, "column", l.col || 0), o = xy(l, "row", 0), a = xy(l, "columnProportions", 0), h = xy(l, "rowProportions", 0)) : by(a) && (a = xy(l = a, "columnProportions", 0), h = xy(l, "rowProportions", 0)), (u = g.call(this, t, e, i, n, s, l)).type = "rexGridSizer", u.resetGrid(r, o, a, h, xy(l, "space", void 0)), u.setIndentLeft(xy(l, "space.indentLeftOdd", 0), xy(l, "space.indentLeftEven", 0)), u.setIndentTop(xy(l, "space.indentTopOdd", 0), xy(l, "space.indentTopEven", 0)), u.addChildrenMap("items", u.sizerChildren); var c = xy(l, "createCellContainerCallback"); if (c) { i = 0; for (var d = u.rowCount; i < d; i++) { e = 0; for (var f = u.columnCount; e < f; e++) { var p = { column: e, row: i },
                                v = c(t, e, i, p);
                            v && u.add(v, p) } } } return u } return k(y, [{ key: "destroy", value: function(t) { this.scene && (O(C(y.prototype), "destroy", this).call(this, t), this.columnProportions = void 0, this.rowProportions = void 0, this.columnWidth = void 0, this.rowHeight = void 0) } }, { key: "setIndentLeft", value: function(t, e) { return this.space.indentLeftOdd = t, this.space.indentLeftEven = e, this } }, { key: "setIndentTop", value: function(t, e) { return this.space.indentTopOdd = t, this.space.indentTopEven = e, this } }, { key: "setColumnProportion", value: function(t, e) { return t >= this.columnProportions.length || (this.columnProportions[t] = e), this } }, { key: "setRowProportion", value: function(t, e) { return t >= this.rowProportions.length || (this.rowProportions[t] = e), this } }, { key: "totalColumnProportions", get: function() { return void 0 === this._totalColumnProportions && (this._totalColumnProportions = function() { for (var t, e = 0, i = 0; i < this.columnCount; i++) 0 < (t = this.columnProportions[i]) && (e += t); return e }.call(this)), this._totalColumnProportions } }, { key: "totalRowProportions", get: function() { return void 0 === this._totalRowProportions && (this._totalRowProportions = function() { for (var t, e = 0, i = 0; i < this.rowCount; i++) 0 < (t = this.rowProportions[i]) && (e += t); return e }.call(this)), this._totalRowProportions } }, { key: "getChildAt", value: function(t, e) { return this.sizerChildren[e * this.columnCount + t] } }, { key: "childToGridIndex", value: function(t, e) { if (!t) return null; var i = this.sizerChildren.indexOf(t); return -1 === i ? null : (void 0 === e && (e = {}), e.x = i % this.columnCount, e.y = Math.floor(i / this.columnCount), e) } }, { key: "getColumnWidth", value: function(t) { var e = this.columnProportions[t]; return 0 === e ? this.columnWidth[t] : e * this.proportionWidthLength } }, { key: "getRowHeight", value: function(t) { var e = this.rowProportions[t]; return 0 === e ? this.rowHeight[t] : e * this.proportionHeightLength } }]), y }();
    Object.assign(Cy.prototype, ky), p.register("gridSizer", function(t, e, i, n, s, r, o, a, h) { var l = new Cy(this.scene, t, e, i, n, s, r, o, a, h); return this.scene.add.existing(l), l }), j(window, "RexPlugins.UI.GridSizer", Cy);

    function wy(t, e, i, n) { return "\n" === t ? this.addNewLine() : (od.call(this, t), My(e) && (e = Ey(s = e, "padding", 0), i = Ey(s, "key", void 0), n = Ey(s, "index", void 0)), void 0 === e && (e = 0), (s = this.getSizerConfig(t)).align = _y, s.padding = rd(e), void 0 === n || n >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(n, 0, t), void 0 !== i && this.addChildrenMap(i, t)), this; var s } var Sy = function(t, e, i, n) { return e / t <= i ? e / (n - 1) : 0 },
        Py = function(t) { var e = t.rexSizer.padding; return Zs(t) + e.left + e.right },
        Ty = function(t) { var e = t.rexSizer.padding; return qs(t) + e.top + e.bottom },
        Oy = Phaser.Math.Distance.Between,
        My = Phaser.Utils.Objects.IsPlainObject,
        Ey = Phaser.Utils.Objects.GetValue,
        _y = Phaser.Display.Align.CENTER,
        Ry = { add: function(t, e, i) { if (Md(t))
                    for (var n = t, s = 0, r = n.length; s < r; s++) wy.call(this, n[s], e);
                else wy.call(this, t, e, i); return this }, addNewLine: function() { return this.sizerChildren.push("\n"), this }, insert: function(t, e, i, n) { return wy.call(this, e, i, n, t), this }, insertAtPosition: function(t, e, i, n, s) { var r = function(t, e) { var i = this.sizerChildren; if (0 === i.length) return -1; for (var n = -1, s = 1 / 0, r = 0, o = i.length; r < o; r++) { var a = i[r]; if (!(Math.abs(a.centerY - e) > a.height / 2)) {
                            (h = Oy(a.left, a.centerY, t, e)) < s && (s = h, n = r); var h, l = i[r + 1]; if (!l || l.y !== a.y)(h = Oy(a.right, a.centerY, t, e)) < s && (s = h, n = r + 1) } } return n }.call(this, t, e); return -1 === r && (r = void 0), this.insert(r, i, n, s), this } },
        By = Phaser.Utils.Array.Remove,
        Iy = { remove: function(t, e) { return this.getParentSizer(t) !== this || (By(this.sizerChildren, t), gv.call(this, t, e)), this }, removeAll: function(t) { for (var e = this.sizerChildren.length - 1; 0 <= e; e--) this.remove(this.sizerChildren[e], t); return this }, clear: function(t) { return this.sizerChildren.length = 0, yv.call(this, t), this } },
        Ly = { getChildrenWidth: function() { return this.rexSizer.hidden ? 0 : this.maxChildWidth + this.space.left + this.space.right }, getChildrenHeight: function() { return this.rexSizer.hidden ? 0 : this.widthWrapResult.height + this.space.top + this.space.bottom }, getChildrenSizers: function(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++) "\n" !== (e = i[n]) && e.isRexSizer && t.push(e); return t }, preLayout: function() { return this._maxChildWidth = void 0, this._maxChildHeight = void 0, ud.call(this), this }, layoutChildren: function() { for (var t, e, i, n, s, r, o, a, h, l, u, c = this.innerWidth, d = this.justifyPercentage, f = this.space.item, p = this.space.line, v = this.space.indentLeftOdd, g = this.space.indentLeftEven, y = this.space.indentTopOdd, m = this.space.indentTopEven, k = 0, b = this.innerLeft, x = this.innerTop, C = this.widthWrapResult.lines, w = x, S = 0, P = C.length; S < P; S++) { switch (h = (a = C[S]).children, this.rtl && h.reverse(), u = b + (S % 2 ? g : v), l = c - a.width, this.align) {
                        case 0:
                            break;
                        case 1:
                            u += l; break;
                        case 2:
                            u += l / 2; break;
                        case 3:
                            k = Sy(c, l, d, h.length); break;
                        case 4:
                            0 === (k = Sy(c, l, d, h.length)) && (u += l); break;
                        case 5:
                            0 === (k = Sy(c, l, d, h.length)) && (u += l / 2) } for (var T = 0, O = h.length; T < O; T++)(t = h[T]).rexSizer.hidden || (i = (e = t.rexSizer).padding, Id.call(this, t), n = u + i.left, 0 < T && (n += f), s = w + (T % 2 ? m : y) + i.top, r = Zs(t), o = qs(t), u = n + r + i.right + k, Ld.call(this, t, n, s, r, o, e.align));
                    w += a.height + p } }, runWidthWrap: function(t) { var e = t - this.space.left - this.space.right;
                this.widthWrapResult = function(t, e) { void 0 === e ? e = { lines: [], width: 0, height: 0 } : (e.lines.length = 0, e.width = 0, e.height = 0); for (var i, n, s, r, o = this.sizerChildren, a = this.space.item, h = this.space.line, l = this.space.indentLeftOdd, u = this.space.indentLeftEven, c = this.space.indentTopOdd, d = this.space.indentTopEven, f = 0, p = e.lines, v = void 0, g = 0, y = o.length; g < y; g++) { if ("\n" === (i = o[g])) i = void 0, r = !(n = 0);
                        else { if (i.rexSizer.hidden) continue;
                            i.isRexSizer && i.layout(), r = f < (n = Py(i)) || void 0 === v } if (r) v && (v.width = t - (f + a), e.width = Math.max(e.width, v.width), e.height += v.height + h), v = { children: [], height: 0 }, p.push(v), f = t - (p.length % 2 ? l : u);
                        f -= n + a, i && (v.children.push(i), s = Ty(i), v.height = Math.max(v.height, s)) } return v && (v.width = t - (f + a), e.width = Math.max(e.width, v.width), e.height += v.height), e.height += Math.max(c, d), e }.call(this, e, this.widthWrapResult), cd.call(this, t) } };
    Object.assign(Ly, Ry, Iy); var Ay = Phaser.Utils.Objects.IsPlainObject,
        jy = Phaser.Utils.Objects.GetValue,
        Dy = function() { w(h, pv); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), Ay(e) ? (e = jy(r = e, "x", 0), i = jy(r, "y", 0), n = jy(r, "width", void 0), s = jy(r, "height", void 0)) : Ay(n) && (n = jy(r = n, "width", void 0), s = jy(r, "height", void 0)), (o = a.call(this, t, e, i, n, s, r)).type = "rexFixWidthSizer", o.sizerChildren = [], o.setOrientation(jy(r, "orientation", 0)), o.setItemSpacing(jy(r, "space.item", 0)), o.setLineSpacing(jy(r, "space.line", 0)), o.setIntentLeft(jy(r, "space.indentLeftOdd", 0), jy(r, "space.indentLeftEven", 0)), o.setIntentTop(jy(r, "space.indentTopOdd", 0), jy(r, "space.indentTopEven", 0)), o.setAlign(jy(r, "align", 0)), o.setJustifyPercentage(jy(r, "justifyPercentage", .25)), o.setRTL(jy(r, "rtl", !1)), o.addChildrenMap("items", o.sizerChildren), o } return k(h, [{ key: "setOrientation", value: function(t) { return this.orientation = iy(t), this } }, { key: "setItemSpacing", value: function(t) { return this.space.item = t, this } }, { key: "setLineSpacing", value: function(t) { return this.space.line = t, this } }, { key: "setIntentLeft", value: function(t, e) { return this.space.indentLeftOdd = t, this.space.indentLeftEven = e, this } }, { key: "setIntentTop", value: function(t, e) { return this.space.indentTopOdd = t, this.space.indentTopEven = e, this } }, { key: "setAlign", value: function(t) { return "string" == typeof t && (t = zy[t]), this.align = t, this } }, { key: "setJustifyPercentage", value: function(t) { return this.justifyPercentage = t, this } }, { key: "setRTL", value: function(t) { return void 0 === t && (t = !0), this.rtl = t, this } }, { key: "maxChildWidth", get: function() { return void 0 === this._maxChildWidth && (this._maxChildWidth = function(t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++) "\n" !== (e = t[s]) && (i = this.getChildWidth(e), n = Math.max(i, n)); return n }.call(this)), this._maxChildWidth } }, { key: "maxChildHeight", get: function() { return void 0 === this._maxChildHeight && (this._maxChildHeight = function(t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++) "\n" !== (e = t[s]) && (i = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : e.hasOwnProperty("minHeight") ? e.minHeight : qs(e), n = Math.max(i, n)); return n }.call(this)), this._maxChildHeight } }]), h }(),
        zy = { left: 0, top: 0, right: 1, bottom: 1, center: 2, justify: 3, "justify-left": 3, "justify-top": 3, "justify-right": 4, "justify-bottom": 4, "justify-center": 5 };
    Object.assign(Dy.prototype, Ly), p.register("fixWidthSizer", function(t, e, i, n, s) { var r = new Dy(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.FixWidthSizer", Dy), p.register("overlapSizer", function(t, e, i, n, s) { var r = new Rv(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r }), j(window, "RexPlugins.UI.OverlapSizer", Rv), p.register("space", function() { return new Ng(this.scene) }), j(window, "RexPlugins.UI.Space", Ng);

    function Fy(t, e, i, n) { var s = new yg(e, i, n); if (t && !t.isRexSizer) { var r = s.createGeometryMask();
            t.setMask(r), this.once("destroy", function() { t.setMask(), r.destroy() }) } return this.pin(s), s } var Yy = Phaser.Utils.Objects.GetValue,
        Xy = function() { w(m, oy); var y = T(m);

            function m(t, e) { var i;
                X(this, m), (i = y.call(this, t, e)).type = "rexLabel"; var n = Yy(e, "background", void 0),
                    s = Yy(e, "icon", void 0),
                    r = Yy(e, "iconMask", void 0),
                    o = Yy(e, "text", void 0),
                    a = Yy(e, "action", void 0),
                    h = Yy(e, "actionMask", void 0),
                    l = Yy(e, "align", void 0),
                    u = Yy(e, "space.icon", 0),
                    c = Yy(e, "space.text", 0);
                n && i.addBackground(n), "right" !== l && "bottom" !== l && "center" !== l || i.addSpace(), s && (0 === i.orientation ? (o || a) && (f = { right: u }) : (o || a) && (f = { bottom: u }), i.add(s, { proportion: 0, padding: f }), r = r && Fy.call(W(i), s, s, 1)); if (o) { var d, f, p, v = Yy(e, "expandTextWidth", !1),
                        g = Yy(e, "expandTextHeight", !1);
                    p = 0 === i.orientation ? (d = v ? 1 : 0, a && (f = { right: c }), g) : (d = g ? 1 : 0, a && (f = { bottom: c }), v), i.add(o, { proportion: d, expand: p, padding: f }) } return a && (i.add(a), h = h && Fy.call(W(i), a, a, 1)), "center" === l && i.addSpace(), i.addChildrenMap("background", n), i.addChildrenMap("icon", s), i.addChildrenMap("iconMask", r), i.addChildrenMap("text", o), i.addChildrenMap("action", a), i.addChildrenMap("actionMask", h), i } return k(m, [{ key: "text", get: function() { var t = this.childrenMap.text; return void 0 === t ? "" : t.text }, set: function(t) { var e = this.childrenMap.text;
                    void 0 !== e && e.setText(t) } }, { key: "setText", value: function(t) { return this.text = t, this } }, { key: "appendText", value: function(t) { return this.text += t, this } }, { key: "setTexture", value: function(t, e) { var i = this.childrenMap.icon; if (void 0 !== i) return i.setTexture(t, e), this } }, { key: "texture", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.texture } }, { key: "frame", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.frame } }, { key: "runLayout", value: function(t, e, i) { if (this.ignoreLayout) return this;
                    O(C(m.prototype), "runLayout", this).call(this, t, e, i); var n = this.childrenMap.iconMask;
                    n && (n.setPosition(), this.resetChildPositionState(n)); var s = this.childrenMap.actionMask; return s && (s.setPosition(), this.resetChildPositionState(s)), this } }, { key: "resize", value: function(t, e) { O(C(m.prototype), "resize", this).call(this, t, e); var i = this.childrenMap.iconMask;
                    i && i.resize(); var n = this.childrenMap.actionMask; return n && n.resize(), this } }]), m }();
    p.register("label", function(t) { var e = new Xy(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Label", Xy); var Wy = Phaser.Utils.Objects.GetValue,
        Gy = function() { w(m, oy); var y = T(m);

            function m(t, e) { var i;
                X(this, m), (i = y.call(this, t, e)).type = "rexTitleLabel"; var n = Wy(e, "background", void 0),
                    s = Wy(e, "icon", void 0),
                    r = Wy(e, "iconMask", void 0),
                    o = Wy(e, "title", void 0),
                    a = Wy(e, "separator", void 0),
                    h = Wy(e, "text", void 0),
                    l = Wy(e, "action", void 0),
                    u = Wy(e, "actionMask", void 0),
                    c = h || o || a; if (n && i.addBackground(n), s) { var d = void 0;
                    0 === i.orientation ? (c || l) && (d = { right: Wy(e, "space.icon", 0), top: Wy(e, "space.iconTop", 0), bottom: Wy(e, "space.iconBottom", 0) }) : (c || l) && (d = { bottom: Wy(e, "space.icon", 0), left: Wy(e, "space.iconLeft", 0), right: Wy(e, "space.iconRight", 0) }), i.add(s, { proportion: 0, padding: d }), r = r && Fy.call(W(i), s, s, 1) } if (c) { var f = new oy(t, { orientation: 1 }),
                        p = Wy(e, "space.separator", 0); if (o) { var v = Wy(e, "align.title", "right"),
                            d = { bottom: !a && h ? p : 0 };
                        f.add(o, { align: v }) } if (a) { d = { top: o ? p : 0, bottom: h ? p : 0, left: Wy(e, "space.separatorLeft", 0), right: Wy(e, "space.separatorRight", 0) };
                        f.add(a, { expand: !0, padding: d }) } if (h) { var g = Wy(e, "align.text", "right");
                        f.add(h, { align: g }) }
                    d = void 0;
                    l && (d = { right: Wy(e, "space.text", 0) }), i.add(f, { proportion: 1, padding: d }) }
                l && (d = 0 === i.orientation ? { top: Wy(e, "space.actionTop", 0), bottom: Wy(e, "space.actionBottom", 0) } : { left: Wy(e, "space.actionLeft", 0), right: Wy(e, "space.actionRight", 0) }, i.add(l, { proportion: 0, padding: d }), u = u && Fy.call(W(i), l, l, 1)); return i.addChildrenMap("background", n), i.addChildrenMap("icon", s), i.addChildrenMap("iconMask", r), i.addChildrenMap("title", o), i.addChildrenMap("separator", a), i.addChildrenMap("text", h), i.addChildrenMap("action", l), i.addChildrenMap("actionMask", u), i } return k(m, [{ key: "title", get: function() { var t = this.childrenMap.title; return void 0 === t ? "" : t.title }, set: function(t) { var e = this.childrenMap.title;
                    void 0 !== e && e.setText(t) } }, { key: "setTitle", value: function(t) { return this.title = t, this } }, { key: "appendTitle", value: function(t) { return this.title += t, this } }, { key: "text", get: function() { var t = this.childrenMap.text; return void 0 === t ? "" : t.text }, set: function(t) { var e = this.childrenMap.text;
                    void 0 !== e && e.setText(t) } }, { key: "setText", value: function(t) { return this.text = t, this } }, { key: "appendText", value: function(t) { return this.text += t, this } }, { key: "setTexture", value: function(t, e) { var i = this.childrenMap.icon; if (void 0 !== i) return i.setTexture(t, e), this } }, { key: "texture", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.texture } }, { key: "frame", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.frame } }, { key: "runLayout", value: function(t, e, i) { if (this.ignoreLayout) return this;
                    O(C(m.prototype), "runLayout", this).call(this, t, e, i); var n = this.childrenMap.iconMask;
                    n && (n.setPosition(), this.resetChildPositionState(n)); var s = this.childrenMap.actionMask; return s && (s.setPosition(), this.resetChildPositionState(s)), this } }, { key: "resize", value: function(t, e) { O(C(m.prototype), "resize", this).call(this, t, e); var i = this.childrenMap.iconMask;
                    i && i.resize(); var n = this.childrenMap.actionMask; return n && n.resize(), this } }]), m }();
    p.register("titleLabel", function(t) { var e = new Gy(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.TitleLabel", Gy);

    function Vy(t, e, i) { return void 0 === t && (t = this.value), void 0 === e && (e = this.minValue), void 0 === i && (i = this.maxValue), this.valueTextFormatCallbackScope ? this.valueTextFormatCallback(t, e, i) : this.valueTextFormatCallback.call(this.valueTextFormatCallbackScope, t, e, i) } var Uy = Phaser.Utils.Objects.GetValue,
        Hy = Phaser.Utils.Objects.IsPlainObject,
        Ny = function(t) { return t.toString() },
        Jy = Phaser.Math.Clamp,
        Ky = { setValueTextFormatCallback: function(t, e) { return this.valueTextFormatCallback = t, this.valueTextFormatCallbackScope = e, this }, getFormatValueText: Vy, updateValueText: function(t, e, i) { var n = this.childrenMap.value; return n && this.valueTextFormatCallback && (n.setText(Vy.call(this, t, e, i)), n.layout && n.layout()), this }, setValue: function(t, e, i) { return t = Jy(t, e, i), this.value = t, this.minValue = e, this.maxValue = i, this.updateValueText(t, e, i), this.setBarValue(t, e, i), this } },
        Zy = function() { w(r, oy); var n = T(r);

            function r(t, e) { var i; return X(this, r), (i = n.call(this, t, e)).type = "rexNameValueLabel",
                    function(t, e) { var i = Uy(e, "background", void 0),
                            n = Uy(e, "icon", void 0),
                            s = Uy(e, "iconMask", void 0),
                            r = Uy(e, "nameText", void 0),
                            o = Uy(e, "valueText", void 0),
                            a = Uy(e, "bar", void 0),
                            h = Uy(e, "action", void 0),
                            l = Uy(e, "actionMask", void 0);
                        Hy(a) && (a = new _c(t, a), t.add.existing(a), r && t.children.moveBelow(a, r), o && t.children.moveBelow(a, o)); var u = r || o || a; if (i && this.addBackground(i), n) { var c = void 0;
                            0 === this.orientation ? (u || h) && (c = { right: Uy(e, "space.icon", 0), top: Uy(e, "space.iconTop", 0), bottom: Uy(e, "space.iconBottom", 0) }) : (u || h) && (c = { bottom: Uy(e, "space.icon", 0), left: Uy(e, "space.iconLeft", 0), right: Uy(e, "space.iconRight", 0) }), this.add(n, { proportion: 0, padding: c }), s = s && Fy.call(this, n, n, 1) } if (u) { var d, f = new oy(t, { orientation: 1 }); if (r || o) { if (d = new oy(t, { orientation: 0 }), r) { "" === r.text && r.setText(" "), r.setOrigin(0, r.originY); var c = { left: Uy(e, "space.name", 0) };
                                    d.add(r, { padding: c }) } if (o) { "" === o.text && o.setText(" "), o.setOrigin(1, o.originY), d.addSpace();
                                    c = { right: Uy(e, "space.value", 0) };
                                    d.add(o, { padding: c }), this.setValueTextFormatCallback(Uy(e, "valueTextFormatCallback", Ny), Uy(e, "valueTextFormatCallbackScope", void 0)) }
                                f.add(d, { expand: !0 }) } if (a) { c = { top: d ? Uy(e, "space.bar", 0) : 0, bottom: Uy(e, "space.barBottom", 0), left: Uy(e, "space.barLeft", 0), right: Uy(e, "space.barRight", 0) };
                                f.add(a, { expand: !0, padding: c }) }
                            c = void 0;
                            h && (c = { right: Uy(e, "space.text", 0) }); var p = Uy(e, "align.text", "bottom");
                            this.add(f, { proportion: 1, align: p, padding: c }) }
                        h && (c = 0 === this.orientation ? { top: Uy(e, "space.actionTop", 0), bottom: Uy(e, "space.actionBottom", 0) } : { left: Uy(e, "space.actionLeft", 0), right: Uy(e, "space.actionRight", 0) }, this.add(h, { proportion: 0, padding: c }), l = l && Fy.call(this, h, h, 1));
                        this.addChildrenMap("background", i), this.addChildrenMap("icon", n), this.addChildrenMap("iconMask", s), this.addChildrenMap("name", r), this.addChildrenMap("value", o), this.addChildrenMap("bar", a), this.addChildrenMap("action", h), this.addChildrenMap("actionMask", l) }.call(W(i), t, e), i } return k(r, [{ key: "nameText", get: function() { var t = this.childrenMap.name; return void 0 === t ? "" : t.text }, set: function(t) { var e = this.childrenMap.name;
                    void 0 !== e && e.setText(t) } }, { key: "setNameText", value: function(t) { return this.nameText = t, this } }, { key: "valueText", get: function() { var t = this.childrenMap.value; return void 0 === t ? "" : t.text }, set: function(t) { var e = this.childrenMap.value;
                    void 0 !== e && e.setText(t) } }, { key: "setValueText", value: function(t) { return this.valueText = t, this } }, { key: "barValue", get: function() { var t = this.childrenMap.bar; if (void 0 !== t) return t.value }, set: function(t) { var e = this.childrenMap.bar;
                    void 0 !== e && e.setValue(t) } }, { key: "setBarValue", value: function(t, e, i) { var n = this.childrenMap.bar; return void 0 === n || n.setValue(t, e, i), this } }, { key: "easeBarValueTo", value: function(t, e, i) { var n = this.childrenMap.bar; return void 0 === n || n.easeValueTo(t, e, i), this } }, { key: "setTexture", value: function(t, e) { var i = this.childrenMap.icon; if (void 0 !== i) return i.setTexture(t, e), this } }, { key: "texture", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.texture } }, { key: "frame", get: function() { var t = this.childrenMap.icon; if (void 0 !== t) return t.frame } }, { key: "runLayout", value: function(t, e, i) { if (this.ignoreLayout) return this;
                    O(C(r.prototype), "runLayout", this).call(this, t, e, i); var n = this.childrenMap.iconMask;
                    n && (n.setPosition(), this.resetChildPositionState(n)); var s = this.childrenMap.actionMask; return s && (s.setPosition(), this.resetChildPositionState(s)), this } }, { key: "resize", value: function(t, e) { O(C(r.prototype), "resize", this).call(this, t, e); var i = this.childrenMap.iconMask;
                    i && i.resize(); var n = this.childrenMap.actionMask; return n && n.resize(), this } }]), r }();
    Object.assign(Zy.prototype, Ky), p.register("nameValueLabel", function(t) { var e = new Zy(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.NameValueLabel", Zy);

    function qy(t) { var e = !t.isRexSpace,
            i = !e || this.buttonsExpand ? 1 : 0; if (0 === this.sizerChildren.length)
            if (e) {!this.buttonsExpand && ("right" === this.buttonsAlign || "center" === this.buttonsAlign || "bottom" === this.buttonsAlign) && em.call(this), tm.call(this, t, { proportion: i, expand: !0 }); var n = !this.buttonsExpand && "center" === this.buttonsAlign;
                n && em.call(this), this.hasTailSpace = n } else tm.call(this, t, { proportion: i, expand: !0 }), this.hasTailSpace = !1;
        else if (this.hasTailSpace) { var s = this.sizerChildren.length - 1;
            tm.call(this, t, { index: s, proportion: i, expand: !0 }) } else tm.call(this, t, { proportion: i, expand: !0 }); return e && this.buttonGroup.add(t), this }

    function $y(t, e) { return this.getParentSizer(t) !== this || (this.buttonGroup.remove(t), nm.call(this, t, e)), this }

    function Qy(t) { var e, i, n = lm(t, "dataManager", void 0); if (void 0 === n) { var s = this.parent;
            s.setDataEnabled(), n = s.data }
        this.dataManager = n, e = lm(t, "setValueCallback", void 0), i = lm(t, "setValueCallbackScope", void 0), void 0 === e && (e = lm(t, "setButtonStateCallback", void 0), i = lm(t, "setButtonStateCallbackScope", void 0)), this.setValueCallback = e, this.setValueCallbackScope = i, n.events.on("changedata", function(t, e, i, n) { var s = this.buttonMap[e]; if (s) { var r = this.setValueCallback,
                    o = this.setValueCallbackScope;
                r && (o ? r.call(o, s, i, n) : r(s, i, n)), this.fireEvent("button.statechange", s, i, n) } }, this) } var tm = oy.prototype.add,
        em = oy.prototype.addSpace,
        im = { addButton: function(t) { if (Md(t))
                    for (var e = t, i = 0, n = e.length; i < n; i++) qy.call(this, e[i]);
                else qy.call(this, t); return this }, addButtons: function(t) { for (var e = 0, i = t.length; e < i; e++) qy.call(this, t[e]); return this } },
        nm = oy.prototype.remove,
        sm = oy.prototype.clear,
        rm = { remove: function(t, e) { if (Md(t))
                    for (var i = t, n = 0, s = i.length; n < s; n++) $y.call(this, i[n], e);
                else $y.call(this, t, e); return this }, clear: function(t) { return this.buttonGroup.buttons.length = 0, sm.call(this, t), this }, removeButton: function(t, e) { return (t = this.getButton(t)) && this.remove(t, e), this }, clearButtons: function(t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--) $y.call(this, e[i], t); return this } },
        om = { add: function(s) { if (this.buttons.push(s), this.buttonsType) { var t = s.name; "" === t ? console.error("".concat(this.parent.constructor.name, ": Button key is an empty string")) : this.buttonMap.hasOwnProperty(t) && console.error("".concat(this.parent.constructor.name, ": Duplicate button key '").concat(t, "'")), this.buttonMap[t] = s, this.dataManager.set(t, void 0).set(t, !1) } return s._buttonBehavior = new If(s, this.clickConfig), s._buttonBehavior.on("click", function(t, e, i, n) { this.fireEvent("button.click", e, i, n) }, this).on("enable", function(t, e) { this.fireEvent("button.enable", e) }, this).on("disable", function(t, e) { this.fireEvent("button.disable", e) }, this), s.on("pointerover", function(t, e, i, n) { this.fireEvent("button.over", s, t, n) }, this).on("pointerout", function(t, e) { this.fireEvent("button.out", s, t, e) }, this), this }, addMultiple: function(t) { for (var e = 0, i = t.length; e < i; e++) this.add(gameObject[e]); return this } },
        am = Phaser.Utils.Array.Remove,
        hm = { remove: function(t) { if (am(this.buttons, t), this.buttonsType) { var e = t.name;
                    delete this.buttonMap[e], this.dataManager.remove(e) } return this }, clear: function() { if (this.buttons.length = 0, this.buttonsType)
                    for (var t in this.buttonMap) delete this.buttonMap[t], this.dataManager.remove(t); return this } },
        lm = Phaser.Utils.Objects.GetValue,
        um = { setButtonsType: function(t) { void 0 === t && (t = {}); var e = lm(t, "buttonsType", t.type); switch (this.buttonsType = e) {
                    case "radio":
                        this.setRadioType(t); break;
                    case "checkboxes":
                        this.setCheckboxesType(t) } return this }, setRadioType: function(t) { Qy.call(this, t); var e = void 0,
                    i = this.parent,
                    s = this.buttons,
                    r = this.dataManager; return Object.defineProperty(i, "value", { get: function() { return e }, set: function(n) { n !== e && (e = n, s.forEach(function(t) { var e = t.name,
                                i = r.get(e);
                            e === n ? i || r.set(e, !0) : i && r.set(e, !1) })) }, enumerable: !0, configurable: !0 }), i.on("button.click", function(t) { i.value = t.name }), this }, setCheckboxesType: function(t) { Qy.call(this, t); var e = this.parent,
                    i = this.dataManager; return e.on("button.click", function(t) { i.toggle(t.name) }), this }, clearAllButtonsState: function() { for (var t in this.buttonMap) this.dataManager.set(t, !1); return this }, getAllButtonsState: function() { var t = {}; for (var e in this.buttonMap) t[e] = this.dataManager.get(e); return t }, setSelectedButtonName: function(t) { return this.parent.value = t, this }, getSelectedButtonName: function() { return this.parent.value }, setButtonState: function(t, e) { return void 0 === e && (e = !0), this.dataManager.set(t, e), this }, getButtonState: function(t) { return this.dataManager.get(t) } },
        cm = function(t, e) { return t ? t.hasOwnProperty("name") ? t.name === e ? t : null : GetElementByName(t, e) : null },
        dm = { getButton: function(t) { var e, i = this.buttons; switch (P(t)) {
                    case "number":
                        e = i[t]; break;
                    case "string":
                        e = function(t, e) { if (!t) return null; if (Md(t)) { for (var i, n = 0, s = t.length; n < s; n++)
                                    if (i = cm(t[n], e)) return i } else
                                for (var r in t)
                                    if (i = cm(t[r], e)) return i }(i, t); break;
                    default:
                        e = t, -1 === i.indexOf(e) && (e = void 0) } return e }, setButtonEnable: function(t, e) { var i = this.buttons; if (void 0 === t || "boolean" == typeof t) { e = t; for (var n = 0, s = i.length; n < s; n++) i[n]._buttonBehavior.setEnable(e) } else this.getButton(t)._buttonBehavior.setEnable(e); return this }, toggleButtonEnable: function(t) { var e = this.buttons; if (void 0 === t || "boolean" == typeof t)
                    for (var i = 0, n = e.length; i < n; i++) e[i]._buttonBehavior.toggleEnable();
                else this.getButton(t)._buttonBehavior.toggleEnable(); return this }, getButtonEnable: function(t) { return void 0 === t && (t = 0), this.getButton(t)._buttonBehavior.enable }, emitButtonClick: function(t) { return (this.buttonGroup ? this.buttonGroup : this).fireEvent("button.click", t), this }, showButton: function(t) { return Cd(this.getButton(t)), this }, hideButton: function(t) { return wd(this.getButton(t)), this }, isButtonShown: function(t) { return Sd(this.getButton(t)), this }, forEachButtton: function(t, e) { for (var i = this.buttons, n = 0, s = i.length; n < s; n++) e ? t.call(e, i[n], n, i) : t(i[n], n, i); return this } },
        fm = function() {
            function e(t) { X(this, e), this.parent = t.parent, this.eventEmitter = t.eventEmitter, this.groupName = t.groupName, this.clickConfig = t.clickConfig, this.buttonsType = void 0, this.buttons = [], this.buttonMap = {} } return k(e, [{ key: "destroy", value: function() { this.parent = void 0, this.eventEmitter = void 0, this.clickConfig = void 0, this.buttons = void 0 } }]), e }(),
        pm = { fireEvent: function(t, e) { var i, n, s, r; if ("number" == typeof e) { if (i = e, !(e = this.buttons[i])) return } else if (-1 === (i = this.buttons.indexOf(e))) return; for (var o = arguments.length, a = new Array(2 < o ? o - 2 : 0), h = 2; h < o; h++) a[h - 2] = arguments[h];
                this.eventEmitter !== this.parent && (n = this.parent).emit.apply(n, [t, e, i].concat(a));
                void 0 !== this.groupName ? (s = this.eventEmitter).emit.apply(s, [t, e, this.groupName, i].concat(a)) : (r = this.eventEmitter).emit.apply(r, [t, e, i].concat(a)) } };
    Object.assign(fm.prototype, om, hm, um, dm, pm); var vm = { clearAllButtonsState: function() { return this.buttonGroup.clearAllButtonsState(), this }, getAllButtonsState: function() { return this.buttonGroup.getAllButtonsState() }, setSelectedButtonName: function(t) { return this.buttonGroup.setSelectedButtonName(t), this }, getSelectedButtonName: function() { return this.buttonGroup.getSelectedButtonName() }, setButtonState: function(t, e) { return this.buttonGroup.setButtonState(t, e), this }, getButtonState: function(t) { return this.buttonGroup.getButtonState(t) } },
        gm = Phaser.Utils.Objects.GetValue,
        ym = function() { w(a, oy); var o = T(a);

            function a(t, e) { var i;
                X(this, a), void 0 === e && (e = {}); var n = e.space; "number" == typeof n && (e.space = { item: n }), (i = o.call(this, t, e)).type = "rexButtons", i.buttonGroup = new fm({ parent: W(i), eventEmitter: gm(e, "eventEmitter", W(i)), groupName: gm(e, "groupName", void 0), clickConfig: gm(e, "click", void 0) }).setButtonsType(e); var s = gm(e, "background", void 0),
                    r = gm(e, "buttons", void 0); return i.buttonsExpand = gm(e, "expand", !1), i.buttonsAlign = gm(e, "align", void 0), s && i.addBackground(s), r && i.addButtons(r), i.addChildrenMap("background", s), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(a, [{ key: "destroy", value: function(t) { this.scene && (O(C(a.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function() { return this.buttonGroup.buttons } }, { key: "groupName", get: function() { return this.buttonGroup.groupName }, set: function(t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function() { return this.buttonGroup.eventEmitter } }]), a }();
    Object.assign(ym.prototype, im, rm, dm, vm), p.register("buttons", function(t) { var e = new ym(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Buttons", ym);

    function mm(t, e) { return (t = this.getButton(t)) && (this.buttonGroup.remove(t), xm.call(this, t, e)), this } var km = Cy.prototype.add,
        bm = { addButton: function(t, e, i) { return km.call(this, t, e, i, void 0, 0, this.buttonsExpand), this.buttonGroup.add(t), this }, addButtons: function(t, e) { for (var i = 0, n = t; i < n; i++) this.addButton(t[i], void 0, e); return this } },
        xm = Cy.prototype.remove,
        Cm = Cy.prototype.clear,
        wm = { remove: function(t, e) { if (Md(t))
                    for (var i = t, n = 0, s = i.length; n < s; n++) mm.call(this, i[n], e);
                else mm.call(this, t, e); return this }, clear: function(t) { return this.buttonGroup.buttons.length = 0, Cm.call(this, t), this }, removeButton: function(t, e) { return this.remove(t, e), this }, clearButtons: function(t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--) mm.call(this, e[i], t); return this } },
        Sm = Phaser.Utils.Objects.GetValue,
        Pm = function() { w(x, Cy); var b = T(x);

            function x(t, e) { var i;
                X(this, x), void 0 === e && (e = {}); var n = Sm(e, "row", 0),
                    s = Sm(e, "column", e.col || 0),
                    r = Sm(e, "createCellContainerCallback"),
                    o = Sm(e, "buttons", void 0),
                    a = Sm(e, "expand", !0),
                    h = a ? 1 : 0; if (r && (e.createCellContainerCallback = void 0), void 0 !== o) { n = Math.max(n, o.length); for (var l = 0, u = o.length; l < u; l++) s = Math.max(s, o[l].length) }
                e.row = n, e.column = s, e.columnProportions = h, e.rowProportions = h, (i = b.call(this, t, e)).type = "rexGridButtons", i.buttonGroup = new fm({ parent: W(i), eventEmitter: Sm(e, "eventEmitter", W(i)), groupName: Sm(e, "groupName", void 0), clickConfig: Sm(e, "click", void 0) }).setButtonsType(e); var c = Sm(e, "background", void 0); if (i.buttonsExpand = a, Sm(e, "space", void 0), c && i.addBackground(c), o)
                    for (var d, f = 0, p = o.length; f < p; f++)
                        for (var v = 0, g = (d = o[f]).length; v < g; v++)(k = d[v]) && i.addButton(k, v, f);
                else if (r)
                    for (var y = 0; y < n; y++)
                        for (var m = 0; m < s; m++) { var k;
                            (k = r(t, m, y)) && i.addButton(k, m, y) }
                return i.addChildrenMap("background", c), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(x, [{ key: "destroy", value: function(t) { this.scene && (O(C(x.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function() { return this.buttonGroup.buttons } }, { key: "groupName", get: function() { return this.buttonGroup.groupName }, set: function(t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function() { return this.buttonGroup.eventEmitter } }]), x }();
    Object.assign(Pm.prototype, bm, wm, dm, vm), p.register("gridButtons", function(t) { var e = new Pm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.GridButtons", Pm);

    function Tm(t) { return Mm.call(this, t), this.buttonGroup.add(t), this }

    function Om(t, e) { return (t = this.getButton(t)) && (this.buttonGroup.remove(t), _m.call(this, t, e)), this } var Mm = Dy.prototype.add,
        Em = { addButton: function(t) { if (Md(t))
                    for (var e = t, i = 0, n = e.length; i < n; i++) Tm.call(this, e[i]);
                else Tm.call(this, t); return this }, addButtons: function(t) { if (Md(t[0]))
                    for (var e, i = t, n = 0, s = i.length - 1; n <= s; n++) { for (var r = 0, o = (e = i[n]).length; r < o; r++) Tm.call(this, e[r]);
                        s < n && Mm.addNewLine(this) } else
                        for (r = 0, o = t.length; r < o; r++) Tm.call(this, t[r]); return this } },
        _m = Dy.prototype.remove,
        Rm = Dy.prototype.clear,
        Bm = { remove: function(t, e) { if (Md(t))
                    for (var i = t, n = 0, s = i.length; n < s; n++) Om.call(this, i[n], e);
                else Om.call(this, t, e); return this }, clear: function(t) { return this.buttonGroup.buttons.length = 0, Rm.call(this, t), this }, removeButton: function(t, e) { return this.remove(t, e), this }, clearButtons: function(t) { for (var e = this.buttonGroup.buttons, i = e.length - 1; 0 <= i; i--) Om.call(this, e[i], t); return this } },
        Im = Phaser.Utils.Objects.GetValue,
        Lm = function() { w(a, Dy); var o = T(a);

            function a(t, e) { var i;
                X(this, a), void 0 === e && (e = {}); var n = e.space; "number" == typeof n && (e.space = { item: n, line: n }), (i = o.call(this, t, e)).type = "rexFixWidthButtons", i.buttonGroup = new fm({ parent: W(i), eventEmitter: Im(e, "eventEmitter", W(i)), groupName: Im(e, "groupName", void 0), clickConfig: Im(e, "click", void 0) }).setButtonsType(e); var s = Im(e, "background", void 0),
                    r = Im(e, "buttons", void 0); return i.buttonsAlign = Im(e, "align", void 0), s && i.addBackground(s), r && i.addButtons(r), i.addChildrenMap("background", s), i.addChildrenMap("buttons", i.buttonGroup.buttons), i } return k(a, [{ key: "destroy", value: function(t) { this.scene && (O(C(a.prototype), "destroy", this).call(this, t), this.buttonGroup.destroy(), this.buttonGroup = void 0) } }, { key: "buttons", get: function() { return this.buttonGroup.buttons } }, { key: "groupName", get: function() { return this.buttonGroup.groupName }, set: function(t) { this.buttonGroup.groupName = t } }, { key: "eventEmitter", get: function() { return this.buttonGroup.eventEmitter } }]), a }();
    Object.assign(Lm.prototype, Em, Bm, dm, vm), p.register("fixWidthButtons", function(t) { var e = new Lm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.FixWidthButtons", Lm); var Am = { getChoice: function(t) { var e = this.childrenMap.choicesSizer; return e ? e.getButton(t) : void 0 }, getAction: function(t) { return this.childrenMap.actionsSizer.getButton(t) }, getToolbar: function(t) { return this.childrenMap.toolbarSizer.getButton(t) }, getLeftToolbar: function(t) { return this.childrenMap.leftToolbarSizer.getButton(t) }, setChoiceEnable: function(t, e) { var i = this.childrenMap.choicesSizer; return i && i.setButtonEnable(t, e), this }, setActionEnable: function(t, e) { return this.childrenMap.actionsSizer.setButtonEnable(t, e), this }, setToolbarEnable: function(t, e) { return this.childrenMap.toolbarSizer.setButtonEnable(t, e), this }, setLeftToolbarEnable: function(t, e) { return this.childrenMap.leftToolbarSizer.setButtonEnable(t, e), this }, toggleChoiceEnable: function(t) { var e = this.childrenMap.choicesSizer; return e && e.toggleButtonEnable(t), this }, toggleActionEnable: function(t) { return this.childrenMap.actionsSizer.toggleButtonEnable(t), this }, toggleToolbarEnable: function(t) { return this.childrenMap.toolbarSizer.toggleButtonEnable(t), this }, toggleLeftToolbarEnable: function(t) { return this.childrenMap.leftToolbarSizer.toggleButtonEnable(t), this }, getChoiceEnable: function(t) { var e = this.childrenMap.choicesSizer; return !!e && e.getButtonEnable(t) }, getActionEnable: function(t) { return this.childrenMap.actionsSizer.getButtonEnable(t) }, getToolbarEnable: function(t) { return this.childrenMap.toolbarSizer.getButtonEnable(t) }, getLeftToolbarEnable: function(t) { return this.childrenMap.leftToolbarSizer.getButtonEnable(t) }, emitChoiceClick: function(t) { var e = this.childrenMap.choicesSizer; return e && e.emitButtonClick(t), this }, emitActionClick: function(t) { return this.childrenMap.actionsSizer.emitButtonClick(t), this }, emitToolbarClick: function(t) { return this.childrenMap.toolbarSizer.emitButtonClick(t), this }, emitLeftToolbarClick: function(t) { return this.childrenMap.leftToolbarSizer.emitButtonClick(t), this }, showChoice: function(t) { var e = this.childrenMap.choicesSizer; return e && e.showButton(t), this }, showAction: function(t) { return this.childrenMap.actionsSizer.showButton(t), this }, showToolbar: function(t) { return this.childrenMap.toolbarSizer.showButton(t), this }, showLeftToolbar: function(t) { return this.childrenMap.leftToolbarSizer.showButton(t), this }, hideChoice: function(t) { var e = this.childrenMap.choicesSizer; return e && e.hideButton(t), this }, hideAction: function(t) { return this.childrenMap.actionsSizer.hideButton(t), this }, hideToolbar: function(t) { return this.childrenMap.toolbarSizer.hideButton(t), this }, hideLeftToolbar: function(t) { return this.childrenMap.leftToolbarSizer.hideButton(t), this }, addChoice: function(t) { var e = this.childrenMap.choicesSizer; return e && e.addButton(t), this }, addAction: function(t) { return this.childrenMap.actionsSizer.addButton(t), this }, addToolbar: function(t) { return this.childrenMap.toolbarSizer.addButton(t), this }, addLeftToolbar: function(t) { return this.childrenMap.leftToolbarSizer.addButton(t), this }, removeChoice: function(t, e) { var i = this.childrenMap.choicesSizer; return i && i.removeButton(t, e), this }, removeAction: function(t, e) { return this.childrenMap.actionsSizer.removeButton(t, e), this }, removeToolbar: function(t, e) { return this.childrenMap.toolbarSizer.removeButton(t, e), this }, removeLeftToolbar: function(t, e) { return this.childrenMap.leftToolbarSizer.removeButton(t, e), this }, clearChoices: function(t) { var e = this.childrenMap.choicesSizer; return e && e.clearButtons(t), this }, clearActions: function(t) { return this.childrenMap.actionsSizer.clearButtons(t), this }, clearToolbar: function(t) { return this.childrenMap.toolbarSizer.clearButtons(t), this }, clearLeftToolbar: function(t) { return this.childrenMap.leftToolbarSizer.clearButtons(t), this }, forEachChoice: function(t, e) { var i = this.childrenMap.choicesSizer; return i && i.forEachButtton(t, e), this }, forEachAction: function(t, e) { return this.childrenMap.actionsSizer.forEachButtton(t, e), this }, forEachToolbar: function(t, e) { return this.childrenMap.toolbarSizer.forEachButtton(t, e), this }, forEachLeftToolbar: function(t, e) { return this.childrenMap.leftToolbarSizer.forEachButtton(t, e), this }, setAllButtonsEnable: function(t) { return void 0 === t && (t = !0), this.childrenMap.toolbarSizer && this.setToolbarEnable(t), this.childrenMap.leftToolbarSizer && this.setLeftToolbarEnable(t), this.childrenMap.actionsSizer && this.setActionEnable(t), this.childrenMap.choicesSizer && this.setChoiceEnable(t), this }, getChoicesButtonStates: function() { var t = this.childrenMap.choicesSizer; return t ? t.getAllButtonsState() : {} }, getChoicesButtonState: function(t) { var e = this.childrenMap.choicesSizer; return void 0 === t ? e ? e.getAllButtonsState() : {} : !!e && e.getButtonState(t) }, setChoicesButtonState: function(t, e) { var i = this.childrenMap.choicesSizer; return i && i.setButtonState(t, e), this }, clearChoicesButtonStates: function() { var t = this.childrenMap.choicesSizer; return t && t.clearAllButtonsState(), this }, getChoicesSelectedButtonName: function() { var t = this.childrenMap.choicesSizer; return t ? t.getSelectedButtonName() : "" }, setChoicesSelectedButtonName: function(t) { var e = this.childrenMap.choicesSizer; return e && e.setSelectedButtonName(t), this } },
        jm = Phaser.Utils.Objects.GetValue,
        Dm = function() { w(Y, oy); var F = T(Y);

            function Y(t, e) { var i;
                X(this, Y), void 0 === e && (e = {}), e.orientation = 1, (i = F.call(this, t, e)).type = "rexDialog", i.eventEmitter = jm(e, "eventEmitter", W(i)); var n, s, r, o, a = jm(e, "background", void 0),
                    h = jm(e, "title", void 0),
                    l = jm(e, "toolbar", void 0),
                    u = jm(e, "toolbarBackground", void 0),
                    c = jm(e, "leftToolbar", void 0),
                    d = jm(e, "leftToolbarBackground", void 0),
                    f = jm(e, "content", void 0),
                    p = jm(e, "description", void 0),
                    v = jm(e, "choices", void 0),
                    g = jm(e, "choicesBackground", void 0),
                    y = jm(e, "actions", void 0),
                    m = jm(e, "actionsBackground", void 0),
                    k = jm(e, "click", void 0); if (a && i.addBackground(a), l && (r = new ym(t, { groupName: "toolbar", background: u, buttons: l, orientation: 0, space: { item: jm(e, "space.toolbarItem", 0) }, click: k, eventEmitter: i.eventEmitter })), c && (o = new ym(t, { groupName: "leftToolbar", background: d, buttons: c, orientation: 0, space: { item: jm(e, "space.leftToolbarItem", 0) }, click: k, eventEmitter: i.eventEmitter })), h || l || c) { var b, x = !!h && jm(e, "expand.title", !0),
                        C = jm(e, "align.title", "center"),
                        w = !(h && !x && "center" === C || !h && (l || c));
                    b = w ? new oy(t, { orientation: 0 }) : new Rv(t); var S = w || { height: !0 }; if (o && b.add(o, { align: "left", expand: S }), h) { w && !x && "right" === C && b.addSpace(); var P = { left: jm(e, "space.titleLeft", 0), right: jm(e, "space.titleRight", 0) },
                            T = x ? 1 : 0;
                        b.add(h, { align: C, proportion: T, expand: S, padding: P }), w && !x && "left" === C && b.addSpace() }
                    r && (w && !h && b.addSpace(), b.add(r, { align: "right", expand: S })); var O = jm(e, "space.title", 0);
                    (f || p || v || y) && (P = { bottom: O }), i.add(b, { padding: P, expand: !0 }) } if (f) { var M = jm(e, "align.content", "center"),
                        E = jm(e, "space.content", 0),
                        _ = (P = { left: jm(e, "space.contentLeft", 0), right: jm(e, "space.contentRight", 0), bottom: p || v || y ? E : 0 }, jm(e, "expand.content", !0));
                    i.add(f, { align: M, padding: P, expand: _ }) } if (p) { M = jm(e, "align.description", "center"); var R = jm(e, "space.description", 0);
                    P = { left: jm(e, "space.descriptionLeft", 0), right: jm(e, "space.descriptionRight", 0), bottom: v || y ? R : 0 }, _ = jm(e, "expand.description", !0);
                    i.add(p, { align: M, padding: P, expand: _ }) } if (v) { var B = jm(e, "choicesType", "").split("-"),
                        I = zm(B, "wrap") ? Lm : zm(B, "grid") ? Pm : ym,
                        L = zm(B, "radio") ? "radio" : zm(B, "checkboxes") ? "checkboxes" : void 0,
                        A = { left: jm(e, "space.choicesBackgroundLeft", 0), right: jm(e, "space.choicesBackgroundRight", 0), top: jm(e, "space.choicesBackgroundTop", 0), bottom: jm(e, "space.choicesBackgroundBottom", 0) },
                        j = jm(e, "space.choice", 0);
                    I === ym ? A.item = j : I === Lm ? (A.item = j, A.line = jm(e, "space.choiceLine", j)) : (A.column = jm(e, "space.choiceColumn", j), A.row = jm(e, "space.choiceRow", j)); var D = { width: jm(e, "choicesWidth", void 0), height: jm(e, "choicesHeight", void 0), groupName: "choices", buttonsType: L, background: g, buttons: v, space: A, click: k, eventEmitter: i.eventEmitter, setValueCallback: jm(e, "choicesSetValueCallback", void 0), setValueCallbackScope: jm(e, "choicesSetValueCallbackScope", void 0) };
                    I === ym && (D.orientation = zm(B, "x") ? 0 : 1), n = new I(t, D); var z = jm(e, "space.choices", 0);
                    P = { left: jm(e, "space.choicesLeft", 0), right: jm(e, "space.choicesRight", 0), bottom: y ? z : 0 }, M = jm(e, "align.choices", "center"), _ = jm(e, "expand.choices", !0);
                    i.add(n, { align: M, padding: P, expand: _ }) } if (y) { s = new ym(t, { groupName: "actions", background: m, buttons: y, orientation: 0, space: { item: jm(e, "space.action", 0) }, expand: jm(e, "expand.actions", !1), align: jm(e, "align.actions", "center"), click: k, eventEmitter: i.eventEmitter });
                    P = { left: jm(e, "space.actionsLeft", 0), right: jm(e, "space.actionsRight", 0) };
                    i.add(s, { align: "center", padding: P, expand: !0 }) } return Ym(W(i), "click"), Ym(W(i), "over"), Ym(W(i), "out"), Ym(W(i), "enable"), Ym(W(i), "disalbe"), i.addChildrenMap("background", a), i.addChildrenMap("title", h), i.addChildrenMap("toolbar", l), i.addChildrenMap("leftToolbar", c), i.addChildrenMap("content", f), i.addChildrenMap("description", p), i.addChildrenMap("choices", n ? n.buttons : void 0), i.addChildrenMap("actions", s ? s.buttons : void 0), i.addChildrenMap("choicesSizer", n), i.addChildrenMap("actionsSizer", s), i.addChildrenMap("toolbarSizer", r), i.addChildrenMap("leftToolbarSizer", o), i } return k(Y) }(),
        zm = function(t, e) { return -1 !== t.indexOf(e) },
        Fm = { actions: "action", choices: "choice", toolbar: "toolbar", leftToolbar: "leftToolbar" },
        Ym = function(r, o) { r.on("button.".concat(o), function(t, e, i, n, s) { Fm.hasOwnProperty(e) && r.emit("".concat(Fm[e], ".").concat(o), t, i, n, s) }) };
    Object.assign(Dm.prototype, Am), p.register("dialog", function(t) { var e = new Dm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Dialog", Dm); var Xm = function() { w(o, Dm); var r = T(o);

        function o(t, e) { var i, n, s; return X(this, o), void 0 === e && (e = {}), e.hasOwnProperty("choices") || (e.choices = []), "function" == typeof e.choices ? (n = e.choices, s = void 0, e.choices = []) : (n = e.createChoiceCallback, s = e.createChoiceCallbackScope), (i = r.call(this, t, e)).type = "rexChoices", i.setCreateChoiceCallback(n, s), i } return k(o, [{ key: "setCreateChoiceCallback", value: function(t, e) { return this.createChoiceCallback = t, this.createChoiceCallbackScope = e, this } }, { key: "setChildText", value: function(t, e) { return "string" == typeof t && (t = this.childrenMap[t]), t && (e ? t.show().setText(e) : t.hide()), this } }, { key: "setTitle", value: function(t) { return this.setChildText("title", t), this } }, { key: "setContent", value: function(t) { return this.setChildText("content", t), this } }, { key: "setDescription", value: function(t) { return this.setChildText("description", t), this } }, { key: "setChoices", value: function(t) { var e = this.childrenMap.choices; if (t.length > e.length) { var i = this.createChoiceCallback,
                        n = this.createChoiceCallbackScope; if (i)
                        for (var s = 0, r = t.length - e.length; s < r; s++) { var o;
                            o = n ? i.call(n, this.scene) : i(this.scene), this.addChoice(o) } } for (s = 0, r = e.length; s < r; s++) this.setChildText(e[s], t[s]); return this } }, { key: "setText", value: function(t) { return void 0 === t && (t = {}), this.setTitle(t.title).setContent(t.content).setDescription(t.description).setChoices(t.choices), this } }, { key: "clickChoicePromise", value: function(t) { t && this.setText(t).layout(); var e = this; return new Promise(function(s, t) { e.once("choice.click", function(t, e, i, n) { s({ button: t, index: e, pointer: i }) }) }) } }]), o }();
    p.register("choices", function(t) { var e = new Xm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Choices", Xm); var Wm = Phaser.Utils.Objects.GetValue,
        Gm = function() { w(v, oy); var p = T(v);

            function v(t, e) { var i;
                X(this, v), void 0 === e && (e = {}), e.orientation = 1, (i = p.call(this, t, e)).type = "rexHolyGrail"; var n = Wm(e, "background", void 0);
                n && i.addBackground(n); var s = Wm(e, "header", void 0); if (s) { var r = Wm(e, "proportion.header", 0),
                        o = Wm(e, "align.header", "center"); "number" == typeof(c = Wm(e, "space.header", void 0)) && (c = { bottom: c }); var a = Wm(e, "expand.header", !0);
                    i.add(s, { proportion: r, align: o, padding: c, expand: a }) } var h = new oy(t, { orientation: 0 });
                i.add(h, { proportion: 1, align: "center", padding: 0, expand: !0 }); var l = Wm(e, "leftSide", void 0); if (l) { r = Wm(e, "proportion.leftSide", 0), o = Wm(e, "align.leftSide", "center"); "number" == typeof(c = Wm(e, "space.leftSide", void 0)) && (c = { right: c });
                    a = Wm(e, "expand.leftSide", !0);
                    h.add(l, { proportion: r, align: o, padding: c, expand: a }) } var u = Wm(e, "content", void 0); if (u) { r = Wm(e, "proportion.content", 1), o = Wm(e, "align.content", "center"); var c = Wm(e, "space.content", void 0);
                    a = Wm(e, "expand.content", !0);
                    h.add(u, { proportion: r, align: o, padding: c, expand: a }) } var d = Wm(e, "rightSide", void 0); if (d) { r = Wm(e, "proportion.rightSide", 0), o = Wm(e, "align.rightSide", "center"); "number" == typeof(c = Wm(e, "space.rightSide", void 0)) && (c = { left: c });
                    a = Wm(e, "expand.rightSide", !0);
                    h.add(d, { proportion: r, align: o, padding: c, expand: a }) } var f = Wm(e, "footer", void 0); if (f) { r = Wm(e, "proportion.footer", 0), o = Wm(e, "align.footer", "center"); "number" == typeof(c = Wm(e, "space.footer", void 0)) && (c = { top: c });
                    a = Wm(e, "expand.footer", !0);
                    i.add(f, { proportion: r, align: o, padding: c, expand: a }) } return i.addChildrenMap("background", n), i.addChildrenMap("header", s), i.addChildrenMap("leftSide", l), i.addChildrenMap("content", u), i.addChildrenMap("rightSide", d), i.addChildrenMap("footer", f), i } return k(v) }();
    p.register("holyGrail", function(t) { var e = new Gm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.HolyGrail", Gm); var Vm = { getButtonsSizer: function(t) { return this.childrenMap["".concat(t, "ButtonsSizer")] }, getButton: function(t, e) { var i = this.getButtonsSizer(t); return i ? i.getButton(e) : void 0 }, setButtonEnable: function(t, e, i) { return this.getButtonsSizer(t).setButtonEnable(e, i), this }, setLeftButtonEnable: function(t, e) { return this.childrenMap.leftButtonsSizer.setButtonEnable(t, e), this }, setRightButtonEnable: function(t, e) { return this.childrenMap.rightButtonsSizer.setButtonEnable(t, e), this }, setTopButtonEnable: function(t, e) { return this.childrenMap.topButtonsSizer.setButtonEnable(t, e), this }, setBottomButtonEnable: function(t, e) { return this.childrenMap.bottomButtonsSizer.setButtonEnable(t, e), this }, toggleButtonEnable: function(t, e) { return this.getButtonsSizer(t).toggleButtonEnable(e), this }, toggleLeftButtonEnable: function(t) { return this.childrenMap.leftButtonsSizer.toggleButtonEnable(t), this }, toggleRightButtonEnable: function(t) { return this.childrenMap.rightButtonsSizer.toggleButtonEnable(t), this }, toggleTopButtonEnable: function(t) { return this.childrenMap.topButtonsSizer.toggleButtonEnable(t), this }, toggleBottomButtonEnable: function(t) { return this.childrenMap.bottomButtonsSizer.toggleButtonEnable(t), this }, getButtonEnable: function(t, e) { return this.getButtonsSizer(t).getButtonEnable(e) }, getLeftButtonEnable: function(t) { return this.childrenMap.leftButtonsSizer.getButtonEnable(t) }, getRightButtonEnable: function(t) { return this.childrenMap.rightButtonsSizer.getButtonEnable(t) }, getTopButtonEnable: function(t) { return this.childrenMap.topButtonsSizer.getButtonEnable(t) }, getBottomButtonEnable: function(t) { return this.childrenMap.bottomButtonsSizer.getButtonEnable(t) }, emitButtonClick: function(t, e) { var i = this.getButtonsSizer(t); return i && i.emitButtonClick(e), this }, emitLeftButtonClick: function(t) { return this.childrenMap.leftButtonsSizer.emitButtonClick(t), this }, emitRightButtonClick: function(t) { return this.childrenMap.rightButtonsSizer.emitButtonClick(t), this }, emitTopButtonClick: function(t) { return this.childrenMap.topButtonsSizer.emitButtonClick(t), this }, emitBottomButtonClick: function(t) { return this.childrenMap.bottomButtonsSizer.emitButtonClick(t), this }, getLeftButton: function(t) { return this.childrenMap.leftButtonsSizer.getButton(t) }, getRightButton: function(t) { return this.childrenMap.rightButtonsSizer.getButton(t) }, getTopButton: function(t) { return this.childrenMap.topButtonsSizer.getButton(t) }, getBottomButton: function(t) { return this.childrenMap.bottomButtonsSizer.getButton(t) }, showButton: function(t, e) { return Cd(this.getButton(t, e)), this }, showLeftButton: function(t) { return Cd(this.getLeftButton(t)), this }, showRightButton: function(t) { return Cd(this.getRightButton(t)), this }, showTopButton: function(t) { return Cd(this.getTopButton(t)), this }, showBottomButton: function(t) { return Cd(this.getBottomButton(t)), this }, hideButton: function(t, e) { return wd(this.getButton(t, e)), this }, hideLeftButton: function(t) { return wd(this.getLeftButton(t)), this }, hideRightButton: function(t) { return wd(this.getRightButton(t)), this }, hideTopButton: function(t) { return wd(this.getTopButton(t)), this }, hideBottomButton: function(t) { return wd(this.getBottomButton(t)), this }, addButton: function(t, e) { return this.getButtonsSizer(t).addButton(e), this }, addLeftButton: function(t) { return this.addButton("left", t), this }, addRightButton: function(t) { return this.addButton("right", t), this }, addTopButton: function(t) { return this.addButton("top", t), this }, removeButton: function(t, e, i) { return this.getButtonsSizer(t).removeButton(e, i), this }, removeLeftButton: function(t, e) { return this.removeButton("left", t, e), this }, removeRightButton: function(t, e) { return this.removeButton("right", t, e), this }, removeTopButton: function(t, e) { return this.removeButton("top", t, e), this }, removeBottomButton: function(t, e) { return this.removeButton("bottom", t, e), this }, clearButtons: function(t, e) { return this.getButtonsSizer(t).clearButtons(e), this }, clearLeftButtons: function(t) { return this.clearButtons("left", t), this }, clearRightButtons: function(t) { return this.clearButtons("right", t), this }, clearTopButtons: function(t) { return this.clearButtons("top", t), this }, clearBottomButtonss: function(t) { return this.clearButtons("bottom", t), this }, forEachButton: function(t, e, i) { return this.getButtonsSizer(t).forEachButtton(e, i), this }, forEachLeftButton: function(t, e) { return this.childrenMap.leftButtonsSizer.forEachButtton(t, e), this }, forEachRightButton: function(t, e) { return this.childrenMap.rightButtonsSizer.forEachButtton(t, e), this }, forEachTopButton: function(t, e) { return this.childrenMap.topButtonsSizer.forEachButtton(t, e), this }, forEachBottomButton: function(t, e) { return this.childrenMap.bottomButtonsSizer.forEachButtton(t, e), this } },
        Um = Phaser.Utils.Objects.GetValue,
        Hm = function() { w(M, Cy); var O = T(M);

            function M(t, e) { var i;
                X(this, M), void 0 === e && (e = {}), e.column = 3, e.row = 3, (i = O.call(this, t, e)).type = "rexTabs", i.eventEmitter = Um(e, "eventEmitter", W(i)); var n, s, r, o, a = Um(e, "background", void 0),
                    h = Um(e, "panel", void 0),
                    l = Um(e, "leftButtons", void 0),
                    u = Um(e, "leftButtonsBackground", void 0),
                    c = Um(e, "rightButtons", void 0),
                    d = Um(e, "rightButtonsBackground", void 0),
                    f = Um(e, "topButtons", void 0),
                    p = Um(e, "topButtonsBackground", void 0),
                    v = Um(e, "bottomButtons", void 0),
                    g = Um(e, "bottomButtonsBackground", void 0),
                    y = Um(e, "click", void 0); if (a && i.addBackground(a), h && i.add(h, 1, 1, "center", 0, !0), l) { var m = Um(e, "space.leftButtonsOffset", 0),
                        k = Um(e, "space.leftButton", 0);
                    n = new ym(t, { groupName: "left", background: u, buttons: l, orientation: 1, space: { item: k }, align: Um(e, "align.leftButtons", void 0), click: y, eventEmitter: i.eventEmitter }); var b = { top: m };
                    i.add(n, 0, 1, "top", b, !1) } if (c) { var x = Um(e, "space.rightButtonsOffset", 0),
                        C = Um(e, "space.rightButton", 0);
                    s = new ym(t, { groupName: "right", background: d, buttons: c, orientation: 1, space: { item: C }, align: Um(e, "align.rightButtons", void 0), click: y, eventEmitter: i.eventEmitter });
                    b = { top: x };
                    i.add(s, 2, 1, "top", b, !1) } if (f) { var w = Um(e, "space.topButtonsOffset", 0),
                        S = Um(e, "space.topButton", 0);
                    r = new ym(t, { groupName: "top", background: p, buttons: f, orientation: 0, space: { item: S }, align: Um(e, "align.topButtons", void 0), click: y, eventEmitter: i.eventEmitter });
                    b = { left: w };
                    i.add(r, 1, 0, "left", b, !1) } if (v) { var P = Um(e, "space.bottomButtonsOffset", 0),
                        T = Um(e, "space.bottomButton", 0);
                    o = new ym(t, { groupName: "bottom", background: g, buttons: v, orientation: 0, space: { item: T }, align: Um(e, "align.bottomButtons", void 0), click: y, eventEmitter: i.eventEmitter });
                    b = { left: P };
                    i.add(o, 1, 2, "left", b, !1) } return i.addChildrenMap("background", a), i.addChildrenMap("panel", h), i.addChildrenMap("leftButtons", l), i.addChildrenMap("rightButtons", c), i.addChildrenMap("topButtons", f), i.addChildrenMap("bottomButtons", v), i.addChildrenMap("leftButtonsSizer", n), i.addChildrenMap("rightButtonsSizer", s), i.addChildrenMap("topButtonsSizer", r), i.addChildrenMap("bottomButtonsSizer", o), i } return k(M) }();
    Object.assign(Hm.prototype, Vm), p.register("tabs", function(t) { var e = new Hm(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Tabs", Hm);

    function Nm(t, e, i) { var n; return t.y === e.y ? n = qm(i.x, t.x, e.x) : t.x === e.x && (n = qm(i.y, t.y, e.y)), n }

    function Jm(t, e, i) { var n, s;
        this.enable && ($m.x = e, $m.y = i, s = this.reverseAxis ? (n = this.getEndPoint(), this.getStartPoint()) : (n = this.getStartPoint(), this.getEndPoint()), this.value = Nm(n, s, $m)) }

    function Km(t) { if (this.enable && t.isDown) { var e, i;
            Qm.x = t.worldX, Qm.y = t.worldY, i = this.reverseAxis ? (e = this.getEndPoint(), this.getStartPoint()) : (e = this.getStartPoint(), this.getEndPoint()); var n = Nm(e, i, Qm);
            this.stopEaseValue(), 0 === this.easeValueDuration || Math.abs(this.value - n) < .1 ? this.value = n : this.easeValueTo(n) } }

    function Zm(t, e) { void 0 === e && (e = tk); var i = this.childrenMap.thumb,
            n = i.x,
            s = i.y; return sd(i, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, t), e.x = i.x, e.y = i.y, i.x = n, i.y = s, e } var qm = Phaser.Math.Percent,
        $m = {},
        Qm = {},
        tk = {},
        ek = Phaser.Display.Align.LEFT_CENTER,
        ik = Phaser.Display.Align.TOP_CENTER,
        nk = {},
        sk = Phaser.Display.Align.RIGHT_CENTER,
        rk = Phaser.Display.Align.BOTTOM_CENTER,
        ok = {},
        ak = Phaser.Math.Linear,
        hk = {},
        lk = Phaser.Display.Align.LEFT_CENTER,
        uk = Phaser.Display.Align.TOP_CENTER,
        ck = Phaser.Display.Align.RIGHT_CENTER,
        dk = Phaser.Display.Align.BOTTOM_CENTER,
        fk = Phaser.Utils.Objects.GetValue,
        pk = Phaser.Math.Clamp,
        vk = Phaser.Math.Snap.To,
        gk = function() { w(l, Yu(oy)); var h = T(l);

            function l(t, e) { var i;
                X(this, l), (i = h.call(this, t, e)).type = "rexSlider", i.bootProgressBase(e), i.reverseAxis = fk(e, "reverseAxis", !1); var n = fk(e, "background", void 0),
                    s = fk(e, "track", void 0),
                    r = fk(e, "indicator", void 0),
                    o = fk(e, "thumb", void 0);
                n && i.addBackground(n), s && i.add(s, { proportion: 1, expand: !0, minWidth: 0 === i.orientation ? 0 : void 0, minHeight: 1 === i.orientation ? 0 : void 0 }), r && i.pin(r), o && i.pin(o); var a = fk(e, "input", 0); switch ("string" == typeof a && (a = yk[a]), a) {
                    case 0:
                        o && (o.setInteractive(), i.scene.input.setDraggable(o), o.on("drag", Jm, W(i)).on("dragstart", function(t) { this.eventEmitter.emit("inputstart", t) }, W(i)).on("dragend", function(t) { this.eventEmitter.emit("inputend", t) }, W(i))); break;
                    case 1:
                        i.on("pointerdown", Km, W(i)).on("pointermove", Km, W(i)).on("pointerdown", function(t) { this.eventEmitter.emit("inputstart", t) }, W(i)).on("pointerup", function(t) { this.eventEmitter.emit("inputend", t) }, W(i)).on("pointerover", function(t) { t.isDown && this.eventEmitter.emit("inputstart", t) }, W(i)).on("pointerout", function(t) { t.isDown && this.eventEmitter.emit("inputend", t) }, W(i)).setInteractive() } return i.addChildrenMap("background", n), i.addChildrenMap("track", s), i.addChildrenMap("indicator", r), i.addChildrenMap("thumb", o), i.setEnable(fk(e, "enable", void 0)), i.setGap(fk(e, "gap", void 0)), i.setValue(fk(e, "value", 0), fk(e, "min", void 0), fk(e, "max", void 0)), i } return k(l, [{ key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setGap", value: function(t) { return this.gap = t, this } }, { key: "value", get: function() { return this._value }, set: function(t) { void 0 !== this.gap && (t = vk(t, this.gap)); var e = this._value;
                    this._value = pk(t, 0, 1), e !== this._value && (this.updateThumb(this._value), this.updateIndicator(this._value), this.eventEmitter.emit("valuechange", this._value, e, this.eventEmitter)) } }, { key: "runLayout", value: function(t, e, i) { return this.ignoreLayout || (O(C(l.prototype), "runLayout", this).call(this, t, e, i), this.updateThumb(), this.updateIndicator()), this } }]), l }(),
        yk = { pan: 0, drag: 0, click: 1, none: -1 },
        mk = { getStartPoint: function(t) { if (void 0 === t && (t = nk), this.childrenMap.thumb) { var e = 0 === this.orientation ? ek : ik;
                    Zm.call(this, e, t) } else 0 === this.orientation ? (t.x = this.innerLeft + 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.innerTop + 1); return t }, getEndPoint: function(t) { if (void 0 === t && (t = ok), this.childrenMap.thumb) { var e = 0 === this.orientation ? sk : rk;
                    Zm.call(this, e, t) } else 0 === this.orientation ? (t.x = this.innerRight - 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.innerBottom - 1); return t }, updateThumb: function(t) { var e, i, n, s, r, o, a = this.childrenMap.thumb; return void 0 === a || (void 0 === t && (t = this.value), i = this.reverseAxis ? (e = this.getEndPoint(), this.getStartPoint()) : (e = this.getStartPoint(), this.getEndPoint()), n = t, s = e, r = i, void 0 === (o = a) && (o = hk), o.x = ak(s.x, r.x, n), o.y = ak(s.y, r.y, n), this.resetChildPositionState(a)), this }, updateIndicator: function(t) { var e = this.childrenMap.indicator; if (void 0 === e) return this;
                void 0 === t && (t = this.value); var i, n, s, r = this.reverseAxis,
                    o = this.childrenMap.thumb; if (o)
                    if (0 === this.orientation) { var a = Zs(o); if (r) { h = o.x - a * o.originX;
                            i = this.right - h } else { var h;
                            i = (h = o.x - a * o.originX) + a - this.left } } else { var l = qs(o); if (r) { u = o.y - l * o.originY;
                            n = this.bottom - u } else { var u;
                            n = (u = o.y - l * o.originY) + l - this.top } }
                else 0 === this.orientation ? i = this.width * t : n = this.height * t;
                Bd(e, i, n), s = r ? 0 === this.orientation ? ck : dk : 0 === this.orientation ? lk : uk, nd(e, this, s), this.resetChildPositionState(e) } };
    Object.assign(gk.prototype, mk), p.register("slider", function(t) { var e = new gk(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Slider", gk);

    function kk(t) { var e = xk(t, "scrollMode", 0); return "string" == typeof e && (e = bk[e]), e } var bk = { v: 0, vertical: 0, h: 1, horizontal: 1 },
        xk = Phaser.Utils.Objects.GetValue,
        Ck = Phaser.Utils.Objects.GetValue,
        wk = function() { w(p, oy); var f = T(p);

            function p(t, e) { var i;
                X(this, p), (i = f.call(this, t, e)).type = "rexScrollBar"; var n, s = Ck(e, "background", void 0),
                    r = Ck(e, "buttons", void 0),
                    o = Ck(r, "top", Ck(r, "left", void 0)),
                    a = Ck(r, "bottom", Ck(r, "right", void 0)),
                    h = Ck(e, "slider", void 0);
                s && i.addBackground(s), o && (i.add(o), new Uf(o).on("intouch", function() { if (this.enable) { var t = n.reverseAxis ? this.scrollStep : -this.scrollStep;
                        this.value += t } }, W(i))); if (h) { var l; if (h.orientation = i.orientation, h.eventEmitter = W(i), h.value = null, 0 === i.orientation) l = void 0 === Ck(h, "width", void 0) ? 1 : 0;
                    else l = void 0 === Ck(h, "height", void 0) ? 1 : 0;
                    n = new gk(t, h), t.add.existing(n), i.add(n, { proportion: l }) }
                a && (i.add(a), new Uf(a).on("intouch", function() { if (this.enable) { var t = n.reverseAxis ? -this.scrollStep : this.scrollStep;
                        this.value += t } }, W(i))); var u = [o, a];
                i.addChildrenMap("background", s), i.addChildrenMap("slider", n), i.addChildrenMap("buttons", u); var c = Ck(e, "valuechangeCallback", null); if (null !== c) { var d = Ck(e, "valuechangeCallbackScope", void 0);
                    i.on("valuechange", c, d) } return i.setEnable(Ck(e, "enable", void 0)), i.setValue(Ck(e, "value", 0)), i.setScrollStep(Ck(r, "step", .01)), i } return k(p, [{ key: "setScrollStep", value: function(t) { return this.scrollStep = t, this } }, { key: "enable", get: function() { return !!this.childrenMap.slider && this.childrenMap.slider.enable }, set: function(t) { this.childrenMap.slider && this.childrenMap.slider.setEnable(t) } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "value", get: function() { return this.childrenMap.slider ? this.childrenMap.slider.value : 0 }, set: function(t) { this.childrenMap.slider && (this.childrenMap.slider.value = t) } }, { key: "setValue", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.setValue(t, e, i), this } }, { key: "addValue", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.addValue(t, e, i), this } }, { key: "getValue", value: function(t, e) { return this.childrenMap.slider ? this.childrenMap.slider.getValue(t, e) : 0 } }, { key: "easeValueTo", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.easeValueTo(t, e, i), this } }, { key: "stopEaseValue", value: function() { return this.childrenMap.slider && this.childrenMap.slider.stopEaseValue(), this } }, { key: "setEaseValueDuration", value: function(t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueDuration(t), this } }, { key: "setEaseValueFunction", value: function(t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueFunction(t), this } }]), p }(),
        Sk = function() { w(o, wk); var r = T(o);

            function o(t, e) { var i;
                X(this, o), void 0 === e && (e = {}); var n = be(e);
                (e = { slider: n }).orientation = n.orientation, delete n.orientation, e.background = n.background, delete n.background, e.buttons = n.buttons, delete n.buttons; var s = (i = r.call(this, t, e)).childrenMap.slider; return i.addChildrenMap("track", s.childrenMap.track), i.addChildrenMap("indicator", s.childrenMap.indicator), i.addChildrenMap("thumb", s.childrenMap.thumb), i } return k(o) }(),
        Pk = function() { w(s, Yf); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, e)).parent = t, i.init(), i } return k(s, [{ key: "init", value: function() { this.start("IDLE") } }, { key: "next_IDLE", value: function() { var t, e = this.parent; return e.dragState.isDown && (t = 0 === e.dragThreshold ? "DRAG" : "DRAGBEGIN"), t } }, { key: "update_IDLE", value: function() { this.next() } }, { key: "next_DRAGBEGIN", value: function() { var t = this.parent,
                        e = t.dragState; return e.isDown ? e.pointer.getDistance() >= t.dragThreshold ? "DRAG" : "DRAGBEGIN" : "IDLE" } }, { key: "update_DRAGBEGIN", value: function() { this.next() } }, { key: "next_DRAG", value: function() { var t, e = this.parent; return e.dragState.isUp && (t = e.outOfBounds ? "BACK" : e.slidingEnable ? "SLIDE" : "IDLE"), t } }, { key: "update_DRAG", value: function() { var t = this.parent;
                    t.dragState.justMoved && t.dragging(), this.next() } }, { key: "enter_DRAG", value: function() { this.parent.onDragStart() } }, { key: "exit_DRAG", value: function() { this.parent.onDragEnd() } }, { key: "next_SLIDE", value: function() { var t, e = this.parent; return e.dragState.isDown ? t = "DRAG" : e.isSliding || (t = "IDLE"), t } }, { key: "enter_SLIDE", value: function() { this.parent.onSliding() } }, { key: "exit_SLIDE", value: function() { this.parent.stop() } }, { key: "update_SLIDE", value: function(t, e) { this.parent.sliding(t, e), this.next() } }, { key: "next_BACK", value: function() { var t, e = this.parent; return e.dragState.isDown ? t = "DRAG" : e.isPullBack || (t = "IDLE"), t } }, { key: "enter_BACK", value: function() { this.parent.onPullBack() } }, { key: "exit_BACK", value: function() { this.parent.stop() } }, { key: "update_BACK", value: function(t, e) { this.parent.pullBack(t, e), this.next() } }]), s }(),
        Tk = Phaser.Utils.Objects.GetValue,
        Ok = Phaser.Math.Distance.Between,
        Mk = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e))._enable = void 0, t.setInteractive(Tk(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.pointer = void 0, this.isInTouched = !1, this.holdStartTime = void 0, this.x = void 0, this.y = void 0, this.preX = void 0, this.preY = void 0, this.localX = void 0, this.localY = void 0, this.justMoved = !1, this.setEnable(Tk(t, "enable", !0)), this.holdThreshold = Tk(t, "holdThreshold", 50), this.pointerOutReleaseEnable = Tk(t, "pointerOutRelease", !0), this } }, { key: "boot", value: function() { this.parent.on("pointerdown", this.onPointIn, this), this.parent.on("pointerup", this.onPointOut, this), this.pointerOutReleaseEnable && this.parent.on("pointerout", this.onPointOut, this), this.parent.on("pointermove", this.onPointerMove, this), this.scene.sys.events.on("preupdate", this.preupdate, this) } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this.preupdate, this), this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { this._enable !== t && (t || (this.isInTouched = !1, this.pointer = void 0), this._enable = t) } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "setPointerOutReleaseEnable", value: function(t) { return void 0 === t && (t = !0), this.pointerOutReleaseEnable = t, this } }, { key: "isDown", get: function() { return this.pointer && this.pointer.isDown } }, { key: "isUp", get: function() { return !this.isDown } }, { key: "dx", get: function() { return this.x - this.preX } }, { key: "dy", get: function() { return this.y - this.preY } }, { key: "dt", get: function() { return Es(this.scene) } }, { key: "speed", get: function() { return this.x === this.preX && this.y === this.preY ? 0 : Ok(this.preX, this.preY, this.x, this.y) / (.001 * this.dt) } }, { key: "speedX", get: function() { return this.dx / (.001 * this.dt) } }, { key: "speedY", get: function() { return this.dy / (.001 * this.dt) } }, { key: "onPointIn", value: function(t, e, i) { this.enable && t.isDown && void 0 === this.pointer && (this.pointer = t, this.localX = e, this.localY = i) } }, { key: "onPointOut", value: function(t) { this.enable && this.pointer === t && (this.pointer = void 0) } }, { key: "onPointerMove", value: function(t, e, i) { this.enable && t.isDown && this.pointer === t && (this.localX = e, this.localY = i) } }, { key: "preupdate", value: function(t) { if (this.enable) { var e = this.pointer;
                        this.justMoved = !1, e && !this.isInTouched ? (this.x = e.worldX, this.y = e.worldY, this.preX = e.worldX, this.preY = e.worldY, this.isInTouched = !0, this.holdStartTime = void 0, this.emit("touchstart", e, this.localX, this.localY)) : e && this.isInTouched ? this.x === e.x && this.y === e.y ? void 0 === this.holdStartTime ? this.holdStartTime = t : t - this.holdStartTime > this.holdThreshold && (this.preX = this.x, this.preY = this.y) : (this.preX = this.x, this.preY = this.y, this.x = e.worldX, this.y = e.worldY, this.holdStartTime = void 0, this.justMoved = !0, this.emit("touchmove", e, this.localX, this.localY)) : !e && this.isInTouched && (this.isInTouched = !1, this.holdStartTime = void 0, this.emit("touchend", e)) } } }]), s }(),
        Ek = Phaser.Utils.Objects.GetValue,
        _k = function() {
            function e(t) { X(this, e), this.resetFromJSON(t) } return k(e, [{ key: "resetFromJSON", value: function(t) { return this.setValue(Ek(t, "value", 0)), this.setSpeed(Ek(t, "speed", 0)), this.setAcceleration(Ek(t, "acceleration", 0)), this } }, { key: "reset", value: function() { this.setValue(0), this.setSpeed(0), this.setAcceleration(0) } }, { key: "setValue", value: function(t) { return this.value = t, this } }, { key: "setSpeed", value: function(t) { return this.speed = t, this } }, { key: "setAcceleration", value: function(t) { return this.acceleration = t, this } }, { key: "updateSpeed", value: function(t) { return 0 !== this.acceleration && (this.speed += this.acceleration * t, this.speed < 0 && (this.speed = 0)), this } }, { key: "getDeltaValue", value: function(t) { return this.updateSpeed(t), this.speed <= 0 ? 0 : this.speed * t } }, { key: "update", value: function(t) { return this.updateSpeed(t), 0 < this.speed && (this.value += this.getDeltaValue(t)), this } }, { key: "isMoving", get: function() { return 0 < this.speed } }]), e }(),
        Rk = function() {
            function t() { X(this, t), this.value, this.dir, this.movement = new _k() } return k(t, [{ key: "init", value: function(t, e, i, n, s) { return this.value = t, this.end = s, this.dir = void 0 !== s ? t < s : e, this.movement.setSpeed(i).setAcceleration(-n), this } }, { key: "stop", value: function() { this.movement.reset() } }, { key: "update", value: function(t) { var e = this.movement.getDeltaValue(t); return this.dir || (e = -e), void 0 === this.end ? this.value += e : 0 === e ? this.value = this.end : (this.value += e, this.dir ? this.value > this.end && (this.value = this.end) : this.value < this.end && (this.value = this.end)), this } }, { key: "isMoving", get: function() { return this.movement.isMoving } }]), t }(),
        Bk = Phaser.Utils.Objects.GetValue,
        Ik = Phaser.Math.Clamp,
        Lk = function() { w(h, ds); var a = T(h);

            function h(t, e) { var i;
                X(this, h), i = a.call(this, t, e); var n = Bk(e, "enable", !0);
                i._state = new Pk(W(i), { enable: n, eventEmitter: !1 }); var s = { inputConfig: Bk(e, "inputConfig", void 0), enable: n, pointerOutRelease: Bk(e, "pointerOutRelease", !0), eventEmitter: !1 };
                i.dragState = new Mk(t, s), i._enable = void 0, i._value = void 0, i._slowDown = new Rk(); var r = Bk(e, "valuechangeCallback", null); if (null !== r) { var o = Bk(e, "valuechangeCallbackScope", void 0);
                    i.on("valuechange", r, o) } if (null !== (r = Bk(e, "overmaxCallback", null))) { o = Bk(e, "overmaxCallbackScope", void 0);
                    i.on("overmax", r, o) } if (null !== (r = Bk(e, "overminCallback", null))) { o = Bk(e, "overminCallbackScope", void 0);
                    i.on("overmin", r, o) } return i.resetFromJSON(e), i.boot(), i } return k(h, [{ key: "resetFromJSON", value: function(t) { this.setOrientationMode(Bk(t, "orientation", 0)), this.setDragThreshold(Bk(t, "threshold", 10)), this.setSlidingDeceleration(Bk(t, "slidingDeceleration", 5e3)), this.setBackDeceleration(Bk(t, "backDeceleration", 2e3)); var e = Bk(t, "bounds", void 0); return e ? this.setBounds(e) : this.setBounds(Bk(t, "max", 0), Bk(t, "min", 0)), this.setValue(Bk(t, "value", this.maxValue || 0)), this.setEnable(Bk(t, "enable", !0)), this } }, { key: "boot", value: function() { this.scene.sys.events.on("preupdate", this._state.update, this._state) } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.scene.sys.events.off("preupdate", this._state.update, this._state), this._state.destroy(t), this.dragState.destroy(t), this._state = void 0, this.dragState = void 0, O(C(h.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) return this._enable = t, this._state.setEnable(t), this.dragState.setEnable(t), this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "setOrientationMode", value: function(t) { return "string" == typeof t && (t = Ak[t]), this.orientationMode = t, this } }, { key: "setDragThreshold", value: function(t) { return this.dragThreshold = t, this } }, { key: "setSlidingDeceleration", value: function(t) { return this.slidingDeceleration = t, this } }, { key: "setBackDeceleration", value: function(t) { return this.backDeceleration = t, this } }, { key: "setBounds", value: function(t, e) { if (Array.isArray(t)) { var i = t;
                        t = i[0], e = i[1] } return t < e ? (this.minValue = t, this.maxValue = e) : (this.minValue = e, this.maxValue = t), this } }, { key: "value", get: function() { return this._value }, set: function(t) { if (t !== this._value) { var e = this._value,
                            i = this.overMax(t),
                            n = this.overMin(t);
                        i && this.emit("overmax", t, e), n && this.emit("overmin", t, e), this.backEnable || (i && (t = this.maxValue), n && (t = this.minValue)), this._value = t, this.emit("valuechange", t, e) } } }, { key: "setValue", value: function(t, e) { return void 0 === e && (e = !1), e && (t = Ik(t, this.minValue, this.maxValue)), this.value = t, this } }, { key: "addValue", value: function(t, e) { return this.setValue(this.value + t, e), this } }, { key: "state", get: function() { return this._state.state } }, { key: "isDragging", get: function() { return this.dragState.isInTouched } }, { key: "outOfMaxBound", get: function() { return this.overMax(this.value) } }, { key: "outOfMinBound", get: function() { return this.overMin(this.value) } }, { key: "outOfBounds", get: function() { return this.outOfMinBound || this.outOfMaxBound } }, { key: "overMax", value: function(t) { return null != this.maxValue && t > this.maxValue } }, { key: "overMin", value: function(t) { return null != this.minValue && t < this.minValue } }, { key: "backEnable", get: function() { return "number" == typeof this.backDeceleration } }, { key: "isPullBack", get: function() { return this._slowDown.isMoving } }, { key: "slidingEnable", get: function() { return "number" == typeof this.slidingDeceleration } }, { key: "isSliding", get: function() { return this._slowDown.isMoving } }, { key: "dragDelta", get: function() { return 0 === this.orientationMode ? this.dragState.dy : 1 === this.orientationMode ? this.dragState.dx : 0 } }, { key: "dragSpeed", get: function() { return 0 === this.orientationMode ? this.dragState.speedY : 1 === this.orientationMode ? this.dragState.speedX : 0 } }, { key: "onDragStart", value: function() { this.emit("dragstart") } }, { key: "onDragEnd", value: function() { this.emit("dragend") } }, { key: "dragging", value: function() { this.value += this.dragDelta } }, { key: "onSliding", value: function() { var t = this.value,
                        e = this.dragSpeed; if (0 === e) return this._slowDown.stop(), void this._state.next(); var i = this.slidingDeceleration;
                    this._slowDown.init(t, 0 < e, Math.abs(e), i) } }, { key: "sliding", value: function(t, e) { e *= .001; var i = this._slowDown.update(e).value;
                    this.overMax(i) ? (this.value = this.maxValue, this._slowDown.stop()) : this.overMin(i) ? (this.value = this.minValue, this._slowDown.stop()) : this.value = i } }, { key: "onPullBack", value: function() { var t = this.value,
                        e = this.outOfMinBound ? this.minValue : this.maxValue,
                        i = Math.abs(e - t),
                        n = this.backDeceleration,
                        s = Math.sqrt(2 * n * i);
                    this._slowDown.init(t, void 0, s, n, e) } }, { key: "pullBack", value: function(t, e) { e *= .001, this.value = this._slowDown.update(e).value, this._slowDown.isMoving || this._state.next() } }, { key: "stop", value: function() { this._slowDown.stop() } }]), h }(),
        Ak = { y: 0, v: 0, vertical: 0, x: 1, h: 1, horizontal: 1 },
        jk = Phaser.Utils.Objects.GetValue,
        Dk = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i;
                (X(this, s), (i = n.call(this, t, e)).parent !== i.scene ? i.focusMode = jk(e, "focus", !1) : i.focusMode = !1, i.setSpeed(jk(e, "speed", .1)), i.setEnable(jk(e, "enable", !0)), i.focusMode) ? (t = i.parent).setInteractive(jk(e, "inputConfig", void 0)).on("wheel", function(t, e, i, n, s) { this.enable && this.scroll(i) }, W(i)): i.scene.input.on("wheel", i.onSceneScroll, W(i)); return i } return k(s, [{ key: "destroy", value: function() { this.focusMode || this.scene.input.off("wheel", this.onSceneScroll, this) } }, { key: "onSceneScroll", value: function(t, e, i, n) { this.enable && this.scroll(n) } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "setSpeed", value: function(t) { return this.speed = t, this } }, { key: "scroll", value: function(t) { t *= this.speed, this.emit("scroll", t, this.parent, this) } }]), s }(),
        zk = Phaser.Utils.Objects.GetValue,
        Fk = { right: 0, left: 1, bottom: 0, top: 1 };
    oy.prototype.runLayout; var Yk = function() { var t = Math.min(this.childVisibleHeight / this.childHeight, 1),
                e = this.childrenMap.slider,
                i = e.childrenMap.track,
                n = e.childrenMap.thumb,
                s = this.minThumbSize; if (0 === this.scrollMode) { var r = i.displayHeight * t;
                void 0 !== s && r < s && (r = s), Bd(n, void 0, r) } else { var o = i.displayWidth * t;
                void 0 !== s && o < s && (o = s), Bd(n, o, void 0) }
            Xk.call(this) },
        Xk = function() { var t = this.childrenMap.slider,
                e = t.minWidth,
                i = t.minHeight;
            t.minWidth = t.width, t.minHeight = t.height, t.layout(), t.minWidth = e, t.minHeight = i },
        Wk = Phaser.Utils.Objects.GetValue,
        Gk = Phaser.Math.Clamp,
        Vk = function() { w(p, oy); var f = T(p);

            function p(t, e) { var i;
                X(this, p), void 0 === e && (e = {}); var n = kk(e);
                e.orientation = 0 === n ? 1 : 0, (i = f.call(this, t, e)).type = Wk(e, "type", "rexScrollable"); var s = Wk(e, "background", void 0),
                    r = function(e, t) { var i, n = e.scene,
                            s = kk(t),
                            r = new oy(n, { orientation: s }),
                            o = zk(t, "child.gameObject", void 0),
                            a = 0,
                            h = zk(t, "slider", void 0),
                            l = 0,
                            u = zk(h, "position", 0); "string" == typeof u && (u = Fk[u]); var c, d, f = 0 === u,
                            p = zk(t, "scroller", !0),
                            v = zk(t, "mouseWheelScroller", !1); if (o) { var g = zk(t, "space.child", 0); if (e.childMargin = {}, "number" != typeof g) { var y = g;
                                0 === s ? (a = { left: zk(y, "left", 0), right: zk(y, "right", 0) }, e.childMargin.top = zk(y, "top", 0), e.childMargin.bottom = zk(y, "bottom", 0)) : (a = { top: zk(y, "top", 0), bottom: zk(y, "bottom", 0) }, e.childMargin.top = zk(y, "left", 0), e.childMargin.bottom = zk(y, "right", 0)) } else h && (a = 0 === s ? f ? { right: g } : { left: g } : f ? { bottom: g } : { top: g }), e.childMargin.top = 0, e.childMargin.bottom = 0;
                            h ? (!0 === h && (h = {}), h.orientation = 0 === r.orientation ? 1 : 0, i = new Sk(n, h), l = zk(t, "space.slider", 0), e.adaptThumbSizeMode = zk(h, "adaptThumbSize", !1), e.minThumbSize = zk(h, "minThumbSize", void 0)) : (e.adaptThumbSizeMode = !1, e.minThumbSize = void 0), p && (!0 === p && (p = {}), p.orientation = s, c = new Lk(o, p)), v && (d = new Dk(o, v)), i && !f && r.add(i, { proportion: 0, align: "center", padding: l, expand: !0 }); var m = zk(t, "child.proportion", 1),
                                k = zk(t, "child.expand", !0);
                            r.add(o, { proportion: m, align: "center", padding: a, expand: k }), i && f && r.add(i, { proportion: 0, align: "center", padding: l, expand: !0 }) } return i && i.on("valuechange", function(t) { e.t = t, e.emit("scroll", e) }), c && c.on("valuechange", function(t) { e.childOY = t, e.emit("scroll", e) }), d && d.on("scroll", function(t) { e.addChildOY(-t, !0) }), e.addChildrenMap("child", o), e.addChildrenMap("slider", i), e.addChildrenMap("scroller", c), e.addChildrenMap("mouseWheelScroller", d), r }(W(i), e),
                    o = Wk(e, "header", void 0),
                    a = Wk(e, "footer", void 0); if (s && i.addBackground(s), o) { var h = Wk(e, "align.header", "center"),
                        l = Wk(e, "space.header", 0);
                    c = 0 === n ? { bottom: l } : { right: l }; var u = Wk(e, "expand.header", !0);
                    i.add(o, { proportion: 0, align: h, padding: c, expand: u }) } if (r && i.add(r, { proportion: 1, align: "center", padding: 0, expand: !0 }), a) { h = Wk(e, "align.footer", "center"); var c, d = Wk(e, "space.footer", 0);
                    c = 0 === n ? { top: d } : { left: d };
                    u = Wk(e, "expand.footer", !0);
                    i.add(a, { proportion: 0, align: h, padding: c, expand: u }) } return i.addChildrenMap("background", s), i.addChildrenMap("header", o), i.addChildrenMap("footer", a), i.runLayoutFlag = !1, i } return k(p, [{ key: "runLayout", value: function(t, e, i) { return this.ignoreLayout || (O(C(p.prototype), "runLayout", this).call(this, t, e, i), this.resizeController(), this.runLayoutFlag || (this.runLayoutFlag = !0, this.setT(0))), this } }, { key: "t", get: function() { var t = this.childrenMap.child.t,
                        e = this.childMargin; if (0 !== e.top || 0 !== e.bottom) { var i = this.childrenMap.child,
                            n = i.topChildOY - i.bottomChildOY,
                            s = n + e.top + e.bottom;
                        t = (n * t + e.top) / s } return t }, set: function(t) { var e = this.childMargin; if (0 !== e.top || 0 !== e.bottom) { var i = this.childrenMap.child,
                            n = i.topChildOY - i.bottomChildOY;
                        t = ((n + e.top + e.bottom) * t - e.top) / n }
                    this.childrenMap.child.t = t, this.updateController() } }, { key: "childOY", get: function() { return this.childrenMap.child.childOY }, set: function(t) { this.childrenMap.child.childOY = t, this.updateController() } }, { key: "topChildOY", get: function() { return this.childrenMap.child.topChildOY + this.childMargin.top } }, { key: "bottomChildOY", get: function() { return this.childrenMap.child.bottomChildOY - this.childMargin.bottom } }, { key: "childVisibleHeight", get: function() { return this.childrenMap.child.childVisibleHeight } }, { key: "childHeight", get: function() { return this.childrenMap.child.childHeight } }, { key: "isOverflow", get: function() { var t = this.childrenMap.child; return t.topChildOY !== t.bottomChildOY } }, { key: "scrollMode", get: function() { return 0 === this.orientation ? 1 : 0 } }, { key: "setChildOY", value: function(t, e) { return void 0 === e && (e = !1), e && (t = Gk(t, this.bottomChildOY, this.topChildOY)), this.childOY = t, this } }, { key: "addChildOY", value: function(t, e) { return this.setChildOY(this.childOY + t, e), this } }, { key: "setT", value: function(t, e) { return void 0 === e && (e = !1), e && (t = Gk(t, 0, 1)), this.t = t, this } }, { key: "addT", value: function(t, e) { return this.setT(this.t + t, e), this } }, { key: "scrollToTop", value: function() { return this.t = 0, this } }, { key: "scrollToBottom", value: function() { return this.t = 1, this } }, { key: "sliderEnable", get: function() { var t = this.childrenMap.slider; return !!t && t.enable }, set: function(t) { var e = this.childrenMap.slider;
                    e && e.setEnable(t) } }, { key: "setSliderEnable", value: function(t) { return void 0 === t && (t = !0), this.sliderEnable = t, this } }, { key: "scrollerEnable", get: function() { var t = this.childrenMap.scroller; return !!t && t.enable }, set: function(t) { var e = this.childrenMap.scroller;
                    e && e.setEnable(t) } }, { key: "setScrollerEnable", value: function(t) { return void 0 === t && (t = !0), this.scrollerEnable = t, this } }, { key: "mouseWheelScrollerEnable", get: function() { var t = this.childrenMap.mouseWheelScroller; return !!t && t.enable }, set: function(t) { var e = this.childrenMap.mouseWheelScrollerEnable;
                    e && e.setEnable(t) } }, { key: "setMouseWheelScrollerEnable", value: function(t) { return void 0 === t && (t = !0), this.mouseWheelScrollerEnable = t, this } }, { key: "setDropZoneEnable", value: function(t) { void 0 === t && (t = !0); var e = this.childrenMap.child; return e.setInteractive(), e.input.dropZone = t, this } }]), p }(),
        Uk = { resizeController: function() { var t = this.topChildOY,
                    e = this.bottomChildOY,
                    i = this.childrenMap.scroller,
                    n = this.childrenMap.slider; return i && i.setBounds(e, t), n && n.setEnable(e !== t), this.updateController(), this.adaptThumbSizeMode && Yk.call(this), this }, updateController: function() { var t = this.childrenMap.scroller,
                    e = this.childrenMap.slider;
                t && t.setValue(this.childOY), e && e.setValue(this.t) } };
    Object.assign(Vk.prototype, Uk); var Hk = function() {
        function i(t, e) { X(this, i), this.container = null, this._deltaHeight = 0, this.setParent(t) } return k(i, [{ key: "setParent", value: function(t) { this.parent = t, this.parentContainer = t.getParentContainer() } }, { key: "destroy", value: function(t) { void 0 === t && (t = !1), t || this.destroyContainer(), this.deltaHeight = 0, this.data = void 0, this.container = null, this.parent = void 0, this.parentContainer = void 0 } }, { key: "table", get: function() { return this.parent } }, { key: "scrollMode", get: function() { return this.parentContainer.scrollMode } }, { key: "colIndx", get: function() { return this.parent.cellIndxeToColIndex(this.index) } }, { key: "rowIndx", get: function() { return this.parent.cellIndxeToRowIndex(this.index) } }, { key: "getContainer", value: function() { return this.container } }, { key: "setContainer", value: function(t) { return t ? (this.container && this.container.destroy(), this.container = t, this.parentContainer.add(t)) : this.destroyContainer(), this } }, { key: "destroyContainer", value: function() { return this.container && (this.container.destroy(), this.container = null), this } }, { key: "popContainer", value: function() { if (this.container) { var t = this.container; return this.container = null, this.parentContainer.remove(t), t } return null } }, { key: "setXY", value: function(t, e) { return this.container && this.parentContainer.setChildLocalPosition(this.container, t, e), this } }, { key: "deltaHeight", get: function() { return this._deltaHeight }, set: function(t) { null == t && (t = 0); var e = this.parent;
                0 === this._deltaHeight && 0 !== t ? e.nonZeroDeltaHeightCount++ : 0 !== this._deltaHeight && 0 === t && e.nonZeroDeltaHeightCount--; var i = this._deltaHeight !== t; if (this._deltaHeight = t, i) { e.resetTotalRowsHeight(); var n = 0 === this.scrollMode ? "cellheightchange" : "cellwidthchange";
                    this.parentContainer.emit(n, this, this.container, this.parentContainer) } } }, { key: "deltaWidth", get: function() { return this.deltaHeight }, set: function(t) { this.deltaHeight = t } }, { key: "setDeltaHeight", value: function(t) { return this.deltaHeight = t, this } }, { key: "setDeltaWidth", value: function(t) { return this.deltaHeight = t, this } }, { key: "height", get: function() { return 0 === this.scrollMode ? this.deltaHeight + this.parent.defaultCellHeight : this.parent.defaultCellWidth }, set: function(t) { 1 !== this.scrollMode && this.setDeltaHeight(t - this.parent.defaultCellHeight) } }, { key: "setHeight", value: function(t) { return this.height = t, this } }, { key: "width", get: function() { return 0 === this.scrollMode ? this.parent.defaultCellWidth : this.deltaHeight + this.parent.defaultCellHeight }, set: function(t) { 0 !== this.scrollMode && this.setDeltaHeight(t - this.parent.defaultCellHeight) } }, { key: "setWidth", value: function(t) { return this.width = t, this } }, { key: "scene", get: function() { return this.parentContainer.scene } }]), i }();
    Object.assign(Hk.prototype, ht);

    function Nk(t) { return t.hasOwnProperty("geometryMask") ? t.geometryMask : t.bitmapMask }

    function Jk(t) { var e, i = null;
        (e = t.getContainer()) ? (i = e, t.popContainer()) : this.cellContainersPool && null !== (i = this.cellContainersPool.getFirstDead()) && i.setActive(!0).setVisible(!0), this.emit("cellvisible", t, i, this), this.cellContainersPool && ((e = t.getContainer()) ? null === i ? this.cellContainersPool.add(e) : i !== e && (this.cellContainersPool.add(e), this.cellContainersPool.killAndHide(i)) : null !== i && this.cellContainersPool.killAndHide(i)) }

    function Kk(t) { if (this.emit("cellinvisible", t), this.cellContainersPool) { var e = t.popContainer();
            e && this.cellContainersPool.killAndHide(e) }
        t.destroyContainer() }

    function Zk(t, e) { e -= this.y + this.topLeftY, t -= this.x + this.topLeftX; var i = this.tableOY - (0 === this.scrollMode ? e : t),
            n = this.tableOX - (0 === this.scrollMode ? t : e),
            s = this.table,
            r = s.heightToRowIndex(-i),
            o = s.widthToColIndex(-n),
            a = s.colRowToCellIndex(o, r); return null !== a && this.isCellVisible(a) ? a : null } var qk = Phaser.Utils.Objects.GetValue,
        $k = Phaser.Utils.Array.SpliceOne,
        Qk = function() {
            function i(t, e) { X(this, i), this.parent = t, this.cells = [], this.cellPool = new N(), this.resetFromJSON(e) } return k(i, [{ key: "resetFromJSON", value: function(t) { return this.colCount = void 0, this.nonZeroDeltaHeightCount = 0, this.resetTotalRowsHeight(), this.setDefaultCellHeight(qk(t, "cellHeight", 30)), this.setDefaultCellWidth(qk(t, "cellWidth", 30)), this.initCells(qk(t, "cellsCount", 0)), this.setColumnCount(qk(t, "columns", 1)), this } }, { key: "destroy", value: function() { this.cellPool.destroy(), this.cells = void 0, this.parent = void 0 } }, { key: "defaultCellHeightMode", get: function() { return 0 === this.nonZeroDeltaHeightCount } }, { key: "setDefaultCellHeight", value: function(t) { return this.defaultCellHeight = t, this } }, { key: "setDefaultCellWidth", value: function(t) { return this.defaultCellWidth = t, this } }, { key: "initCells", value: function(t) { var e = this.cells;
                    e.length = t; for (var i = 0; i < t; i++) e[i] = null; return this } }, { key: "insertNewCells", value: function(t, e) { var i = this.cells; if (t === i.length) { var n = t + e;
                        i.legth = n; for (var s = t; s < n; s++) i[s] = null } else { var r, o = [];
                        o.length = e; for (s = 0; s < e; s++) o[s] = null;
                        (r = this.cells).splice.apply(r, [t, 0].concat(o)) } return this.resetTotalRowsHeight(), this } }, { key: "removeCells", value: function(t, e) { for (var i = t + e, n = t; n < i; n++) this.freeCell(n); return i === this.cells.length ? this.cells.length = t : (1 === e ? $k(this.cells, t) : this.cells.splice(t, e), this.buildCellIndex(t)), this.resetTotalRowsHeight(), this } }, { key: "setColumnCount", value: function(t) { return this.colCount = t, this.resetTotalRowsHeight(), this } }, { key: "rowCount", get: function() { return Math.ceil(this.cells.length / this.colCount) } }, { key: "cellsCount", get: function() { return this.cells.length } }, { key: "isValidCellIdx", value: function(t) { return 0 <= t && t < this.cells.length } }, { key: "heightToRowIndex", value: function(t, e) { if (this.defaultCellHeightMode) { var i = t / this.defaultCellHeight; return i = e ? Math.ceil(i) : Math.floor(i) } var n, s = this.rowCount,
                        r = t; for (i = 0;;) { if (n = 0 <= i && i < s, !(0 < (r -= this.getRowHeight(i)) && n)) { if (0 === r) return i; if (e) { var o = i;
                                (n = 0 <= (i += 1) && i < s) || (i = o) } return i }
                        i += 1 } } }, { key: "widthToColIndex", value: function(t, e) { var i = t / this.defaultCellWidth; return i = e ? Math.ceil(i) : Math.floor(i) } }, { key: "colRowToCellIndex", value: function(t, e) { return t >= this.colCount ? null : e * this.colCount + t } }, { key: "rowIndexToHeight", value: function(t, e) { if (this.defaultCellHeightMode) return (e - t + 1) * this.defaultCellHeight; for (var i = 0, n = t; n <= e; n++) i += this.getRowHeight(n); return i } }, { key: "colIndexToWidth", value: function(t, e) { return (e - t + 1) * this.defaultCellWidth } }, { key: "getRowHeight", value: function(t) { var e = this.colCount; if (e <= 1) return this.getCellHeight(this.colRowToCellIndex(0, t)); for (var i, n = 0, s = 0; s < e; s++) n < (i = this.getCellHeight(this.colRowToCellIndex(s, t))) && (n = i); return n } }, { key: "getColWidth", value: function() { return this.defaultCellWidth } }, { key: "getCellHeight", value: function(t) { if (!this.isValidCellIdx(t)) return 0; var e; if (this.defaultCellHeightMode) e = this.defaultCellHeight;
                    else { var i = this.getCell(t, !1),
                            n = i ? i.deltaHeight : 0;
                        e = this.defaultCellHeight + n } return e } }, { key: "resetTotalRowsHeight", value: function() { this._totalRowsHeight = null } }, { key: "totalRowsHeight", get: function() { return null === this._totalRowsHeight && (this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1)), this._totalRowsHeight } }, { key: "totalColumnWidth", get: function() { return this.colCount * this.defaultCellWidth } }, { key: "cellIndxeToColIndex", value: function(t) { return t % this.colCount } }, { key: "cellIndxeToRowIndex", value: function(t) { return Math.floor(t / this.colCount) } }, { key: "getCell", value: function(t, e) { if (!this.isValidCellIdx(t)) return null; if (void 0 === e && (e = !0), null === this.cells[t] && e) { var i = this.newCell(t);
                        this.cells[t] = i } return this.cells[t] } }, { key: "newCell", value: function(t) { var e = this.cellPool.pop(); return null === e ? e = new Hk(this) : e.setParent(this), e.index = t, e } }, { key: "buildCellIndex", value: function(t) { void 0 === t && (t = 0); for (var e, i = this.cells, n = t, s = i.length; n < s; n++)(e = i[n]) && (e.index = n); return this } }, { key: "getParentContainer", value: function() { return this.parent } }, { key: "freeCell", value: function(t) { return "number" == typeof t && (t = this.cells[t]), t && (t.destroy(), this.cellPool.push(t)), this } }]), i }(),
        tb = Phaser.Geom.Intersects.RectangleToRectangle,
        eb = Phaser.Geom.Rectangle.Overlaps,
        ib = function(t) { if (!t.displayList) return !1; for (;;) { var e = t.rexContainer; if (e) { if (e.visible) { var i = e.parent; if (i) { t = i; continue } return !0 } return !1 } return t.visible } },
        nb = function(t, e) { var i = 0,
                n = e.top,
                s = e.bottom,
                r = e.left,
                o = e.right; return i += t.contains(r, n) ? 1 : 0, i += t.contains(r, s) ? 1 : 0, i += t.contains(o, n) ? 1 : 0, i += t.contains(o, s) ? 1 : 0 },
        sb = function(t, e) { t.setChildMaskVisible(e, !0), e.clearMask && e.clearMask() },
        rb = function(t, e, i) { t.setChildMaskVisible(e, !0), e.setMask && e.setMask(i) },
        ob = function(t, e) { t.setChildMaskVisible(e, !1), e.clearMask && e.clearMask() },
        ab = Phaser.Utils.Objects.GetValue,
        hb = { update: 0, everyTick: 1 },
        lb = { setupChildrenMask: function(t) { return !1 === t || (this.setMaskUpdateMode(ab(t, "updateMode", 0)), this.enableChildrenMask(ab(t, "padding", 0)), this.setMaskLayer(ab(t, "layer", void 0)), this.startMaskUpdate()), this }, destroyChildrenMask: function() { return this.childrenMask && (this.stopMaskUpdate(), this.childrenMask.destroy(), this.childrenMask = void 0), this }, setMaskUpdateMode: function(t) { return "string" == typeof t && (t = hb[t]), this.maskUpdateMode = t, this }, startMaskUpdate: function() { this.scene.game.events.on("poststep", this.maskChildren, this) }, stopMaskUpdate: function() { this.scene.game.events.off("poststep", this.maskChildren, this) }, enableChildrenMask: function(t) { var e = Fy.call(this, null, this, 0, t); return this.childrenMask = e.createGeometryMask(), this }, setMaskChildrenFlag: function(t) { return void 0 === t && (t = !0), this.maskChildrenFlag = t, this }, setMaskLayer: function(t) { return this.maskLayer = t, this }, maskChildren: function() { return this.childrenMask && this.maskChildrenFlag && 0 !== this.alpha && this.visible && (this.layer ? this.layer.setMask(this.childrenMask) : this.maskLayer ? (this.addToLayer(this.maskLayer), this.maskLayer.setMask(this.childrenMask)) : function(t, e, i) { if (e) { void 0 === i && (i = t.getAllChildren()); for (var n, s, r = t.getBounds(), o = Nk(e), a = 0, h = i.length; a < h; a++)
                            if (!(n = i[a]).hasOwnProperty("isRexContainerLite") && n !== o && ib(n))
                                if (n.getBounds) switch (s = n.getBounds(s), nb(r, s)) {
                                    case 4:
                                        sb(t, n); break;
                                    case 0:
                                        tb(r, s) || eb(r, s) ? rb(t, n, e) : ob(t, n); break;
                                    default:
                                        rb(t, n, e) } else rb(t, n, e) } }(this, this.childrenMask), 0 === this.maskUpdateMode && (this.maskChildrenFlag = !1)), this }, layoutChildrenMask: function() { if (!this.childrenMask) return this; var t = Nk(this.childrenMask); return t.setPosition().resize(), this.resetChildPositionState(t), this } },
        ub = function() { var t = this.preVisibleCells;
            this.preVisibleCells = this.visibleCells, this.visibleCells = t, this.visibleCells.clear() },
        cb = Phaser.Math.Clamp,
        db = { setTableOY: function(t) { var e = this.table,
                    i = this.topTableOY,
                    n = this.bottomTableOY,
                    s = t > this.topTableOY,
                    r = t < this.bottomTableOY;
                this.clampTableOXY && (e.rowCount < e.heightToRowIndex(this.instHeight, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOY !== t && (this._tableOY = t), s && (this.execeedTopState || this.emit("execeedtop", this, t, i)), this.execeedTopState = s, r && (this.execeedBottomState || this.emit("execeedbottom", this, t, n)), this.execeedBottomState = r, this }, setTableOX: function(t) { var e = this.table,
                    i = this.leftTableOX,
                    n = this.rightTableOX,
                    s = t > this.leftTableOX,
                    r = t < this.rightTableOX;
                this.clampTableOXY && (e.colCount < e.widthToColIndex(this.instWidth, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOX !== t && (this._tableOX = t), s && (this.execeedLeftState || this.emit("execeedleft", this, t, i)), this.execeedLeftState = s, r && (this.execeedRightState || this.emit("execeedright", this, t, n)), this.execeedRightState = r, this }, showCells: function() { if (0 !== this.cellsCount) { var t = this.table,
                        e = t.heightToRowIndex(-this.tableOY);
                    e <= 0 && (e = 0); var i = e,
                        n = t.widthToColIndex(-this.tableOX);
                    n <= 0 && (n = 0); for (var s = n, r = t.colRowToCellIndex(s, i), o = this.bottomBound, a = this.rightBound, h = t.cellsCount - 1, l = t.colCount - 1, u = this.getCellTLX(s), c = u, d = this.getCellTLY(i); d < o && r <= h;) { if (this.table.isValidCellIdx(r)) { var f = t.getCell(r, !0);
                            this.visibleCells.set(f), this.preVisibleCells.contains(f) || this.showCell(f), 0 === this.scrollMode ? f.setXY(c, d) : f.setXY(d, c) }
                        c < a && s < l ? (c += t.getColWidth(s), s += 1) : (c = u, d += t.getRowHeight(i), s = n, i += 1), r = t.colRowToCellIndex(s, i) } } }, showCell: Jk, getCellTLX: function(t) { var e = 0 === this.scrollMode ? this.topLeftX : this.topLeftY; return this.tableOX + this.table.colIndexToWidth(0, t - 1) + e }, getCellTLY: function(t) { var e = 0 === this.scrollMode ? this.topLeftY : this.topLeftX; return this.tableOY + this.table.rowIndexToHeight(0, t - 1) + e }, hideCells: function() { var t = this.preVisibleCells,
                    e = this.visibleCells;
                t.iterate(function(t) { e.contains(t) || this.hideCell(t) }, this) }, hideCell: Kk, updateTable: function(t) { return void 0 === t && (t = !1), t && (ub.call(this), this.hideCells()), ub.call(this), this.showCells(), this.hideCells(), this.setMaskChildrenFlag(), this }, isCellVisible: function(t) { var e = this.table.getCell(t, !1); return e && this.visibleCells.contains(e) }, pointToCellIndex: Zk, pointToCellContainer: function(t, e) { var i = Zk.call(this, t, e); if (null !== i) return this.getCellContainer(i) }, eachVisibleCell: function(t, e) { return this.visibleCells.each(t, e), this }, iterateVisibleCell: function(t, e) { return this.visibleCells.iterate(t, e), this }, eachCell: function(t, e) { return this.table.cells.slice().forEach(t, e), this }, iterateCell: function(t, e) { return this.table.cells.forEach(t, e), this }, setCellsCount: function(t) { var e = this.cellsCount; return e === t || (t < e ? this.removeCells(t, e - t) : this.insertNewCells(e, t - e)), this }, insertNewCells: function(t, e) { return "object" === P(t) && (t = t.index), void 0 === e && (e = 1), e <= 0 || (t = cb(t, 0, this.cellsCount), this.table.insertNewCells(t, e)), this }, removeCells: function(t, e) { if ("object" === P(t) && (t = t.index), void 0 === e && (e = 1), t < 0 && (e += t, t = 0), e <= 0) return this; if (t > this.cellsCount) return this; for (var i, n = t, s = t + e; n < s; n++)(i = this.getCell(n, !1)) && (this.visibleCells.contains(i) && (Kk.call(this, i), this.visibleCells.delete(i)), this.preVisibleCells.delete(i)); return this.table.removeCells(t, e), this }, setColumnCount: function(t) { return this.table.colCount === t || this.table.setColumnCount(t), this }, setGridSize: function(t, e) { return this.setCellsCount(t * e), this.table.setColumnCount(t), this }, updateVisibleCell: function(t) { var e = this.table.getCell(t, !1); return e && e.container && Jk.call(this, e), this } };
    Object.assign(db, lb); var fb = Phaser.GameObjects.Group,
        pb = Phaser.Structs.Set,
        vb = Phaser.Utils.Objects.GetValue,
        gb = function() { w(p, Kr); var f = T(p);

            function p(t, e, i, n, s, r) { var o;
                X(this, p), void 0 === r && (r = {}), (o = f.call(this, t, e, i, n, s)).type = "rexGridTable", o._tableOX = 0, o._tableOY = 0, o.visibleCells = new pb(), o.preVisibleCells = new pb(), o.execeedTopState = !1, o.execeedBottomState = !1, o.execeedLeftState = !1, o.execeedRightState = !1, vb(r, "reuseCellContainer", !1) && (o.cellContainersPool = new fb(t)); var a, h, l, u = vb(r, "cellVisibleCallback", null); if (null !== u) { var c = vb(r, "cellVisibleCallbackScope", void 0);
                    o.on("cellvisible", u, c) } if (null !== (u = vb(r, "cellInvisibleCallback", null))) { c = vb(r, "cellInvisibleCallbackScope", void 0);
                    o.on("cellinvisible", u, c) }
                vb(r, "enableLayer", !1) && o.enableLayer(), o.setupChildrenMask(vb(r, "mask", void 0)), o.setScrollMode(vb(r, "scrollMode", 0)), o.setClampMode(vb(r, "clamplTableOXY", !0)); var d = 0 === o.scrollMode;
                l = d ? (a = r.cellWidth, h = r.cellHeight, r.columns) : (a = r.cellHeight, h = r.cellWidth, vb(r, "rows", r.columns)), o.expandCellSize = void 0 === a, o.expandCellSize && (a = (n = d ? o.width : o.height) / l); return r.cellWidth = a, r.cellHeight = h, r.columns = l, o.table = new Qk(W(o), r), o.updateTable(), o } return k(p, [{ key: "destroy", value: function(t) { this.scene && (this.destroyChildrenMask(), this.table.destroy(t), this.table = void 0, this.cellContainersPool && (this.cellContainersPool.destroy(!0), this.cellContainersPool = void 0), O(C(p.prototype), "destroy", this).call(this, t)) } }, { key: "setScrollMode", value: function(t) { return "string" == typeof t && (t = kb[t.toLowerCase()]), this.scrollMode = t, this } }, { key: "setClampMode", value: function(t) { return void 0 === t && (t = !0), this.clampTableOXY = t, this } }, { key: "tableOY", get: function() { return this._tableOY }, set: function(t) { this.setTableOY(t).updateTable() } }, { key: "tableOX", get: function() { return this._tableOX }, set: function(t) { this.setTableOX(t).updateTable() } }, { key: "setTableOXY", value: function(t, e) { return this.setTableOY(e).setTableOX(t), this } }, { key: "addTableOY", value: function(t) { return this.setTableOY(this.tableOY + t), this } }, { key: "addTableOX", value: function(t) { return this.setTableOX(this.tableOX + t), this } }, { key: "addTableOXY", value: function(t, e) { return this.addTableOY(e).addTableOX(t), this } }, { key: "setTableOYByPercentage", value: function(t) { return this.setTableOY(-this.tableVisibleHeight * t), this } }, { key: "getTableOYPercentage", value: function() { var t = this.tableVisibleHeight; return 0 === t ? 0 : this.tableOY / -t } }, { key: "t", get: function() { return this.getTableOYPercentage() }, set: function(t) { this.setTableOYByPercentage(t).updateTable() } }, { key: "getCell", value: function(t) { return this.table.getCell(t, !0) } }, { key: "getCellContainer", value: function(t) { var e, i = this.table.getCell(t, !1); return i && (e = i.getContainer()), e } }, { key: "cellsCount", get: function() { return this.table.cellsCount } }, { key: "columnCount", get: function() { return this.table.colCount } }, { key: "setCellHeight", value: function(t, e) { return ("number" == typeof t ? this.table.getCell(t, !0) : t).height = e, this } }, { key: "setCellWidth", value: function(t, e) { return ("number" == typeof t ? this.table.getCell(t, !0) : t).width = e, this } }, { key: "instHeight", get: function() { return 0 === this.scrollMode ? this.height : this.width } }, { key: "instWidth", get: function() { return 0 === this.scrollMode ? this.width : this.height } }, { key: "tableHeight", get: function() { return this.table.totalRowsHeight } }, { key: "tableWidth", get: function() { return this.table.totalColumnWidth } }, { key: "topTableOY", get: function() { return 0 } }, { key: "bottomTableOY", get: function() { return -this.tableVisibleHeight } }, { key: "leftTableOX", get: function() { return 0 } }, { key: "rightTableOX", get: function() { return -this.tableVisibleWidth } }, { key: "tableVisibleHeight", get: function() { var t = this.tableHeight - this.instHeight; return t < 0 && (t = 0), t } }, { key: "tableVisibleWidth", get: function() { var t = this.tableWidth,
                        e = this.instWidth; return e < t ? t - e : 0 } }, { key: "bottomLeftY", get: function() { return -(this.displayHeight * this.originY) + this.displayHeight } }, { key: "topRightX", get: function() { return -(this.displayWidth * this.originX) + this.displayWidth } }, { key: "topLeftX", get: function() { return -(this.displayWidth * this.originX) } }, { key: "topLeftY", get: function() { return -(this.displayHeight * this.originY) } }, { key: "bottomBound", get: function() { return 0 === this.scrollMode ? this.bottomLeftY : this.topRightX } }, { key: "rightBound", get: function() { return 0 === this.scrollMode ? this.topRightX : this.bottomLeftY } }, { key: "resize", value: function(t, e) { return this.width === t && this.height === e || (O(C(p.prototype), "resize", this).call(this, t, e), this.expandCellSize && this.table.setDefaultCellWidth(this.instWidth / this.table.colCount), this.updateTable(!0), this.layoutChildrenMask(), this.maskChildren()), this } }]), p }();
    Object.assign(gb.prototype, db);

    function yb(t, e, i, n, s, r, o) { var a; if (null != (a = void 0 === s ? n : i.pointToCellIndex(n, s))) { var h = i.getCellContainer(a);
            h && t.emit(e, h, a, r, o) } }

    function mb(t, e) { t.setInteractive(),
            function(s) { s.on("pointerdown", function(t, e, i, n) { yb(this.eventEmitter, "cell.down", s, t.x, t.y, t, n) }, this).on("pointerup", function(t, e, i, n) { yb(this.eventEmitter, "cell.up", s, t.x, t.y, t, n) }, this) }.call(this, t, e),
            function(t) { t.on("pointermove", bb, this).on("pointerover", bb, this).on("pointerout", xb, this) }.call(this, t, e),
            function(t, e) { var i = Cb(e, "click", void 0);!1 !== i && (void 0 === i && (i = {}), i.threshold = 10, t._click = new If(t, i), t._click.on("click", function(t, e, i, n) { yb(this.eventEmitter, "cell.click", e, i.x, i.y, i, n) }, this)) }.call(this, t, e),
            function(t, e) { var i = wb(e, "tap", void 0);!1 !== i && (t._tap = new hp(t, i), t._tap.on("tap", function(t, e, i) { var n = "cell.".concat(t.tapsCount, "tap");
                    yb(this.eventEmitter, n, t.gameObject, t.x, t.y, i) }, this)) }.call(this, t, e),
            function(n, t) { var e = Sb(t, "press", void 0);!1 !== e && (n._press = new fp(n, e), n._press.on("pressstart", function(t, e, i) { yb(this.eventEmitter, "cell.pressstart", n, t.x, t.y, i) }, this).on("pressend", function(t, e, i) { yb(this.eventEmitter, "cell.pressend", n, t.x, t.y, i) }, this)) }.call(this, t, e),
            function(s, t) { var e = Pb(t, "swipe", void 0);!1 !== e && (void 0 === e && (e = {}), e.dir = "4dir", s._swipe = new Ep(s, e), s._swipe.on("swipe", function(t, e, i) { var n = t.left ? "left" : t.right ? "right" : t.up ? "up" : "down";
                    yb(this.eventEmitter, "cell.swipe".concat(n), s, t.x, t.y, i) }, this)) }.call(this, t, e) } var kb = { v: 0, vertical: 0, h: 1, horizontal: 1 },
        bb = function(t, e, i, n) { var s = this.childrenMap.child,
                r = s.pointToCellIndex(t.x, t.y); if (r !== s.input.lastOverCellIndex) { var o = s.input.lastOverCellIndex;
                s.input.lastOverCellIndex = r, yb(this.eventEmitter, "cell.out", s, o, void 0, t, n), yb(this.eventEmitter, "cell.over", s, r, void 0, t, n) } },
        xb = function(t, e) { var i = this.childrenMap.child,
                n = i.input.lastOverCellIndex;
            i.input.lastOverCellIndex = void 0, yb(this.eventEmitter, "cell.out", i, n, void 0, t, e) },
        Cb = Phaser.Utils.Objects.GetValue,
        wb = Phaser.Utils.Objects.GetValue,
        Sb = Phaser.Utils.Objects.GetValue,
        Pb = Phaser.Utils.Objects.GetValue,
        Tb = Phaser.Utils.Objects.GetValue,
        Ob = function() { w(g, Vk); var v = T(g);

            function g(t, e) { var i;
                X(this, g), void 0 === e && (e = {}); var n = kk(e),
                    s = Tb(e, "table", void 0);
                void 0 === s && (s = {}), s.scrollMode = n, s.clamplTableOXY = Tb(e, "clamplChildOY", !1); var r, o, a, h = Tb(s, "width", void 0),
                    l = Tb(s, "height", void 0),
                    u = new gb(t, 0, 0, h, l, s);
                t.add.existing(u), o = 0 === n ? (r = void 0 === h ? 1 : 0, void 0 === l) : (r = void 0 === l ? 1 : 0, void 0 === h), a = u, Object.defineProperty(a, "childOY", { configurable: !0, get: function() { return a.tableOY }, set: function(t) { a.tableOY = t } }), Object.defineProperty(a, "topChildOY", { get: function() { return a.topTableOY } }), Object.defineProperty(a, "bottomChildOY", { get: function() { return a.bottomTableOY } }), Object.defineProperty(a, "childVisibleHeight", { get: function() { return a.instHeight } }), Object.defineProperty(a, "childHeight", { get: function() { return a.tableHeight } }), u.minWidth = void 0 === h ? 0 : void 0, u.minHeight = void 0 === l ? 0 : void 0, e.type = "rexGridTable", e.child = { gameObject: u, proportion: r, expand: o }; var c = Tb(e, "space", void 0);
                c && (c.child = c.table), (i = v.call(this, t, e)).addChildrenMap("table", u), i.addChildrenMap("tableLayer", u.maskLayer), i.eventEmitter = Tb(e, "eventEmitter", W(i)); var d = Tb(e, "createCellContainerCallback", _),
                    f = Tb(e, "createCellContainerCallbackScope", void 0);
                i.setCreateCellContainerCallback(d, f),
                    function(t) { t.on("cellvisible", function(t, e, i) { var n = this.createCellContainerCallback,
                                s = this.createCellContainerCallbackScope;
                            t.item = this.items[t.index], (e = s ? n.call(s, t, e, i) : n(t, e, i)) && (e.setOrigin && e.setOrigin(0), e.isRexSizer && e.layout()), t.item = void 0, t.setContainer(e) }, this) }.call(W(i), u), i.resizeControllerFlag = !1; var p = 0 === n ? "cellheightchange" : "cellwidthchange"; return u.on(p, function() { this.resizeControllerFlag = !0 }, W(i)), Tb(s, "interactive", !0) && mb.call(W(i), u, s), i.setItems(Tb(e, "items", [])), t.game.events.on("poststep", i.onPostStep, W(i)), i } return k(g, [{ key: "destroy", value: function(t) { this.scene && (this.scene.game.events.off("poststep", this.onPostStep, this), O(C(g.prototype), "destroy", this).call(this, t)) } }, { key: "setCreateCellContainerCallback", value: function(t, e) { return this.createCellContainerCallback = t, this.createCellContainerCallbackScope = e, this } }, { key: "refresh", value: function() { return this.setItems(this.items), this } }, { key: "getCell", value: function(t) { return this.childrenMap.child.getCell(t) } }, { key: "getCellContainer", value: function(t) { return this.childrenMap.child.getCellContainer(t) } }, { key: "updateVisibleCell", value: function(t) { return this.childrenMap.child.updateVisibleCell(t) } }, { key: "onPostStep", value: function() { this.resizeControllerFlag && (this.resizeController(), this.resizeControllerFlag = !1) } }]), g }(),
        Mb = { setItems: function(t) { void 0 === t ? this.items.length = 0 : this.items = t; var e = this.childrenMap.child; return e.setCellsCount(this.items.length), e.updateTable(!0), this.resizeController(), this } };
    Object.assign(Ob.prototype, Mb), p.register("gridTable", function(t) { var e = new Ob(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.GridTable", Ob);

    function Eb(t, e) { return t.sameOrientation ? t.orientation = e.orientation : t.orientation = 0 === e.orientation ? 1 : 0, t }

    function _b(t) { t.popUp(Eb(t.root.easeIn, t)) }

    function Rb(t) { t.scaleDown(Eb(t.root.easeOut, t)) }

    function Bb(t, e, i, n, s) { var r = t.scene,
            o = r.sys.events; return r.time.delayedCall(e, o.once, ["postupdate", function() { i.call(n, s) }], o) } var Ib = { setTransitInCallback: function(t) { return void 0 === t && (t = _b), this.transitInCallback = t, this }, setTransitOutCallback: function(t) { return void 0 === t && (t = Rb), this.transitOutCallback = t, this } },
        Lb = { delayCall: function(t, e, i) { return this.timer = Bb(this, t, e, i), this }, removeDelayCall: function() { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } },
        Ab = { expandSubMenu: function(t, e) { var i; if ((n = this.childrenMap.subMenu) && n.parentButton === t) return this;
                this.collapseSubMenu(), i = this.root.toggleOrientation ? 0 === this.orientation ? 1 : 0 : this.orientation; var n = new this.constructor(this.scene, { items: e, orientation: i, space: this.space, createBackgroundCallback: this.root.createBackgroundCallback, createBackgroundCallbackScope: this.root.createBackgroundCallbackScope, createButtonCallback: this.root.createButtonCallback, createButtonCallbackScope: this.root.createButtonCallbackScope, easeIn: this.root.easeIn, easeOut: this.root.easeOut, _rootMenu: this.root, _parentMenu: this, _parentButton: t }); return this.pin(n), this.childrenMap.subMenu = n, this.root.emit("expand", n, t, this), this }, collapse: function() { var t = this.root;
                t.emit("collapse", this, this.parentButton, t); var e = t.easeOut.duration; return t.transitOutCallback(this, e), this.collapseSubMenu(), this.delayCall(e, this.destroy, this), this }, collapseSubMenu: function() { var t = this.childrenMap.subMenu; return void 0 === t || (this.childrenMap.subMenu = void 0, this.remove(t), t.collapse()), this } };
    Object.assign(Ab, Ib, Lb);

    function jb(t, e) { return "number" == typeof e && (e = { duration: e }), e.hasOwnProperty("orientation") && void 0 !== e.orientation ? e.sameOrientation = iy(e.orientation) === t.orientation : e.sameOrientation = !0, e.destroy = !1, e } var Db = Phaser.Utils.Objects.GetValue,
        zb = function() { w(P, ym); var S = T(P);

            function P(t, e) { var i;
                X(this, P), void 0 === e && (e = {}), e.hasOwnProperty("orientation") || (e.orientation = 1); var n, s, r, o, a, h = e._rootMenu,
                    l = e._parentMenu,
                    u = e._parentButton,
                    c = Db(e, "popup", !0),
                    d = Db(e, "items", void 0),
                    f = Db(e, "createBackgroundCallback", void 0),
                    p = Db(e, "createBackgroundCallbackScope", void 0);
                e.background = (n = t, s = d, o = p, (r = f) && (s.scene = n, a = o ? r.call(o, s) : r(s), s.scene = void 0), a); var v = Db(e, "createButtonCallback", void 0),
                    g = Db(e, "createButtonCallbackScope", void 0); if (e.buttons = function(t, e, i, n) { var s, r, o = []; if (e && i)
                            for (var a = 0, h = e.length; a < h; a++)(s = e[a]).scene = t, r = n ? i.call(n, s, a, e) : i(s, a, e), s.scene = void 0, o.push(r); return o }(t, d, v, g), (i = S.call(this, t, e)).type = "rexMenu", i.items = d, i.root = void 0 === h ? W(i) : h, i.isRoot = i.root === W(i), i.parentMenu = l, i.parentButton = u, i.timer = void 0, i.isRoot) { i.isPopUpMode = c; var y = e.bounds;
                    void 0 === y && (y = xh(t)), i.bounds = y, i.subMenuSide = [i.y < y.centerY ? Wb : Xb, i.x < y.centerX ? Yb : Fb], void 0 !== (w = Db(e, "subMenuSide", void 0)) && ("string" == typeof w && (w = Gb[w]), i.subMenuSide[i.orientation] = w), i.toggleOrientation = Db(e, "toggleOrientation", !1), i.expandEventName = Db(e, "expandEvent", "button.click"), i.easeIn = jb(W(i), Db(e, "easeIn", 0)), i.easeOut = jb(W(i), Db(e, "easeOut", 0)), i.setTransitInCallback(Db(e, "transitIn")), i.setTransitOutCallback(Db(e, "transitOut")), i.createBackgroundCallback = f, i.createBackgroundCallbackScope = p, i.createButtonCallback = v, i.createButtonCallbackScope = g, i.childrenKey = Db(e, "childrenKey", "children"), i._isPassedEvent = !1, i.pointerDownOutsideCollapsing = Db(e, "pointerDownOutsideCollapsing", !0), i.pointerDownOutsideCollapsing && t.input.on("pointerdown", i.onPointerDownOutside, W(i)) } var m, k = 0,
                    b = 0; if (!i.root.easeIn.sameOrientation) { var x = Eb(i.root.easeIn, W(i)).orientation,
                        C = l ? l.orientation : i.orientation,
                        w = i.root.subMenuSide[C];
                    0 === x && w === Fb && (k = 1), 1 === x && w === Xb && (b = 1) } if (c && i.setOrigin(k, b).layout(), !i.isRoot) switch (i.setScale(i.root.scaleX, i.root.scaleY), w = i.root.subMenuSide[l.orientation]) {
                    case Fb:
                        i.alignTop(u.top).alignRight(u.left); break;
                    case Yb:
                        i.alignTop(u.top).alignLeft(u.right); break;
                    case Xb:
                        i.alignLeft(u.left).alignBottom(u.top); break;
                    case Wb:
                        i.alignLeft(u.left).alignTop(u.bottom) }
                return (m = W(i)).on(m.root.expandEventName, function(t, e) { if (!this._isPassedEvent) { var i = this.root.childrenKey,
                            n = this.items[e][i];
                        n && this.expandSubMenu(t, n) } }, m).on("button.click", function(t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.click", t, e, i, n), this.root._isPassedEvent = !1) }, m).on("button.over", function(t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.over", t, e, i, n), this.root._isPassedEvent = !1) }, m).on("button.out", function(t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit("button.out", t, e, i, n), this.root._isPassedEvent = !1) }, m), c && (i.pushIntoBounds(i.root.bounds), function() { var t = this.root,
                        e = t.easeIn.duration;
                    t.transitInCallback(this, e), this !== this.root && this.delayCall(e, function() { this.root.emit("popup.complete", this) }, this) }.call(W(i))), i } return k(P, [{ key: "destroy", value: function(t) { this.scene && (this.isRoot && this.pointerDownOutsideCollapsing && this.scene.input.off("pointerdown", this.onPointerDownOutside, this), O(C(P.prototype), "destroy", this).call(this, t), this.removeDelayCall()) } }, { key: "isInTouching", value: function(t) { return !!O(C(P.prototype), "isInTouching", this).call(this, t) || !!this.childrenMap.subMenu && this.childrenMap.subMenu.isInTouching(t) } }, { key: "onPointerDownOutside", value: function(t) { this.isInTouching(t) || (this.isPopUpMode ? this.collapse() : this.collapseSubMenu()) } }]), P }(),
        Fb = 2,
        Yb = 0,
        Xb = 3,
        Wb = 1,
        Gb = { up: Xb, down: Wb, left: Fb, right: Yb };
    Object.assign(zb.prototype, Ab), p.register("menu", function(t) { var e = new zb(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Menu", zb);

    function Vb(t) { t.popUp(this.listEaseInDuration, "y", "Cubic") }

    function Ub(t) { t.scaleDown(this.listEaseOutDuration, "y", "Linear") } var Hb = { setWrapEnable: function(t) { return void 0 === t && (t = !0), this.listWrapEnable = t, this }, setCreateButtonCallback: function(t) { return this.listCreateButtonCallback = t, this }, setCreateBackgroundCallback: function(t) { return this.listCreateBackgroundCallback = t, this }, setButtonClickCallback: function(t) { return this.listOnButtonClick = t, this }, setButtonOverCallback: function(t) { return this.listOnButtonOver = t, this }, setButtonOutCallback: function(t) { return this.listOnButtonOut = t, this }, setListExpandDirection: function(t) { return "string" == typeof t && (t = Nb[t]), this.listExpandDirection = t, this }, setListEaseInDuration: function(t) { return void 0 === t && (t = 0), this.listEaseInDuration = t, this }, setListEaseOutDuration: function(t) { return void 0 === t && (t = 0), this.listEaseOutDuration = t, this }, setListTransitInCallback: function(t) { return void 0 === t && (t = Vb), this.listTransitInCallback = t, this }, settListTTransitOutCallback: function(t) { return void 0 === t && (t = Ub), this.listTransitOutCallback = t, this }, setListBounds: function(t) { return this.listBounds = t, this }, setListWidth: function(t) { return this.listWidth = t, this }, setListHeight: function(t) { return this.listHeight = t, this }, setListSize: function(t, e) { return this.setListWidth(t).setListHeight(e), this }, setListAlignmentMode: function(t) { return this.listAlignMode = t, this }, setListSpace: function(t) { return void 0 === t && (t = {}), this.listSpace = t, this }, setListDraggable: function(t) { return void 0 === t && (t = !0), this.listDraggable = t, this } },
        Nb = { down: 0, up: 1 },
        Jb = { delayCall: function(t, e, i) { return this.timer = Bb(this, t, e, i), this }, removeDelayCall: function() { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } },
        Kb = { openListPanel: function() { if (this.listPanel) return this; var t = this.scene,
                    e = 0 === this.listExpandDirection,
                    i = 1 === this.listExpandDirection,
                    n = !e && !i,
                    r = function(t) { var e, i = this.listCreateBackgroundCallback;
                        i && (e = i.call(this, t), t.add.existing(e)); var n = [],
                            s = this.listCreateButtonCallback; if (s)
                            for (var r = this.options, o = 0, a = r.length; o < a; o++) { var h = s.call(this, t, r[o], o, r);
                                t.add.existing(h), n.push(h) }
                        var l = this.listWidth;
                        void 0 === l && (l = "text" === this.listAlignMode ? this.getElement("text").width : this.width); var u, c = this.listHeight; return u = this.listWrapEnable ? new Lm(t, { width: l, height: c, background: e, buttons: n, space: this.listSpace, draggable: this.listDraggable }) : new ym(t, { width: l, height: c, orientation: "y", background: e, buttons: n, space: this.listSpace, draggable: this.listDraggable }), t.add.existing(u), u }.call(this, t),
                    s = e || n ? 0 : 1;
                r.setOrigin(0, s).layout(); var o = this.getElement(this.listAlignMode).getTopLeft().x,
                    a = e || n ? this.bottom : this.top;
                r.setPosition(o, a); var h = this.listBounds;
                h = h || xh(t), n && r.bottom > h.bottom && r.changeOrigin(0, 1).setPosition(o, this.top), r.on("button.over", function(t, e, i, n) { this.listOnButtonOver && this.listOnButtonOver.call(this, t, e, i, n), this.emit("button.over", this, r, t, e, i, n) }, this).on("button.out", function(t, e, i, n) { this.listOnButtonOut && this.listOnButtonOut.call(this, t, e, i, n), this.emit("button.out", this, r, t, e, i, n) }, this); var l = this.listEaseInDuration; return this.listTransitInCallback(r, l), this.delayCall(l, function() { var s = this.listOnButtonClick;
                    s && r.on("button.click", function(t, e, i, n) { s.call(this, t, e, i, n), this.emit("button.click", this, r, t, e, i, n) }, this), t.input.once("pointerup", this.closeListPanel, this), this.emit("list.open", this, r) }, this), this.pin(r), this.listPanel = r, this }, closeListPanel: function() { if (!this.listPanel) return this; var t = this.listPanel;
                this.listPanel = void 0; var e = this.listEaseOutDuration; return this.listTransitOutCallback(t, e), this.delayCall(e, function() { this.emit("list.close", this, t), t.destroy() }, this), this }, toggleListPanel: function() { return this.listPanel ? this.closeListPanel() : this.openListPanel(), this } };
    Object.assign(Kb, Hb, Jb); var Zb = Phaser.Utils.Objects.GetValue,
        qb = function() { w(r, Xy); var s = T(r);

            function r(t, e) { var i;
                X(this, r), (i = s.call(this, t, e)).type = "rexDropDownList", i.timer = void 0, i.setOptions(Zb(e, "options")); var n = Zb(e, "list"); return i.setWrapEnable(Zb(n, "wrap", !1)), i.setCreateButtonCallback(Zb(n, "createButtonCallback")), i.setCreateBackgroundCallback(Zb(n, "createBackgroundCallback")), i.setButtonClickCallback(Zb(n, "onButtonClick")), i.setButtonOverCallback(Zb(n, "onButtonOver")), i.setButtonOutCallback(Zb(n, "onButtonOut")), i.setListExpandDirection(Zb(n, "expandDirection")), i.setListEaseInDuration(Zb(n, "easeIn", 500)), i.setListEaseOutDuration(Zb(n, "easeOut", 100)), i.setListTransitInCallback(Zb(n, "transitIn")), i.settListTTransitOutCallback(Zb(n, "transitOut")), i.setListSize(Zb(n, "width"), Zb(n, "height")), i.setListAlignmentMode(Zb(n, "alignParent", "text")), i.setListBounds(Zb(n, "bounds")), i.setListSpace(Zb(n, "space")), i.setListDraggable(Zb(n, "draggable", !1)), i.setValueChangeCallback(Zb(e, "setValueCallback"), Zb(e, "setValueCallbackScope")), i.setValue(Zb(e, "value")), i.onClick(i.toggleListPanel, W(i)), i } return k(r, [{ key: "destroy", value: function(t) { this.scene && (this.listPanel && (this.listPanel.destroy(t), this.listPanel = void 0), O(C(r.prototype), "destroy", this).call(this, t), this.removeDelayCall()) } }, { key: "setOptions", value: function(t) { return void 0 === t && (t = []), this.options = t, this } }, { key: "setValueChangeCallback", value: function(t, e) { return this.valueChangeCallback = t, this.valueChangeCallbackScope = e, this } }, { key: "setValue", value: function(t) { return this.value = t, this } }, { key: "value", get: function() { return this._value }, set: function(t) { if (this._value !== t) { var e = this._value;
                        this._value = t; var i = this.valueChangeCallback,
                            n = this.valueChangeCallbackScope;
                        i && (n ? i.call(n, this, t, e) : i(this, t, e)) } } }]), r }();
    Object.assign(qb.prototype, Kb), p.register("dropDownList", function(t) { var e = new qb(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.DropDownList", qb);

    function $b(t) { return t instanceof sx }

    function Qb(t) { return t instanceof rx }

    function tx(t) { return Qb(t) ? 2 : $b(t) ? 0 : 1 }

    function ex(t, e, i) { switch (tx(t)) {
            case 0:
                i = t.getWrappedText(e); break;
            case 1:
                i = t.getPenManager(e, i); break;
            case 2:
                i = 0 < t.maxWidth ? t.setText(e).getTextBounds().wrappedText.split("\n") : e.split("\n") } return i }

    function ix(t) { return Array.isArray(t) ? t = t.join("\n") : "number" == typeof t && (t = t.toString()), t }

    function nx(t, e) { switch (tx(t)) {
            case 0:
                var i = (s = t.style).wordWrapWidth,
                    n = s.wordWrapCallback;
                s.wordWrapWidth = 0, s.wordWrapCallback = void 0, t.setText(e), s.wordWrapWidth = i, s.wordWrapCallback = n; break;
            case 1:
                var s, r = (s = t.style).wrapMode;
                s.wrapMode = 0, t.setText(e), s.wrapMode = r; break;
            case 2:
                var o = t._maxWidth;
                t._maxWidth = 0, t.setText(e), t._maxWidth = o } } var sx = Phaser.GameObjects.Text,
        rx = Phaser.GameObjects.BitmapText,
        ox = { clearText: function() { return this.sections.length = 0, this.pageStartIndexes.length = 0, this.lines.length = 0, this }, appendPage: function(t) { var e = this.totalLinesCount;
                this.sections.push(ix(t));
                t = this.sections.join("\n");
                this.lines = ex(this.parent, t, this.lines); for (var i = this.totalLinesCount - e, n = Math.ceil(i / this.pageLinesCount), s = 0; s < n; s++) this.pageStartIndexes.push(e + s * this.pageLinesCount); return this }, setText: function(t, e) { void 0 === e && (e = !0), e && this.resetPageIdx(), this.clearText(); for (var i = ix(t).split(this.pageBreak), n = 0, s = i.length; n < s; n++) this.appendPage(i[n]); return this }, appendText: function(t) { var e = this.content + ix(t); return this.setText(e, !1), this } },
        ax = Phaser.Math.Clamp,
        hx = { getPage: function(t) { return void 0 === t && (t = this.pageIndex), this.setPageIndex(t).getLines(this.startLineIndex, this.endLineIndex) }, getNextPage: function() { return this.getPage(this.pageIndex + 1) }, getPreviousPage: function() { return this.getPage(this.pageIndex - 1) }, resetPageIdx: function() { return this.pageIndex = -1, this }, setPageIndex: function(t) { return t = ax(t, 0, this.pageCount - 1), this.pageIndex = t, this.startLineIndex = this.pageStartIndexes[t], this.endLineIndex = this.pageStartIndexes[t + 1], this } },
        lx = { showPage: function(t) { return this.displayText(this.getPage(t)), this }, showNextPage: function() { return this.displayText(this.getNextPage()), this }, showPreviousPage: function() { return this.displayText(this.getPreviousPage()), this }, show: function() { return this.displayText(this.getLines()), this }, showNextLine: function() { return this.displayText(this.setStartLineIndex(this.startLineIndex + 1).getLines()), this }, showPreviousLine: function() { return this.displayText(this.setStartLineIndex(this.startLineIndex - 1).getLines()), this }, displayText: function(t) { nx(this.parent, t) } },
        ux = { getLines: function(t, e) { var i; switch (void 0 === t && (t = this.startLineIndex), void 0 === e && (e = t + this.pageLinesCount), this.textObjectType) {
                    case 0:
                    case 2:
                        i = this.lines.slice(t, e).join("\n"); break;
                    case 1:
                        var n = this.lines.getLineStartIndex(t),
                            s = this.lines.getLineEndIndex(e - 1);
                        i = this.lines.getSliceTagText(n, s, !0) } return i } };
    Object.assign(ux, ox, hx, lx); var cx = Phaser.Utils.Objects.GetValue,
        dx = Phaser.Math.Clamp,
        fx = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, { eventEmitter: !1 })).textObjectType = tx(i.parent), i.pageStartIndexes = [], i.lines = ex(i.parent, ""), i.sections = [], i.resetFromJSON(e), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.setMaxLines(cx(t, "maxLines", void 0)), this.setPageBreak(cx(t, "pageBreak", "\f\n")), this.setText(cx(t, "text", "")), this.setStartLineIndex(cx(t, "start", 0)), this.setPageIndex(cx(t, "page", -1)), this } }, { key: "toJSON", value: function() { return { maxLines: this.maxLines, text: this.content, start: this.startLineIndex, page: this.pageIndex, pageBreak: this.pageBreak } } }, { key: "shutdown", value: function(t) { if (!this.isShutdown) { switch (this.textObjectType) {
                            case 0:
                                this.lines.length = 0; break;
                            case 1:
                                this.lines.destroy(); break;
                            case 2:
                                this.lines.length = 0 }
                        this.pageStartIndexes.length = 0, this.sections.length = 0, this.lines = void 0, this.pageStartIndexes = void 0, this.sections = void 0, O(C(s.prototype), "shutdown", this).call(this, t) } } }, { key: "setMaxLines", value: function(t) { return this.maxLines = t, this } }, { key: "setPageBreak", value: function(t) { return this.pageBreak = t, this } }, { key: "pageCount", get: function() { return this.pageStartIndexes.length } }, { key: "isFirstPage", get: function() { return this.pageIndex <= 0 } }, { key: "isLastPage", get: function() { return this.pageIndex >= this.pageCount - 1 } }, { key: "totalLinesCount", get: function() { return this.lines ? this.lines.length : 0 } }, { key: "startLineIndex", get: function() { return this._startLineIndex }, set: function(t) { t = dx(t, 0, this.totalLinesCount - 1), this._startLineIndex = t } }, { key: "setStartLineIndex", value: function(t) { return this.startLineIndex = t, this } }, { key: "pageLinesCount", get: function() { if (void 0 !== this.maxLines) return this.maxLines; var t; switch (this.textObjectType) {
                        case 0:
                        case 1:
                            var e = this.parent.style.maxLines;
                            t = 0 < e ? e : this.totalLinesCount; break;
                        case 2:
                            t = this.totalLinesCount } return t } }, { key: "content", get: function() { return this.sections.join(this.pageBreak) } }]), s }();
    Object.assign(fx.prototype, ux); var px = Phaser.Utils.Objects.GetFastValue,
        vx = Phaser.Utils.Objects.GetValue,
        gx = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).timer = null, i.resetFromJSON(e), i } return k(s, [{ key: "resetFromJSON", value: function(t) { this.setTextWrapEnable(vx(t, "wrap", !1)), this.setTypeMode(vx(t, "typeMode", 0)), this.setTypingSpeed(vx(t, "speed", 333)), this.setTextCallback = px(t, "setTextCallback", null), this.setTextCallbackScope = px(t, "setTextCallbackScope", null), this.setTypingContent(px(t, "text", "")), this.typingIdx = px(t, "typingIdx", 0), this.insertIdx = px(t, "insertIdx", null); var e = px(t, "elapsed", null); return null !== e && this.start(void 0, void 0, this.typingIdx, e), this } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.freeTimer(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "setTypeMode", value: function(t) { return "string" == typeof t && (t = mx[t]), this.typeMode = t, this } }, { key: "setTypeSpeed", value: function(t) { return this.speed = t, this } }, { key: "setTypingSpeed", value: function(t) { return this.speed = t, this } }, { key: "setTextWrapEnable", value: function(t) { return void 0 === t && (t = !0), this.textWrapEnable = t, this } }, { key: "text", get: function() { return this._text }, set: function(t) { var e = yx(t);
                    this.textWrapEnable && (e = function(t, e) { switch (tx(t)) {
                            case 0:
                                t.style.syncFont(t.canvas, t.context), e = t.runWordWrap(e); break;
                            case 1:
                                e = t.getText(e, void 0, void 0, !0); break;
                            case 2:
                                e = t.setText(e).getTextBounds().wrappedText } return e }(this.parent, e)), this._text = e } }, { key: "isTyping", get: function() { return null !== this.getTimer() } }, { key: "isLastChar", get: function() { return this.typingIdx === this.textLen } }, { key: "start", value: function(t, e, i, n) { return void 0 !== t && this.setTypingContent(t), void 0 !== e && (this.speed = e), void 0 === i && (i = 0), this.typingIdx = i + 1, 0 === this.speed ? this.stop(!0) : (this.setText(""), this.startTimer(n)), this } }, { key: "appendText", value: function(t) { var e = this.text.concat(yx(t)); return this.isTyping ? this.setTypingContent(e) : this.start(e, void 0, this.textLen), this } }, { key: "stop", value: function(t) { return this.getTimer() && this.freeTimer(), t && (this.typingIdx = this.textLen, this.setText(this.text), this.emit("type"), this.emit("complete", this, this.parent)), this } }, { key: "pause", value: function() { var t = this.getTimer(); return t && (t.paused = !0), this } }, { key: "resume", value: function() { var t = this.getTimer(); return t && (t.paused = !1), this } }, { key: "setTypingContent", value: function(t) { return this.text = t, this.textLen = this.getTextLength(this.text), this } }, { key: "onTyping", value: function() { var t = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode);
                    this.setText(t), this.emit("type"), this.isLastChar ? (this.freeTimer(), this.emit("complete", this, this.parent)) : (this.timer.delay = this.speed, this.typingIdx++) } }, { key: "getTypingString", value: function(t, e, i, n) { var s; if (0 === n) { var r = 0,
                            o = e;
                        this.insertIdx = o, s = this.getSubString(t, r, o) } else if (1 === n) { r = (o = i) - e;
                        this.insertIdx = 0, s = this.getSubString(t, r, o) } else if (2 === n) { var a = i / 2;
                        o = (r = Math.floor(a - e / 2)) + e;
                        this.insertIdx = e % 2 ? e : 0, s = this.getSubString(t, r, o) } else if (3 === n) { var h, l = Math.floor(e / 2); if (0 < l) { r = (o = i) - l;
                            h = this.getSubString(t, r, o) } else h = ""; var u, c = e - l; if (0 < c) { o = (r = 0) + c;
                            this.insertIdx = o, u = this.getSubString(t, r, o) } else u = "", this.insertIdx = 0;
                        s = u + h } return s } }, { key: "startTimer", value: function(t) { var e; return this.timer && this.freeTimer(), e = void 0 === t ? 0 : (this.speed, t), this.timer = this.scene.time.addEvent({ delay: 0, startAt: e, loop: !0, callback: this.onTyping, callbackScope: this }), this } }, { key: "getTimer", value: function() { return this.timer } }, { key: "freeTimer", value: function() { return this.timer && (this.timer.remove(), this.timer = null), this } }, { key: "setText", value: function(t) { this.setTextCallback && (t = this.setTextCallbackScope ? this.setTextCallback.call(this.setTextCallbackScope, t, this.isLastChar, this.insertIdx) : this.setTextCallback(t, this.isLastChar, this.insertIdx)), this.textWrapEnable ? nx(this.parent, t) : this.parent.setText(t) } }, { key: "getTextLength", value: function(t) { var e = this.parent; return e.getPlainText ? e.getPlainText(t).length : t.length } }, { key: "getSubString", value: function(t, e, i) { var n = this.parent; return n.getSubString ? n.getSubString(t, e, i) : t.slice(e, i) } }]), s }(),
        yx = function(t) { return Array.isArray(t) ? t = t.join("\n") : "number" == typeof t && (t = t.toString()), t },
        mx = { "left-to-right": 0, "right-to-left": 1, "middle-to-sides": 2, "sides-to-middle": 3 },
        kx = Phaser.Utils.Objects.GetValue,
        bx = function() { w(r, Xy); var s = T(r);

            function r(t, e) { var i;
                X(this, r), void 0 === e && (e = { text: xx(t) }), (i = s.call(this, t, e)).type = "rexTextBox"; var n = i.childrenMap.text; return i.page = new fx(n, kx(e, "page", void 0)), i.typing = new gx(n, kx(e, "typing", e.type)), i.typing.on("complete", i.onPageEnd, W(i)).on("type", i.onType, W(i)), i.textWidth = n.width, i.textHeight = n.height, i } return k(r, [{ key: "start", value: function(t, e) { return this.page.setText(t), void 0 !== e && this.setTypingSpeed(e), this.typeNextPage(), this } }, { key: "typeNextPage", value: function() { if (this.isLastPage) this.emit("complete");
                    else { var t = this.page.getNextPage();
                        this.typing.start(t) } return this } }, { key: "pause", value: function() { return this.typing.pause(), this } }, { key: "resume", value: function() { return this.typing.resume(), this } }, { key: "stop", value: function(t) { return this.typing.stop(t), this } }, { key: "setTypeSpeed", value: function(t) { return this.typing.setTypingSpeed(t), this } }, { key: "setTypingSpeed", value: function(t) { return this.typing.setTypingSpeed(t), this } }, { key: "isTyping", get: function() { return this.typing.isTyping } }, { key: "isLastPage", get: function() { return this.page.isLastPage } }, { key: "isFirstPage", get: function() { return this.page.isFirstPage } }, { key: "pageCount", get: function() { return this.page.pageCount } }, { key: "pageIndex", get: function() { return this.page.pageIndex } }, { key: "onType", value: function() { var t = this.childrenMap.text;
                    this.textWidth === t.width && this.textHeight === t.height || (this.textWidth = t.width, this.textHeight = t.height, this.getTopmostSizer().layout()), this.emit("type") } }, { key: "onPageEnd", value: function() { this.emit("pageend"), this.isLastPage && this.emit("complete") } }]), r }(),
        xx = function(t) { return t.add.text(0, 0, "", { wordWrap: { width: 200 }, maxLines: 5 }) };
    p.register("textBox", function(t) { var e = new bx(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.TextBox", bx); var Cx = Phaser.Utils.Objects.GetValue,
        wx = function() { w(g, oy); var v = T(g);

            function g(t, e) { var i;
                X(this, g), (i = v.call(this, t, e)).type = "rexNumberBar"; var n, s = Cx(e, "background", void 0),
                    r = Cx(e, "icon", void 0),
                    o = Cx(e, "iconMask", void 0),
                    a = Cx(e, "slider", void 0),
                    h = Cx(e, "text", void 0),
                    l = Cx(e, "space.icon", 0),
                    u = Cx(e, "space.slider", 0);
                s && i.addBackground(s), r && (0 === i.orientation ? (a || h) && (c = { right: l }) : (a || h) && (c = { bottom: l }), i.add(r, { proportion: 0, align: "center", padding: c }), o = o && Fy.call(W(i), r, r, 1)); if (a) { var c, d; if (a.orientation = i.orientation, a.eventEmitter = W(i), a.value = null, a.hasOwnProperty("input") || (a.input = -1), n = new gk(t, a), t.add.existing(n), 0 === i.orientation ? h && (c = { right: u }) : h && (c = { bottom: u }), 0 === i.orientation) d = void 0 === Cx(a, "width", void 0) ? 1 : 0;
                    else d = void 0 === Cx(a, "height", void 0) ? 1 : 0;
                    i.add(n, { proportion: d, align: "center", padding: c }) }
                h && i.add(h), i.addChildrenMap("background", s), i.addChildrenMap("icon", r), i.addChildrenMap("iconMask", o), i.addChildrenMap("slider", n), i.addChildrenMap("text", h); var f = Cx(e, "valuechangeCallback", null); if (null !== f) { var p = Cx(e, "valuechangeCallbackScope", void 0);
                    i.on("valuechange", f, p) } return i.setEnable(Cx(e, "enable", void 0)), i.setValue(Cx(e, "value", 0)), i } return k(g, [{ key: "enable", get: function() { return !!this.childrenMap.slider && this.childrenMap.slider.enable }, set: function(t) { this.childrenMap.slider && this.childrenMap.slider.setEnable(t) } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "value", get: function() { return this.childrenMap.slider ? this.childrenMap.slider.value : 0 }, set: function(t) { this.childrenMap.slider && (this.childrenMap.slider.value = t) } }, { key: "setValue", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.setValue(t, e, i), this } }, { key: "addValue", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.addValue(t, e, i), this } }, { key: "getValue", value: function(t, e) { return this.childrenMap.slider ? this.childrenMap.slider.getValue(t, e) : 0 } }, { key: "easeValueTo", value: function(t, e, i) { return this.childrenMap.slider && this.childrenMap.slider.easeValueTo(t, e, i), this } }, { key: "stopEaseValue", value: function() { return this.childrenMap.slider && this.childrenMap.slider.stopEaseValue(), this } }, { key: "setEaseValueDuration", value: function(t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueDuration(t), this } }, { key: "setEaseValueFunction", value: function(t) { return this.childrenMap.slider && this.childrenMap.slider.setEaseValueFunction(t), this } }, { key: "text", get: function() { var t = this.childrenMap.text; return void 0 === t ? "" : t.text ? t.text : t.getData("text") }, set: function(t) { var e = this.childrenMap.text;
                    void 0 !== e && (e.setText ? e.setText(t) : e.setData("text", t)) } }, { key: "setText", value: function(t) { return this.text = t, this } }]), g }();
    p.register("numberBar", function(t) { var e = new wx(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.NumberBar", wx), p.register("scrollBar", function(t) { var e = new wk(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.ScrollBar", wk); var Sx = Phaser.Utils.Objects.GetValue,
        Px = { leftTop: "left-top", centerTop: "center-top", rightTop: "right-top", leftCenter: "left-center", center: "center", rightCenter: "right-center", leftBottom: "left-bottom", centerBottom: "center-bottom", rightBottom: "right-bottom" },
        Tx = function() { w(h, Rv); var a = T(h);

            function h(t, e) { var i;
                X(this, h), (i = a.call(this, t, e)).type = "rexBadge"; var n = Sx(e, "background", void 0);
                n && i.addBackground(n), i.addChildrenMap("background", n); var s = Sx(e, "main", void 0); for (var r in s && i.add(s, { key: "main", align: "center", expand: !1 }), i.addChildrenMap("main", s), Px) { var o = Sx(e, r, void 0);
                    o && (i.add(o, { key: r, align: Px[r], expand: !1 }), i.addChildrenMap(r, o)) } return i } return k(h) }();
    p.register("badgeLabel", function(t) { var e = new Tx(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.BadgeLabel", Tx);

    function Ox(t, e, i, n, s, r, o, a, h) { return t.setVisible(!1), Mx.call(this, t, e, i, n, s, r, o, a, h), this } var Mx = Rv.prototype.add,
        Ex = { add: Ox, addPage: Ox },
        _x = Kr.prototype.setChildVisible,
        Rx = { getPage: function(t) { return void 0 !== t && this.sizerChildren.hasOwnProperty(t) ? this.sizerChildren[t] : null }, swapPage: function(t) { this._previousKey = this._currentKey; var e = this.previousPage;
                e && (0 === this.swapMode ? (_x.call(this, e, !1), this.emit("pageinvisible", e, this._previousKey, this)) : e.destroy()), t && !this.sizerChildren.hasOwnProperty(t) && this.emit("createpage", t, this), this._currentKey = t; var i = this.currentPage; return i && (_x.call(this, i, !0), this.emit("pagevisible", i, this._currentKey, this), 0 < this.fadeInDuration && i.setAlpha(0).fadeIn(this.fadeInDuration, 1)), this }, hasPage: function(t) { return this.sizerChildren.hasOwnProperty(t) } };
    Object.assign(Rx, Ex); var Bx = Phaser.Utils.Objects.GetValue,
        Ix = function() { w(s, Rv); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).type = "rexPages", i.childrenMap = i.sizerChildren, i._previousKey = void 0, i._currentKey = void 0, i.setSwapMode(Bx(e, "swapMode", 0)), i.setFadeInDuration(Bx(e, "fadeIn", 0)), i } return k(s, [{ key: "setSwapMode", value: function(t) { return "string" == typeof t && (t = Lx[t]), this.swapMode = t, this } }, { key: "setFadeInDuration", value: function(t) { return this.fadeInDuration = t, this } }, { key: "previousKey", get: function() { return this._previousKey } }, { key: "currentKey", get: function() { return this._currentKey }, set: function(t) { this.swapPage(t) } }, { key: "currentPage", get: function() { return this.getPage(this.currentKey) } }, { key: "previousPage", get: function() { return this.getPage(this.previousKey) } }, { key: "keys", get: function() { return Object.keys(this.sizerChildren) } }]), s }();
    Object.assign(Ix.prototype, Rx); var Lx = { invisible: 0, destroy: 1 };
    p.register("pages", function(t) { var e = new Ix(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Pages", Ix); var Ax = Phaser.Math.Vector3,
        jx = Phaser.Math.Matrix4,
        Dx = new Ax(),
        zx = new Ax(),
        Fx = new jx(),
        Yx = Phaser.GameObjects.Mesh,
        Xx = Phaser.Utils.Objects.IsPlainObject,
        Wx = Phaser.Utils.Objects.GetValue,
        Gx = Phaser.Geom.Mesh.GenerateGridVerts,
        Vx = Phaser.Math.RadToDeg,
        Ux = Phaser.Math.DegToRad,
        Hx = 1 + 1 / Math.sin(Ux(45)),
        Nx = function() { w(u, Yx); var l = T(u);

            function u(t, e, i, n, s, r) { var o;
                X(this, u), Xx(e) && (e = Wx(r = e, "x", 0), i = Wx(r, "y", 0), n = Wx(r, "key", null), s = Wx(r, "frame", null)), (o = l.call(this, t, e, i, n, s)).type = "rexPerspectiveImage", o.setSizeToFrame(), o.resetPerspective(), o.panZ(Hx), o.hideCCW = Wx(r, "hideCCW", !0); var a = Wx(r, "gridWidth", 32),
                    h = Wx(r, "gridHeight", a); return o.resetVerts(a, h), o } return k(u, [{ key: "resetPerspective", value: function() { return this.setPerspective(this.width, this.height, 45), this } }, { key: "resetVerts", value: function(t, e) { if (void 0 !== t && (this.gridWidth = t), void 0 !== e && (this.gridHeight = e), this.clear(), this.dirtyCache[9] = -1, 0 === this.width || 0 === this.height) return this; var i = this.frame.cutWidth,
                        n = this.frame.cutHeight;
                    Gx({ mesh: this, texture: this.texture.key, frame: this.frame.name, width: i / this.height, height: n / this.height, widthSegments: Math.ceil(i / this.gridWidth), heightSegments: Math.ceil(n / this.gridHeight), flipY: this.frame.source.isRenderTexture }); var s = this.transformInfo; return s && this.transformVerts(s.x, s.y, s.z, s.rotateX, s.rotateY, s.rotateZ), this } }, { key: "syncSize", value: function() { return this.setSizeToFrame(), this.resetPerspective(), this.resetVerts(), this } }, { key: "rotationX", get: function() { return this.modelRotation.x }, set: function(t) { this.modelRotation.x = t } }, { key: "angleX", get: function() { return Vx(this.rotationX) }, set: function(t) { this.rotationX = Ux(t) } }, { key: "rotationY", get: function() { return this.modelRotation.y }, set: function(t) { this.modelRotation.y = t } }, { key: "angleY", get: function() { return Vx(this.rotationY) }, set: function(t) { this.rotationY = Ux(t) } }, { key: "rotationZ", get: function() { return this.modelRotation.z }, set: function(t) { this.modelRotation.z = t } }, { key: "angleZ", get: function() { return Vx(this.rotationZ) }, set: function(t) { this.rotationZ = Ux(t) } }, { key: "transformVerts", value: function(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.transformInfo || (this.transformInfo = {}), this.transformInfo.x = t, this.transformInfo.y = e, this.transformInfo.rotateX = n, this.transformInfo.rotateY = s, this.transformInfo.rotateZ = r,
                        function(t, e, i, n, s, r, o) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), Dx.set(e, i, n), zx.set(s, r, o), Fx.fromRotationXYTranslation(zx, Dx, !0); for (var a = 0, h = t.vertices.length; a < h; a++) t.vertices[a].transformMat4(Fx) }(this, t, e, i, n, s, r), this } }, { key: "forceUpdate", value: function() { return this.dirtyCache[10] = 1, this } }, { key: "tint", get: function() { return 0 === this.vertices.length ? 16777215 : this.vertices[0].color }, set: function(t) { for (var e = this.vertices, i = 0, n = e.length; i < n; i++) e[i].color = t } }, { key: "setTint", value: function(t) { return this.tint = t, this } }]), u }(),
        Jx = Phaser.GameObjects.RenderTexture,
        Kx = Phaser.Utils.Objects.IsPlainObject,
        Zx = Phaser.Utils.Objects.GetValue,
        qx = function() { w(l, Nx); var h = T(l);

            function l(t, e, i, n, s, r) { var o;
                X(this, l), Kx(e) && (e = Zx(r = e, "x", 0), i = Zx(r, "y", 0), n = Zx(r, "width", 32), s = Zx(r, "height", 32)); var a = new Jx(t, e, i, n, s).setOrigin(.5); return (o = h.call(this, t, e, i, a.texture.key, null, r)).type = "rexPerspectiveRenderTexture", o.rt = a, o } return k(l, [{ key: "destroy", value: function(t) { O(C(l.prototype), "destroy", this).call(this, t), this.rt.destroy(), this.rt = null } }, { key: "snapshot", value: function(t, e) { return void 0 === e && (e = {}), e.gameObjects = t, e.renderTexture = this.rt, Qs(e), this.width === this.frame.realWidth && this.height === this.frame.realHeight || this.syncSize(), this } }]), l }();
    Phaser.Animations.AnimationState, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue;

    function $x(t, e, i, n) { if (Array.isArray(t))
            for (var s = 0, r = t.length; s < r; s++) { var o = t[s]; if ((!n || o) && (i ? e.call(i, o, s, t) : e(o, s, t))) return } else { for (var a in t) { o = t[a]; if ((!n || o) && (i ? e.call(i, o, a, t) : e(o, a, t))) return } } }

    function Qx(t, e) { var i; return void 0 === e && (e = sC), nC(e) ? (e.hasOwnProperty("type") || (e.hasOwnProperty("key") ? e.type = "image" : e.hasOwnProperty("width") && (e.type = "rendertexture")), i = new rC[e.type](t, e), t.add.existing(i)) : i = e, i } var tC = Phaser.Math.RadToDeg,
        eC = Phaser.Math.DegToRad,
        iC = function() { w(h, Kr); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), (o = a.call(this, t, e, i, n, s)).faces = r, $x(r, function(t) { t.setPosition(e, i), this.add(t) }, W(o), !0), o } return k(h, [{ key: "rotationX", get: function() { return 0 }, set: function() {} }, { key: "angleX", get: function() { return tC(this.rotationX) }, set: function(t) { this.rotationX = eC(t) } }, { key: "rotationY", get: function() { return 0 }, set: function() {} }, { key: "angleY", get: function() { return tC(this.rotationY) }, set: function(t) { this.rotationY = eC(t) } }, { key: "rotationZ", get: function() { return 0 }, set: function() {} }, { key: "angleZ", get: function() { return tC(this.rotationZ) }, set: function(t) { this.rotationZ = eC(t) } }, { key: "setDebug", value: function(e, i) { return $x(this.faces, function(t) { t.setDebug(e, i) }, null, !0), this } }, { key: "panX", value: function(e) { return $x(this.faces, function(t) { t.panX(e) }, null, !0), this } }, { key: "panY", value: function(e) { return $x(this.faces, function(t) { t.panY(e) }, null, !0), this } }, { key: "panZ", value: function(e) { return $x(this.faces, function(t) { t.panZ(e) }, null, !0), this } }, { key: "transformVerts", value: function(e, i, n, s, r, o) { return $x(this.faces, function(t) { t.transformVerts(e, i, n, s, r, o) }, null, !0), this } }, { key: "forEachFace", value: function(t, e, i) { return $x(this.faces, t, e, i), this } }]), h }(),
        nC = Phaser.Utils.Objects.IsPlainObject,
        sC = { key: "__WHITE" },
        rC = { image: Nx, rendertexture: qx },
        oC = (0, Phaser.Math.DegToRad)(180),
        aC = Phaser.Utils.Objects.GetValue,
        hC = Phaser.Math.Linear,
        lC = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setEase(aC(t, "ease", "Cubic")), this.setFrontToBackDirection(aC(t, "frontToBack", 0)), this.setBackToFrontDirection(aC(t, "backToFront", 1)), this } }, { key: "setFrontToBackDirection", value: function(t) { return "string" == typeof t && (t = uC[t]), this.endAngleFB = 0 === t ? 180 : -180, this } }, { key: "setBackToFrontDirection", value: function(t) { return "string" == typeof t && (t = uC[t]), this.endAngleBF = 0 === t ? -180 : 180, this } }, { key: "start", value: function(t, e) { if (this.timer.isRunning) return this;
                    this.timer.setDelay(this.delay).setDuration(t); var i = e + 1; return 0 === this.parent.face ? (this.startAngle = 0, this.endAngle = this.endAngleFB * i) : (this.startAngle = this.endAngleBF, this.endAngle = this.startAngle - this.endAngleBF * i), O(C(s.prototype), "start", this).call(this), this } }, { key: "flip", value: function(t, e) { return this.isRunning || (void 0 === t && (t = this.duration), void 0 === e && (e = 0), this.start(t, e), this.emit("start", this.parent, this), this.parent.currentFaceIndex = (this.parent.currentFaceIndex + e + 1) % 2), this } }, { key: "flipRight", value: function(t, e) { return 0 === this.parent.currentFaceIndex ? this.setFrontToBackDirection(0) : this.setBackToFrontDirection(0), this.flip(t, e), this } }, { key: "flipLeft", value: function(t, e) { return 0 === this.parent.currentFaceIndex ? this.setFrontToBackDirection(1) : this.setBackToFrontDirection(1), this.flip(t, e), this } }, { key: "updateGameObject", value: function(t, e) { var i = this.easeFn(e.t),
                        n = hC(this.startAngle, this.endAngle, i);
                    0 === t.orientation ? t.angleY = n : t.angleX = n } }]), s }(),
        uC = { right: 0, "left-to-right": 0, left: 1, "right-to-left": 1 },
        cC = Phaser.Utils.Objects.IsPlainObject,
        dC = Phaser.Utils.Objects.GetValue,
        fC = ["back", "front"],
        pC = function() { w(m, iC); var y = T(m);

            function m(t, e, i, n) { var s;
                X(this, m), cC(e) && (e = dC(n = e, "x", 0), i = dC(n, "y", 0)); var r = function(t, e, i) { var n; if (void 0 === i) { var s;
                            n = []; for (var r = 0, o = e.length; r < o; r++) a = (s = e[r]) ? Qx(t, s) : null, n.push(a) } else { var a, h;
                            n = {}; for (r = 0, o = i.length; r < o; r++) h = i[r], a = e.hasOwnProperty(h) ? Qx(t, e[h]) : null, n[h] = a } return n }(t, n, fC),
                    o = r.back,
                    a = r.front,
                    h = dC(n, "width"),
                    l = dC(n, "height"); if (void 0 === h || void 0 === l) { if (void 0 === h) { var u = a ? a.width : 0,
                            c = o ? o.width : 0;
                        h = Math.max(u, c) } if (void 0 === l) { var d = a ? a.height : 0,
                            f = o ? o.height : 0;
                        l = Math.max(d, f) } }(s = y.call(this, t, e, i, h, l, r)).type = "rexPerspectiveCard", s.frontFaceRotationX = 0, s.frontFaceRotationY = 0, s.frontFaceRotationZ = 0, $x(r, function(t, e) { this["".concat(e, "Face")] = t }, W(s)); var p, v, g = dC(n, "flip", void 0); return !1 !== g && (s.flip = new lC(W(s), g)), s.setOrientation(dC(n, "orientation", 0)), p = W(s), (v = r.back) && (0 === p.orientation ? v.transformVerts(0, 0, 0, 0, oC, 0) : v.transformVerts(0, 0, 0, oC, 0, 0)), s.setFace(dC(n, "face", 0)), s } return k(m, [{ key: "rotationX", get: function() { return this.frontFaceRotationX }, set: function(e) { this.frontFaceRotationX !== e && (this.frontFaceRotationX = e, $x(this.faces, function(t) { t.rotationX = e }, null, !0)) } }, { key: "rotationY", get: function() { return this.frontFaceRotationY }, set: function(e) { this.frontFaceRotationY !== e && (this.frontFaceRotationY = e, $x(this.faces, function(t) { t.rotationY = e }, null, !0)) } }, { key: "rotationZ", get: function() { return this.frontFaceRotationZ }, set: function(e) { this.frontFaceRotationZ !== e && (this.frontFaceRotationZ = e, $x(this.faces, function(t) { t.rotationZ = e }, null, !0)) } }, { key: "setOrientation", value: function(t) { return "string" == typeof t && (t = vC[t]), this.orientation = t, this } }, { key: "face", get: function() { return this.currentFaceIndex }, set: function(t) { "string" == typeof t && (t = gC[t]); var e = 1 === (this.currentFaceIndex = t) ? 180 : 0;
                    0 === this.orientation ? this.angleY = e : this.angleX = e } }, { key: "setFace", value: function(t) { return this.face = t, this } }, { key: "toggleFace", value: function() { var t = 0 === this.face ? 1 : 0; return this.setFace(t), this } }]), m }(),
        vC = { x: 0, horizontal: 0, h: 0, y: 1, vertical: 1, v: 1 },
        gC = { front: 0, back: 1 };
    Phaser.Utils.Objects.GetValue, Phaser.Math.RadToDeg, Phaser.Math.DegToRad, Phaser.Math.Angle.WrapDegrees, Phaser.Math.Angle.ShortestBetween, Phaser.Math.Wrap, Phaser.Math.Linear, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Math.DegToRad, Phaser.Math.RadToDeg, Phaser.Math.Angle.WrapDegrees, Phaser.Math.Linear, Phaser.Math.Wrap, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue, Phaser.Math.Wrap;

    function yC(t, e) { if (t) { for (var i = e.visibleSibling, n = 0, s = i.length; n < s; n++) t.setChildVisible(i[n], !0); return i.length = 0, t.setChildVisible(e, !1), e.isRunning = !1, 1 } }

    function mC(t) { return function() { w(h, t); var a = T(h);

            function h(t, e) { var i;
                X(this, h); var n, s, r, o = t.scene; return i = a.call(this, o, 0, 0, 1, 1, e), o.add.existing(W(i)), n = t, s = W(i), r = e, s.visibleSibling = [], s.isRunning = !1, s.useParentBounds = kC(r, "useParentBounds", !1), s.setPosition(n.x, n.y).setVisible(!1), n.pin(s), i } return k(h, [{ key: "destroy", value: function(t) { this.scene && (this.exit(), O(C(h.prototype), "destroy", this).call(this, t)) } }, { key: "enter", value: function() { return function(t, e) { if (!t) return !1;
                        yC(t, e); var i = e.useParentBounds;
                        Qs({ gameObjects: t.getAllVisibleChildren(), renderTexture: e.rt, x: e.x, y: e.y, width: i ? t.displayWidth : void 0, height: i ? t.displayHeighth : void 0, originX: i ? t.originX : void 0, originY: i ? t.originY : void 0 }), t.setChildVisible(e, !0); for (var n = e.visibleSibling, s = t.children, r = 0, o = s.length; r < o; r++) { var a = s[r];
                            a.visible && a !== e && (t.setChildVisible(a, !1), n.push(a)) } return e.isRunning = !0 }(this.rexContainer.parent, this) && this.syncSize(), this } }, { key: "exit", value: function() { return yC(this.rexContainer.parent, this), this } }]), h }() } var kC = Phaser.Utils.Objects.GetValue,
        bC = function() { w(e, mC(qx)); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "perspectiveState", get: function() { return this.isRunning } }]), e }(),
        xC = Phaser.Utils.Objects.GetValue,
        CC = ["front", "back"],
        wC = { enterPerspectiveMode: function() { return this.isInPerspectiveMode || (this.setChildVisible(this.perspectiveCard, !0), this.snapshotFace(0), this.snapshotFace(1), this.setChildVisible(this.childrenMap.front, !1), this.setChildVisible(this.childrenMap.back, !1), this.perspectiveCard.setSize(this.width, this.height)), this }, exitPerspectiveMode: function() { if (!this.isInPerspectiveMode) return this;
                this.setChildVisible(this.perspectiveCard, !1); var t = 0 === this.perspectiveCard.face; return this.setChildVisible(this.childrenMap.front, t), this.setChildVisible(this.childrenMap.back, !t), this }, setSnapshotPadding: function(t) { return this.snapshotPadding = t, this }, snapshotFace: function(t) { "number" == typeof t && (t = CC[t]); var e = this.perspectiveCard.faces[t],
                    i = this.childrenMap[t];
                e.rt.clear(); var n = i.visible;
                i.visible = !0; var s = i.isRexContainerLite ? i.getAllVisibleChildren() : i; return e.snapshot(s, { padding: this.snapshotPadding }), i.visible = n, this } },
        SC = Phaser.Utils.Objects.GetValue,
        PC = function() { w(h, Rv); var a = T(h);

            function h(t, e) { var i;
                X(this, h), (i = a.call(this, t, e)).type = "rexPerspectiveCard"; var n = e.back,
                    s = SC(e, "expand.back", !0);
                i.add(n, { key: "back", expand: s }); var r = e.front,
                    o = SC(e, "expand.front", !0); return i.add(r, { key: "front", expand: o }), i.perspectiveCard = function(t) { var e = this.scene;
                    this.setSnapshotPadding(xC(t, "snapshotPadding", 0)), delete(t = be(t)).width, delete t.height, t.front = { width: 1, height: 1 }, t.back = { width: 1, height: 1 }; var i = new pC(e, t);
                    e.add.existing(i); var n = i.flip; if (n) { var s = this;
                        n.on("start", function() { s.enterPerspectiveMode() }).on("complete", function() { s.exitPerspectiveMode() }) } return i }.call(W(i), e), i.pin(i.perspectiveCard), i.exitPerspectiveMode(!1), i } return k(h, [{ key: "flip", get: function() { return this.perspectiveCard.flip } }, { key: "face", get: function() { return this.perspectiveCard.face }, set: function(t) { if (!this.flip || !this.flip.isRunning) { var e = 0 === (this.perspectiveCard.face = t),
                            i = this.childrenMap.front,
                            n = this.childrenMap.back;
                        this.setChildVisible(i, e), this.setChildVisible(n, !e) } } }, { key: "setFace", value: function(t) { return this.face = t, this } }, { key: "toggleFace", value: function() { var t = 0 === this.face ? 1 : 0; return this.setFace(t), this } }, { key: "isInPerspectiveMode", get: function() { return this.perspectiveCard.visible } }, { key: "rotationX", get: function() { return this.perspectiveCard.rotationX }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.rotationX = t } }, { key: "angleX", get: function() { return this.perspectiveCard.angleX }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.angleX = t } }, { key: "rotationY", get: function() { return this.perspectiveCard.rotationY }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.rotationY = t } }, { key: "angleY", get: function() { return this.perspectiveCard.angleY }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.angleY = t } }, { key: "rotationZ", get: function() { return this.perspectiveCard.rotationZ }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.rotationZ = t } }, { key: "angleZ", get: function() { return this.perspectiveCard.angleZ }, set: function(t) { this.enterPerspectiveMode(), this.perspectiveCard.angleZ = t } }, { key: "panX", value: function(t) { return this.enterPerspectiveMode(), this.perspectiveCard.panX(t), this } }, { key: "panY", value: function(t) { return this.enterPerspectiveMode(), this.perspectiveCard.panY(t), this } }, { key: "panZ", value: function(t) { return this.enterPerspectiveMode(), this.perspectiveCard.panZ(t), this } }, { key: "transformVerts", value: function(t, e, i, n, s, r) { return this.enterPerspectiveMode(), this.perspectiveCard.transformVerts(t, e, i, n, s, r), this } }, { key: "forEachFace", value: function(t, e, i) { return this.enterPerspectiveMode(), this.perspectiveCard.forEachFace(t, e, i), this } }]), h }();
    Object.assign(PC.prototype, wC), p.register("perspectiveCard", function(t) { var e = new PC(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.PerspectiveCard", PC); var TC = Phaser.Utils.Objects.IsPlainObject,
        OC = Phaser.Utils.Objects.GetValue,
        MC = Phaser.Utils.String.UUID,
        EC = { swapPage: function(t) { var e; return null != (e = "number" == typeof t ? t : this.getPageIndex(t)) && this.childrenMap.tabs.emitButtonClick(e), this }, swapFirstPage: function() { return this.swapPage(0), this }, swapLastPage: function() { return this.swapPage(this.getElement("tabs.buttons").length - 1), this } },
        _C = { removePage: function(t, e) { "number" == typeof t && (t = this.getPageKey(t)); var i = this.childrenMap.tabs,
                    n = i.getByName(t),
                    s = this.childrenMap.pages,
                    r = s.getElement(t); return n && r && (s.removeChildrenMap(t), i.removeButton(n, e), s.remove(r, e)), this } },
        RC = { getPageKey: function(t) { var e = this.getElement("tabs.buttons"); if (!(t >= e.length)) return e[t].name }, getPageIndex: function(t) { for (var e = this.getElement("tabs.buttons"), i = 0, n = e.length; i < n; i++)
                    if (e[i].name === t) return i }, addPage: function(t, e, i) { if (TC(t)) { var n = t;
                    t = OC(n, "key"), e = OC(n, "tab"), i = OC(n, "page") } return t = t || MC(), e.name = t, this.childrenMap.tabs.addButton(e), this.childrenMap.pages.addPage(i, { key: t }), this }, getPage: function(t) { return "number" == typeof t && (t = this.getPageKey(t)), this.childrenMap.pages.getPage(t) }, getTab: function(t) { var e; return e = "number" == typeof t ? t : this.getPageIndex(t), this.getElement("tabs.buttons")[e] } };
    Object.assign(RC, EC, _C); var BC = Phaser.Utils.Objects.GetValue,
        IC = oy.prototype.add,
        LC = function() { w(g, oy); var v = T(g);

            function g(t, e) { var i;
                X(this, g), void 0 === e && (e = {}); var n = BC(e, "tabPosition", "top"),
                    s = "left" === n || "right" === n ? "x" : "y";
                e.orientation = s, (i = v.call(this, t, e)).type = "rexTabPages"; var r = BC(e, "background", void 0);
                r && i.addBackground(r); var o = BC(e, "pages"),
                    a = new Ix(t, o);
                t.add.existing(a); var h = "y" == s,
                    l = h && BC(e, "wrapTabs", !1),
                    u = BC(e, "tabs", void 0);
                void 0 === u && (u = {}); var c = l ? Lm : ym;
                u.orientation = h ? "x" : "y", u.buttonsType = "radio"; var d = new c(t, u);
                t.add.existing(d); var f = !!l || BC(e, "expand.tabs", !1),
                    p = BC(e, "align.tabs", "left"); switch (n) {
                    case "top":
                    case "left":
                        IC.call(W(i), d, { proportion: 0, expand: f, align: p }), IC.call(W(i), a, { proportion: 1, expand: !0 }); break;
                    case "bottom":
                    case "right":
                        IC.call(W(i), a, { proportion: 1, expand: !0 }), IC.call(W(i), d, { proportion: 0, expand: f, align: p }) } return i.addChildrenMap("background", r), i.addChildrenMap("tabs", d), i.addChildrenMap("pages", a), d.on("button.click", function(t) { var e = t.name;
                    a.hasPage(e) && a.swapPage(e) }), d.on("button.statechange", function(t, e, i, n) { var s = i ? "tab.focus" : "tab.blur";
                    this.emit(s, t, t.name) }, W(i)), a.on("pagevisible", function(t, e, i) { this.emit("page.focus", t, e) }), a.on("pageinvisible", function(t, e, i) { this.emit("page.blur", t, e) }), i } return k(g, [{ key: "currentKey", get: function() { return this.getElement("pages").currentKey }, set: function(t) { this.showPage(t) } }, { key: "keys", get: function() { return this.getElement("pages").keys } }, { key: "currentPage", get: function() { return this.getElement("pages").currentPage } }, { key: "previousPage", get: function() { return this.getElement("pages").previousPage } }]), g }();
    Object.assign(LC.prototype, RC), p.register("tabPages", function(t) { var e = new LC(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.TabPages", LC);

    function AC(t) { return (t - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing) }

    function jC(t) { return t * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing }

    function DC() { var t = this.textObject.rexSizer;
        this.textObject.y += t.offsetY - t.preOffsetY, t.preOffsetY = t.offsetY, this.resetChildPositionState(this.textObject), this.textCropEnable && zC.call(this) } var zC = function() { if (this.textObject.setCrop) { var t, e, i = this.textObject.rexSizer.offsetY;
                e = i <= 0 ? (t = -i, this.height) : (t = 0, this.height - i), this.textObject.setCrop(0, t, this.width, e) } },
        FC = { setText: function(t) { return void 0 !== t && (this.text = t), this.lines = ex(this.textObject, this.text, this.lines), this.linesCount = this.lines.length, this._textHeight = void 0, this._textVisibleHeight = void 0, this.updateTextObject(), this }, updateTextObject: function() { var t = Math.max(Math.floor(AC.call(this, -this.textOY)), 0),
                    e = jC.call(this, t) + this.textOY,
                    i = function(t) { var e, i = t + this.visibleLinesCount + 1; switch (this.textObjectType) {
                            case 0:
                                e = this.lines.slice(t, i).join("\n"); break;
                            case 1:
                                var n = this.lines.getLineStartIndex(t),
                                    s = this.lines.getLineEndIndex(i - 1);
                                e = this.lines.getSliceTagText(n, s, !0); break;
                            case 2:
                                e = this.lines.slice(t, i).join("\n") } return e }.call(this, t); return nx(this.textObject, i), this.textObject.rexSizer.offsetY = e, DC.call(this), this }, preLayout: function() { return this._textLineHeight = void 0, this._textLineSpacing = void 0, this._visibleLinesCount = void 0, this._textHeight = void 0, this._textVisibleHeight = void 0, ud.call(this), this }, layoutChildren: function() { var t, e, i, n, s, r, o, a = this.left,
                    h = this.top;
                (t = this.textObject).rexSizer.hidden || (n = a + (i = (e = t.rexSizer).padding).left, s = h + i.top, r = this.width - i.left - i.right, o = this.height - i.top - i.bottom, function(t, e, i) { if (i += this.textLineHeight + this.textLineSpacing, this.textObjectWidth !== e || this._textObjectRealHeight !== i) { switch (this.textObjectWidth = e, this._textObjectRealHeight = i, this.textObjectType) {
                            case 0:
                            case 1:
                                t.setFixedSize(e, i); var n = t.style,
                                    s = Math.max(e, 0);
                                0 === this.textObjectType ? n.wordWrapWidth = s : (0 === n.wrapMode && (n.wrapMode = 1), n.wrapWidth = s); break;
                            case 2:
                                t.setMaxWidth(e) }
                        this.setText() } }.call(this, t, r, o), sd(t, n, s, r, o, e.align), e.preOffsetY = 0, DC.call(this), this.textMask && (this.textMask.setPosition().resize(), this.resetChildPositionState(this.textMask))) } },
        YC = Phaser.Utils.Objects.IsPlainObject,
        XC = Phaser.Utils.Objects.GetValue,
        WC = Phaser.Display.Align.TOP_LEFT,
        GC = function() { w(d, pv); var c = T(d);

            function d(t, e, i, n, s, r) { var o;
                X(this, d), YC(e) ? (e = XC(r = e, "x", 0), i = XC(r, "y", 0), n = XC(r, "width", void 0), s = XC(r, "height", void 0)) : YC(n) && (n = XC(r = n, "width", void 0), s = XC(r, "height", void 0)), (o = c.call(this, t, e, i, n, s, r)).type = "rexTextBlock", o.textObject = void 0, o.linesCount = 0, o.textMask = void 0, o.textObjectType = void 0, o._textLineHeight = void 0, o._textLineSpacing = void 0, o._visibleLinesCount = void 0, o._textHeight = void 0, o._textVisibleHeight = void 0, o.lines = void 0, o.text = XC(r, "content", ""), o._textOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setClampMode(XC(r, "clamplTextOY", !0)), o.alwaysScrollable = XC(r, "alwaysScrollable", !1); var a = XC(r, "background", void 0),
                    h = XC(r, "text", void 0);
                void 0 === h && (h = VC(t)), o.textCropEnable = XC(r, "textCrop", !!h.setCrop); var l = XC(r, "textMask", !o.textCropEnable);
                a && o.addBackground(a), o.add(h), o.sizerChildren = [h]; var u = o.getSizerConfig(h); return u.align = WC, u.padding = rd(0), u.expand = !0, o.textObject = h, o.textObjectType = tx(h), u.preOffsetY = 0, u.offsetY = 0, l && (o.textMask = Fy.call(W(o), o.textObject, W(o))), o.addChildrenMap("background", a), o.addChildrenMap("text", h), o } return k(d, [{ key: "destroy", value: function(t) { if (this.scene) { if (this.textObject = void 0, this.textMask = void 0, this.lines) { switch (this.textObjectType) {
                                case 0:
                                    this.lines.length = 0; break;
                                case 1:
                                    this.lines.destroy(); break;
                                case 2:
                                    this.lines.length = 0 }
                            this.lines = void 0 }
                        O(C(d.prototype), "destroy", this).call(this, t) } } }, { key: "setClampMode", value: function(t) { return void 0 === t && (t = !0), this.clampTextOY = t, this } }, { key: "textLineHeight", get: function() { if (void 0 === this._textLineHeight) { var t; switch (this.textObjectType) {
                            case 0:
                            case 1:
                                var e = this.textObject.style;
                                t = e.metrics.fontSize + e.strokeThickness; break;
                            case 2:
                                var i = this.textObject.fontSize / this.textObject.fontData.size;
                                t = this.textObject.fontData.lineHeight * i }
                        this._textLineHeight = t } return this._textLineHeight } }, { key: "textLineSpacing", get: function() { if (void 0 === this._textLineSpacing) { var t; switch (this.textObjectType) {
                            case 0:
                            case 1:
                                t = this.textObject.lineSpacing; break;
                            case 2:
                                t = 0 }
                        this._textLineSpacing = t } return this._textLineSpacing } }, { key: "visibleLinesCount", get: function() { return void 0 === this._visibleLinesCount && (this._visibleLinesCount = Math.floor(AC.call(this, this._textObjectRealHeight))), this._visibleLinesCount } }, { key: "topTextOY", get: function() { return 0 } }, { key: "bottomTextOY", get: function() { return -this.textVisibleHeight } }, { key: "textHeight", get: function() { return void 0 === this._textHeight && (this._textHeight = jC.call(this, this.linesCount)), this._textHeight } }, { key: "textObjectHeight", get: function() { return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing) } }, { key: "textVisibleHeight", get: function() { if (void 0 === this._textVisibleHeight) { var t = this.textHeight - this.textObjectHeight;!this.alwaysScrollable && t < 0 && (t = 0), this._textVisibleHeight = t } return this._textVisibleHeight } }, { key: "textOYExceedTop", value: function(t) { return void 0 === t && (t = this.textOY), t > this.topTextOY } }, { key: "textOYExeceedBottom", value: function(t) { return void 0 === t && (t = this.textOY), t < this.bottomTextOY } }, { key: "textOY", get: function() { return this._textOY }, set: function(t) { var e = this.topTextOY,
                        i = this.bottomTextOY,
                        n = this.textOYExceedTop(t),
                        s = this.textOYExeceedBottom(t);
                    this.clampTextOY && (this.visibleLinesCount > this.linesCount ? t = 0 : n ? t = e : s && (t = i)), this._textOY !== t && (this._textOY = t, this.updateTextObject()), n && (this.execeedTopState || this.emit("execeedtop", this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit("execeedbottom", this, t, i)), this.execeedBottomState = s } }, { key: "setTextOY", value: function(t) { return this.textOY = t, this } }, { key: "t", get: function() { var t = this.textVisibleHeight; return 0 === t ? 0 : this.textOY / -t }, set: function(t) { this.textOY = -this.textVisibleHeight * t } }, { key: "setTextOYByPercentage", value: function(t) { return this.t = t, this } }]), d }(),
        VC = function(t) { return t.add.text(0, 0, "") };
    Object.assign(GC.prototype, FC); var UC = Phaser.Utils.Objects.GetValue,
        HC = function() { w(v, Vk); var p = T(v);

            function v(t, e) { var i;
                X(this, v), void 0 === e && (e = {}); var n = UC(e, "text", void 0),
                    s = UC(e, "textWidth", void 0),
                    r = UC(e, "textHeight", void 0),
                    o = UC(e, "textCrop", !!n.setCrop),
                    a = UC(e, "textMask", !o),
                    h = UC(e, "content", ""),
                    l = new GC(t, { width: s, height: r, text: n, textMask: a, textCrop: o && !a, content: h, clamplTextOY: UC(e, "clamplChildOY", !1), alwaysScrollable: UC(e, "alwaysScrollable", !1) });
                t.add.existing(l); var u, c = void 0 === s ? 1 : 0,
                    d = void 0 === r;
                u = l, Object.defineProperty(u, "childOY", { configurable: !0, get: function() { return u.textOY }, set: function(t) { u.textOY = t } }), Object.defineProperty(u, "topChildOY", { get: function() { return u.topTextOY } }), Object.defineProperty(u, "bottomChildOY", { get: function() { return u.bottomTextOY } }), Object.defineProperty(u, "childVisibleHeight", { get: function() { return u.textObjectHeight } }), Object.defineProperty(u, "childHeight", { get: function() { return u.textHeight } }), e.scrollMode = 0, e.type = "rexTextArea", e.child = { gameObject: l, proportion: c, expand: d }; var f = UC(e, "space", void 0); return f && (f.child = f.text), (i = p.call(this, t, e)).addChildrenMap("text", n), i } return k(v, [{ key: "text", get: function() { return this.childrenMap.child.text } }, { key: "linesCount", get: function() { return this.childrenMap.child.linesCount } }, { key: "contentHeight", get: function() { return this.childrenMap.child.textHeight } }]), v }(),
        NC = { setText: function(t) { return this.childrenMap.child.setText(t), this.resizeController(), this }, appendText: function(t) { return this.setText(this.text + t), this } };
    Object.assign(HC.prototype, NC), p.register("textArea", function(t) { var e = new HC(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.TextArea", HC); var JC = { getChildrenWidth: function() { if (this.rexSizer.hidden) return 0; var t = this.child; return !t.rexSizer.hidden && 0 === this.scrollMode ? this.getChildWidth(t) : 0 }, getChildrenHeight: function() { if (this.rexSizer.hidden) return 0; var t = this.child; return t.rexSizer.hidden || 0 === this.scrollMode ? 0 : t.isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : t.hasOwnProperty("minHeight") ? t.minHeight : qs(t) }, getChildrenSizers: function(t) { return void 0 === t && (t = []), this.child && this.child.isRexSizer && t.push(this.child), t }, resetChildPosition: function() { var t = this.left,
                e = this.top;
            0 === this.scrollMode ? e += this.childOY : t += this.childOY, this.child.setPosition(t, e), this.resetChildPositionState(this.child), this.setMaskChildrenFlag() }, layoutChildren: function() { var t, e, i = this.child;
            i.rexSizer.hidden || (0 === this.scrollMode ? t = this.width : e = this.height, i.isRexSizer ? i.runLayout(this, t, e) : Bd(i, t, e), this.resetChildPosition(), this.layoutChildrenMask(), this.maskChildren()) } };
    Object.assign(JC, lb); var KC = Phaser.Utils.Objects.IsPlainObject,
        ZC = Phaser.Utils.Objects.GetValue,
        qC = Phaser.Display.Align.TOP_LEFT,
        $C = function() { w(c, pv); var u = T(c);

            function c(t, e, i, n, s, r) { var o;
                X(this, c), KC(e) ? (e = ZC(r = e, "x", 0), i = ZC(r, "y", 0), n = ZC(r, "width", void 0), s = ZC(r, "height", void 0)) : KC(n) && (n = ZC(r = n, "width", void 0), s = ZC(r, "height", void 0)), (o = u.call(this, t, e, i, n, s, r)).type = "rexScrollableBlock", o.child = void 0, o.childrenMask = void 0, o._childOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setScrollMode(ZC(r, "scrollMode", !0)), o.setClampMode(ZC(r, "clamplChildOY", !0)); var a = ZC(r, "child", void 0),
                    h = ZC(r, "expand", !0);
                a.setOrigin && a.setOrigin(0), o.add(a), o.sizerChildren = [a]; var l = o.getSizerConfig(a); return l.align = qC, l.expand = h, o.child = a, o.setupChildrenMask(ZC(r, "mask", void 0)), o } return k(c, [{ key: "destroy", value: function(t) { this.scene && (this.destroyChildrenMask(), this.child = void 0, O(C(c.prototype), "destroy", this).call(this, t)) } }, { key: "setScrollMode", value: function(t) { return "string" == typeof t && (t = bk[t.toLowerCase()]), this.scrollMode = t, this } }, { key: "setClampMode", value: function(t) { return void 0 === t && (t = !0), this.clampChildOY = t, this } }, { key: "instHeight", get: function() { return 0 === this.scrollMode ? this.height : this.width } }, { key: "instWidth", get: function() { return 0 === this.scrollMode ? this.width : this.height } }, { key: "childHeight", get: function() { return (0 === this.scrollMode ? qs : Zs)(this.child) } }, { key: "childWidth", get: function() { return (0 === this.scrollMode ? Zs : qs)(this.child) } }, { key: "topChildOY", get: function() { return 0 } }, { key: "bottomChildOY", get: function() { return -this.visibleHeight } }, { key: "childVisibleHeight", get: function() { return this.instHeight } }, { key: "visibleHeight", get: function() { var t = this.childHeight - this.childVisibleHeight; return t < 0 && (t = 0), t } }, { key: "childOYExceedTop", value: function(t) { return void 0 === t && (t = this.childOY), t > this.topChildOY } }, { key: "childOYExeceedBottom", value: function(t) { return void 0 === t && (t = this.childOY), t < this.bottomChildOY } }, { key: "childOY", get: function() { return this._childOY }, set: function(t) { var e = this.topChildOY,
                        i = this.bottomChildOY,
                        n = this.childOYExceedTop(t),
                        s = this.childOYExeceedBottom(t);
                    this.clampChildOY && (this.childVisibleHeight > this.childHeight ? t = 0 : n ? t = e : s && (t = i)), this._childOY !== t && (this._childOY = t, this.resetChildPosition()), n && (this.execeedTopState || this.emit("execeedtop", this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit("execeedbottom", this, t, i)), this.execeedBottomState = s } }, { key: "setChildOY", value: function(t) { return this.childOY = t, this } }, { key: "t", get: function() { var t = this.visibleHeight; return 0 === t ? 0 : this.childOY / -t }, set: function(t) { this.childOY = -this.visibleHeight * t } }, { key: "setChildOYByPercentage", value: function(t) { return this.t = t, this } }]), c }();
    Object.assign($C.prototype, JC); var QC = Phaser.Utils.Objects.GetValue,
        tw = function() { w(d, Vk); var c = T(d);

            function d(t, e) { var i;
                X(this, d), void 0 === e && (e = {}); var n = kk(e),
                    s = QC(e, "panel", void 0);
                void 0 === s && (s = {}), s.scrollMode = n, s.clamplChildOY = QC(e, "clamplChildOY", !1); var r = new $C(t, s);
                t.add.existing(r); var o, a, h = QC(s, "width", void 0),
                    l = QC(s, "height", void 0);
                a = 0 === n ? (o = void 0 === h ? 1 : 0, void 0 === l) : (o = void 0 === l ? 1 : 0, void 0 === h), e.type = "rexScrollablePanel", e.child = { gameObject: r, proportion: o, expand: a }; var u = QC(e, "space", void 0); return u && (u.child = u.panel), (i = c.call(this, t, e)).addChildrenMap("panel", r.child), i.addChildrenMap("panelLayer", r.maskLayer), i } return k(d, [{ key: "setChildrenInteractive", value: function(t) { return void 0 === t && (t = {}), t.hasOwnProperty("eventEmitter") || (t.eventEmitter = this), t.hasOwnProperty("targets") || (t.targets = [this.childrenMap.panel]), sv(this.childrenMap.child, t), this } }]), d }();
    p.register("scrollablePanel", function(t) { var e = new tw(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.ScrollablePanel", tw);

    function ew(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = e.length), t.length = n - i; for (var s = 0, r = t.length; s < r; s++) t[s] = e[s + i]; return t }

    function iw(t, e, i) { var n, s = aw(i, "reverse", !1); if (Md(t[0]))
            if (s)
                for (r = (o = t.length) - 1; 0 <= r; r--) n = iw(t[r], e, i);
            else
                for (var r = 0, o = t.length; r < o; r++) n = iw(t[r], e, i);
        else n = hw(t, e, i); return n } var nw = function(t, e) { t.popUp(e) },
        sw = function(t, e) { t.scaleDown(e) },
        rw = function(t, e) { t.fadeIn(e) },
        ow = function(t, e) { t.fadeOut(e) },
        aw = Phaser.Utils.Objects.GetValue,
        hw = function(t, e, i) { var n, s = aw(i, "argsConvert", void 0),
                r = aw(i, "argsConvertScope", void 0),
                o = t[0]; if (lw = ew(lw, t, 1), s) {!0 === s && (s = Ah, r = void 0); for (var a = 0, h = lw.length; a < h; a++) lw[a] = r ? s.call(r, lw[a], t) : s(lw[a], t) } return "string" == typeof o ? null == (n = e[o]) && (n = aw(e, o, null)) : n = o, n.apply(e, lw) },
        lw = [],
        uw = Phaser.Utils.Objects.GetValue,
        cw = function() { w(r, ds); var s = T(r);

            function r(t, e) { var i;
                X(this, r), i = s.call(this, t, e); var n = uw(e, "clock", void 0); return n = n || new Ka(t), i.clock = n, i.clock.on("update", i.update, W(i)), i.resetFromJSON(e), i } return k(r, [{ key: "resetFromJSON", value: function(t) { return this.clock.resetFromJSON(uw(t, "clock", void 0)), this.state = uw(t, "state", 0), this.commands = uw(t, "commands", []), this.scope = uw(t, "scope", void 0), this.setTimeUnit(uw(t, "timeUnit", 0)), this.setDtMode(uw(t, "dtMode", 0)), this.index = uw(t, "index", 0), this.nextTime = uw(t, "nextTime", 0), this } }, { key: "toJSON", value: function() { return { clock: this.clock.toJSON(), state: this.state, commands: this.commands, scope: this.scope, timeUnit: this.timeUnit, dtMode: this.dtMode, index: this.index, nextTime: this.nextTime } } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.clock.shutdown(t), this.commands = void 0, O(C(r.prototype), "shutdown", this).call(this, t)) } }, { key: "load", value: function(t, e, i) { this.stop(); var n = uw(i, "timeUnit", void 0);
                    void 0 !== n && this.setTimeUnit(n); var s = uw(i, "dtMode", void 0); return void 0 !== s && this.setDtMode(s), t = t.filter(function(t) { var e = t[0]; return !isNaN(e) }).map(function(t) { return "string" == typeof t[0] && (t[0] = parseFloat(t[0])), t }), 0 === this.dtMode && t.sort(function(t, e) { var i = t[0],
                            n = e[0]; return n < i ? 1 : i < n ? -1 : 0 }), this.commands = t, this.scope = e, this } }, { key: "start", value: function(t) { return void 0 === t && (t = 0), this.stop(), this.index = 0, this.state = 1, this.nextTime = this.getNextDt(0), this.clock.start(t), this.update(t), this.emit("start", this.parent, this), this } }, { key: "pause", value: function() { return this.clock.pause(), this.emit("pause", this.parent, this), this } }, { key: "resume", value: function() { return this.clock.resume(), this.emit("resume", this.parent, this), this } }, { key: "stop", value: function() { return this.clock.stop(), this.state = 0, this.emit("stop", this.parent, this), this } }, { key: "seek", value: function(t) { return this.clock.seek(t), this } }, { key: "seekToNext", value: function() { return this.seek(this.nextTime), this } }, { key: "isPlaying", get: function() { return this.clock.isRunning } }, { key: "completed", get: function() { return 2 === this.state } }, { key: "timeScale", get: function() { return this.clock.timeScale }, set: function(t) { this.clock.timeScale = t } }, { key: "setTimeScale", value: function(t) { return this.timeScale = t, this } }, { key: "now", get: function() { return this.clock.now } }, { key: "update", value: function(t) { if (this.nextTime > t) return this; for (var e = this.commands.length - 1;;) { var i = this.commands[this.index],
                            n = i[1]; if (Md(n) || (n = ew(dw, i, 1)), iw(n, this.scope), this.emit("runcommand", n, this.scope), this.index === e) return this.complete(), this; if (this.index++, this.nextTime = this.getNextDt(this.nextTime), this.nextTime > t) return this } } }, { key: "complete", value: function() { this.clock.stop(), this.state = 2, this.emit("complete", this.parent, this) } }, { key: "getNextDt", value: function(t) { var e = this.commands[this.index][0]; return 1 === this.timeUnit && (e *= 1e3), 1 === this.dtMode && (e += t), e } }, { key: "setDtMode", value: function(t) { return "string" == typeof t && (t = pw[t]), this.dtMode = t, this } }, { key: "setTimeUnit", value: function(t) { return "string" == typeof t && (t = fw[t]), this.timeUnit = t, this } }]), r }(),
        dw = [],
        fw = { ms: 0, s: 1, sec: 1 },
        pw = { abs: 0, absolute: 0, inc: 1, increment: 1 },
        vw = Phaser.Utils.Objects.GetValue,
        gw = function() { w(s, Xy); var n = T(s);

            function s(t, e) { var i; return X(this, s), void 0 === e && (e = { text: createDefaultTextObject(t) }), (i = n.call(this, t, e)).type = "rexToast", i.setTransitInTime(vw(e, "duration.in", 200)), i.setDisplayTime(vw(e, "duration.hold", 1200)), i.setTransitOutTime(vw(e, "duration.out", 200)), i.setTransitInCallback(vw(e, "transitIn", yw.popUp)), i.setTransitOutCallback(vw(e, "transitOut", yw.scaleDown)), i.player = new cw(W(i), { dtMode: 1 }), i.messages = [], i.scaleX0 = void 0, i.scaleY0 = void 0, i.setVisible(!1), i } return k(s, [{ key: "destroy", value: function(t) { this.scene && (this.player.destroy(), this.player = void 0, this.messages = void 0, O(C(s.prototype), "destroy", this).call(this, t)) } }, { key: "setDisplayTime", value: function(t) { return this.displayTime = t, this } }, { key: "setTransitOutTime", value: function(t) { return this.transitOutTime = t, this } }, { key: "setTransitInTime", value: function(t) { return this.transitInTime = t, this } }, { key: "setTransitInCallback", value: function(t) { switch ("string" == typeof t && (t = yw[t]), t) {
                        case yw.popUp:
                            t = nw; break;
                        case yw.fadeIn:
                            t = rw } return t = t || _, this.transitInCallback = t, this } }, { key: "setTransitOutCallback", value: function(t) { switch ("string" == typeof t && (t = yw[t]), t) {
                        case yw.scaleDown:
                            t = sw; break;
                        case yw.fadeOut:
                            t = ow } return t = t || _, this.transitOutCallback = t, this } }, { key: "setScale", value: function(t, e) { return void 0 === e && (e = t), this.scaleX0 = t, this.scaleY0 = e, O(C(s.prototype), "setScale", this).call(this, t, e), this } }, { key: "showMessage", value: function(t) { if (void 0 === this.scaleX0 && (this.scaleX0 = this.scaleX), void 0 === this.scaleY0 && (this.scaleY0 = this.scaleY), void 0 === t) { if (0 === this.messages.length) return this;
                        t = this.messages.shift() } if (this.player.isPlaying) return this.messages.push(t), this;
                    this.setScale(this.scaleX0, this.scaleY0).setVisible(!0), "string" == typeof t ? this.setText(t) : t(this), this.layout(); var e = [
                        [0, [this.transitInCallback, this, this.transitInTime]],
                        [this.transitInTime, [_]],
                        [this.displayTime, [this.transitOutCallback, this, this.transitOutTime]],
                        [this.transitOutTime, [this.setVisible, !1]],
                        [30, [_]]
                    ]; return this.player.load(e, this).once("complete", function() { this.showMessage() }, this).start(), this } }]), s }(),
        yw = { popUp: 0, fadeIn: 1, scaleDown: 0, fadeOut: 1 };
    p.register("toast", function(t) { var e = new gw(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Toast", gw);

    function mw(s, r) { return function(t, e, i, n) { "panel" !== e && i.moveChild(t, n ? 0 : s, r) } }

    function kw(s, r) { return function(t, e, i, n) { "panel" === e && i.moveChild(t, n ? 0 : s, r) } } var bw = { visible: { show: function() { return function(t, e, i, n) { "panel" !== e && i.setChildVisible(t, !0) } }, hide: function() { return function(t, e, i, n) { "panel" !== e && i.setChildVisible(t, !1) } } }, fade: { show: function(s, r) { return void 0 === r && (r = 1),
                        function(t, e, i, n) { "panel" !== e && i.fadeChild(t, n ? 0 : s, r) } }, hide: function(s, r) { return void 0 === r && (r = 0),
                        function(t, e, i, n) { "panel" !== e && i.fadeChild(t, n ? 0 : s, r) } } }, move: { show: mw, hide: mw }, "move-panel": { show: kw, hide: kw } },
        xw = Kr.prototype.setChildVisible,
        Cw = { setChildVisible: function(t, e) { if ("string" == typeof t) { var i = t;
                    t = this.sizerChildren[i] } else i = Mv(this.sizerChildren, t); return void 0 === e && (e = this.currentChildKey === i), xw.call(this, t, e), this } },
        ww = { fadeChild: function(t, e, i) { var n; return "string" == typeof t ? (n = t, t = this.sizerChildren[n]) : n = Mv(this.sizerChildren, t), void 0 === e && (e = 500), void 0 === i && (i = this.currentChildKey === n ? 1 : 0), t.fadeIn(e, { start: t.alpha, end: i }), this }, fadeChildPromise: function(t, e, i) { return "string" == typeof t && (t = this.sizerChildren[key]), this.fadeChild(t, e, i), t._fade ? nl(t._fade) : Promise.resolve() } },
        Sw = { moveChild: function(t, e, i, n) { var s; "string" == typeof t ? (s = t, t = this.sizerChildren[s]) : s = Mv(this.sizerChildren, t), void 0 === e && (e = 500); var r, o, a, h, l = this.currentChildKey === s; if (void 0 === n) switch (s) {
                    case "leftSide":
                    case "rightSide":
                        n = Zs(t); break;
                    case "topSide":
                    case "bottomSide":
                        n = qs(t); break;
                    default:
                        if (l) switch (this.previousChildKey) {
                            case "leftSide":
                            case "rightSide":
                                n = Zs(this.sizerChildren[this.previousChildKey]); break;
                            case "topSide":
                            case "bottomSide":
                                n = qs(this.sizerChildren[this.previousChildKey]); break;
                            default:
                                n = 0 } else switch (this.currentChildKey) {
                            case "leftSide":
                            case "rightSide":
                                n = Zs(this.sizerChildren[this.currentChildKey]); break;
                            case "topSide":
                            case "bottomSide":
                                n = qs(this.sizerChildren[this.currentChildKey]); break;
                            default:
                                n = 0 } }
                if (l) switch (s) {
                    case "panel":
                        switch (this.previousChildKey) {
                            case "leftSide":
                                r = !0; break;
                            case "rightSide":
                                o = !0; break;
                            case "topSide":
                                a = !0; break;
                            case "bottomSide":
                                h = !0 } break;
                    case "leftSide":
                        o = !0; break;
                    case "rightSide":
                        r = !0; break;
                    case "topSide":
                        h = !0; break;
                    case "bottomSide":
                        a = !0 } else switch (s) {
                    case "panel":
                        switch (this.currentChildKey) {
                            case "leftSide":
                                o = !0; break;
                            case "rightSide":
                                r = !0; break;
                            case "topSide":
                                h = !0; break;
                            case "bottomSide":
                                a = !0 } break;
                    case "leftSide":
                        r = !0; break;
                    case "rightSide":
                        o = !0; break;
                    case "topSide":
                        a = !0; break;
                    case "bottomSide":
                        h = !0 }
                return r ? t.moveTo(e, "-=".concat(n), void 0, i) : o ? t.moveTo(e, "+=".concat(n), void 0, i) : a ? t.moveTo(e, void 0, "-=".concat(n), i) : h ? t.moveTo(e, void 0, "+=".concat(n), i) : t.moveTo(0), this }, moveChildPromise: function(t, e, i, n) { return "string" == typeof t && (t = this.sizerChildren[key]), this.moveChild(t, e, i, n), t._easeMove ? nl(t._easeMove) : Promise.resolve() } },
        Pw = {};
    Object.assign(Pw, Cw, ww, Sw); var Tw = Phaser.Utils.Objects.GetValue,
        Ow = function() { w(C, Rv); var x = T(C);

            function C(t, e) { var i;
                X(this, C), (i = x.call(this, t, e)).type = "rexSides", i.childrenMap = i.sizerChildren, i.previousChildKey = void 0, i.currentChildKey = void 0; var n, s, r, o, a, h, l = Tw(e, "showChildCallback", void 0); if (l)
                    if (Od(l)) { var u = Tw(e, "showChildCallbackScope", void 0);
                        i.on("showchild", l, u); var c = Tw(e, "hideChildCallback", void 0),
                            d = Tw(e, "hideChildCallbackScope", void 0);
                        i.on("hidechild", c, d) } else { var f = (h = S("string" == typeof(n = l) ? [n] : n), s = h[0], r = h.slice(1), a = bw.hasOwnProperty(s) ? (o = bw[s].show.apply(null, r), bw[s].hide.apply(null, r)) : o = _, { show: o, hide: a });
                        i.on("showchild", f.show), i.on("hidechild", f.hide) }
                var p = Tw(e, "background", void 0),
                    v = Tw(e, "panel", void 0),
                    g = Tw(e, "leftSide", void 0),
                    y = Tw(e, "rightSide", void 0),
                    m = Tw(e, "topSide", void 0),
                    k = Tw(e, "bottomSide", void 0); if (p && i.addBackground(p), v && i.add(v, "panel", "center", 0, !0), g) { var b = Tw(e, "expand.left", !0);
                    i.add(g, "leftSide", "left-top", 0, { height: b }) } if (y) { b = Tw(e, "expand.right", !0);
                    i.add(y, "rightSide", "right-top", 0, { height: b }) } if (m) { b = Tw(e, "expand.top", !0);
                    i.add(m, "topSide", "left-top", 0, { width: b }) } if (k) { b = Tw(e, "expand.bottom", !0);
                    i.add(k, "bottomSide", "left-bottom", 0, { width: b }) } return i } return k(C, [{ key: "reset", value: function() { return this.previousChildKey = void 0, this.currentChildKey = "panel", this.showChild("panel", !0), this.hideChild("leftSide", !0), this.hideChild("rightSide", !0), this.hideChild("topSide", !0), this.hideChild("bottomSide", !0), this } }]), C }();
    Object.assign(Ow.prototype, { showChild: function(t, e) { var i = this.sizerChildren[t]; return i && (this.emit("showchild", i, t, this, e), this.resetChildState(i)), this }, hideChild: function(t, e) { var i = this.sizerChildren[t]; return i && (this.emit("hidechild", i, t, this, e), this.resetChildState(i)), this }, swapChild: function(t, e) { return this.currentChildKey === t || ("panel" === this.currentChildKey || "panel" === t ? (this.previousChildKey = this.currentChildKey, this.currentChildKey = t, this.hideChild(this.previousChildKey, e), this.showChild(this.currentChildKey, e)) : (this.swapChild("panel", e), this.swapChild(t, e))), this }, showPanel: function(t) { return this.swapChild("panel", t), this }, showLeftSide: function() { return this.swapChild("leftSide"), this }, showRightSide: function() { return this.swapChild("rightSide"), this }, showTopSide: function() { return this.swapChild("topSide"), this }, showBottomSide: function() { return this.swapChild("bottomSide"), this }, hideLeftSide: function() { return "leftSide" == this.currentChildKey && this.showPanel(), this }, hideRightSide: function() { return "rightSide" == this.currentChildKey && this.showPanel(), this }, hideTopSide: function() { return "topSide" == this.currentChildKey && this.showPanel(), this }, hideBottomSide: function() { return "bottomSide" == this.currentChildKey && this.showPanel(), this }, toggleLeftSide: function() { var t = "panel" !== this.currentChildKey ? "panel" : "leftSide"; return this.swapChild(t), this }, toggleRightSide: function() { var t = "panel" !== this.currentChildKey ? "panel" : "rightSide"; return this.swapChild(t), this }, toggleTopSide: function() { var t = "panel" !== this.currentChildKey ? "panel" : "topSide"; return this.swapChild(t), this }, toggleBottomSide: function() { var t = "panel" !== this.currentChildKey ? "panel" : "bottomSide"; return this.swapChild(t), this } }, Pw), p.register("sides", function(t) { var e = new Ow(this.scene, t); return this.scene.add.existing(e), e }), j(window, "RexPlugins.UI.Sides", Ow), p.register("click", function(t, e) { return new If(t, e) }), j(window, "RexPlugins.UI.Click", If), p.register("clickOutside", function(t, e) { return new Df(t, e) }), j(window, "RexPlugins.UI.ClickOutside", Df), p.register("inTouching", function(t, e) { return new Uf(t, e) }), j(window, "RexPlugins.UI.InTouching", Uf);

    function Mw(t) { return t instanceof Ew } var Ew = Phaser.GameObjects.GameObject;
    p.register("tap", function(t, e) { return Mw(t) || (e = t, t = this.scene), new hp(t, e) }), j(window, "RexPlugins.UI.Tap", hp), p.register("press", function(t, e) { return Mw(t) || (e = t, t = this.scene), new fp(t, e) }), j(window, "RexPlugins.UI.Press", fp), p.register("swipe", function(t, e) { return Mw(t) || (e = t, t = this.scene), new Ep(t, e) }), j(window, "RexPlugins.UI.Swipe", Ep), p.register("pan", function(t, e) { return Mw(t) || (e = t, t = this.scene), new mp(t, e) }), j(window, "RexPlugins.UI.Pan", mp);

    function _w(t) { for (var e, i = t.scene.input, n = i.manager, s = n.pointersTotal, r = n.pointers, o = 0; o < s; o++)
            if ((e = r[o]).primaryDown && 0 === i.getDragState(e) && ps(t, e)) return i.setDragState(e, 1), i._drag[e.id] = [t], 0 === i.dragDistanceThreshold || 0 === i.dragTimeThreshold ? (i.setDragState(e, 3), i.processDragStartList(e)) : i.setDragState(e, 2), !0;
        return !1 } var Rw = Phaser.Utils.Objects.GetValue,
        Bw = Phaser.Math.Distance.Between,
        Iw = Phaser.Math.RotateAroundDistance,
        Lw = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, { eventEmitter: !1 }))._enable = void 0, t.setInteractive(Rw(e, "inputConfig", void 0)), i.resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return this.pointer = void 0, this.setEnable(Rw(t, "enable", !0)), this.setAxisMode(Rw(t, "axis", 0)), this.setAxisRotation(Rw(t, "rotation", 0)), this } }, { key: "toJSON", value: function() { return { enable: this.enable, axis: this.axisMode, rotation: this.axisRotation } } }, { key: "boot", value: function() { var t = this.parent;
                    t.on("dragstart", this.onDragStart, this), t.on("drag", this.onDrag, this), t.on("dragend", this.onDragEnd, this) } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.pointer = void 0, O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "enable", get: function() { return this._enable }, set: function(t) { if (this._enable !== t) return t || this.dragend(), this._enable = t, this.scene.input.setDraggable(this.parent, t), this } }, { key: "setEnable", value: function(t) { return void 0 === t && (t = !0), this.enable = t, this } }, { key: "toggleEnable", value: function() { return this.setEnable(!this.enable), this } }, { key: "setAxisMode", value: function(t) { return "string" == typeof t && (t = Aw[t]), this.axisMode = t, this } }, { key: "setAxisRotation", value: function(t) { return this.axisRotation = t, this } }, { key: "drag", value: function() { return _w(this.parent), this } }, { key: "dragend", value: function() { if (this.isDragging) return this.scene.input.setDragState(this.pointer, 5), this } }, { key: "onDragStart", value: function(t) { this.isDragging || (this.pointer = t) } }, { key: "onDrag", value: function(t, e, i) { if (this.pointer === t) { var n = this.parent; if (0 === this.axisMode) n.x = e, n.y = i;
                        else if (0 === this.axisRotation) 1 === this.axisMode ? n.x = e : 2 === this.axisMode && (n.y = i);
                        else { var s, r = { x: e, y: i };
                            s = Bw(r.x, r.y, n.x, n.y), r = Iw(r, n.x, n.y, -this.axisRotation, s), 1 === this.axisMode ? r.y = n.y : 2 === this.axisMode && (r.x = n.x), s = Bw(r.x, r.y, n.x, n.y), r = Iw(r, n.x, n.y, this.axisRotation, s), n.x = r.x, n.y = r.y } } } }, { key: "onDragEnd", value: function(t) { this.pointer === t && (this.pointer = void 0) } }, { key: "isDragging", get: function() { return void 0 !== this.pointer } }]), s }(),
        Aw = { both: 0, "h&v": 0, "x&y": 0, horizontal: 1, h: 1, x: 1, vertical: 2, v: 2, y: 2 };
    p.register("drag", function(t, e) { return new Lw(t, e) }), j(window, "RexPlugins.UI.Drag", Lw), p.register("pinch", function(t) { return new Up(this.scene, t) }), j(window, "RexPlugins.UI.Pinch", Up), p.register("rotate", function(t) { return new iv(this.scene, t) }), j(window, "RexPlugins.UI.Rotate", iv);

    function jw(e, i, t) { var n; if (void 0 === e) e = t.texture.key, i = t.frame.name;
        else if (Dw(e)) { var s = e;
            e = zw(s, "key", t.texture.key), i = zw(s, "frame", t.frame.name) } else "string" == typeof e || (n = e); return void 0 === n && (n = function(t) { t.setTexture(e, i) }), n } var Dw = Phaser.Utils.Objects.IsPlainObject,
        zw = Phaser.Utils.Objects.GetValue,
        Fw = Phaser.Utils.Objects.GetValue,
        Yw = Phaser.Utils.Objects.GetAdvancedValue,
        Xw = Phaser.Math.Linear,
        Ww = function() { w(s, za); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).resetFromJSON(e), i.boot(), i } return k(s, [{ key: "resetFromJSON", value: function(t) { return O(C(s.prototype), "resetFromJSON", this).call(this, t), this.setDuration(Yw(t, "duration", 500)), this.setEase(Fw(t, "ease", "Sine")), this.setOrientation(Fw(t, "orientation", 0)), this.setFrontFace(Fw(t, "front", void 0)), this.setBackFace(Fw(t, "back", void 0)), this.setFace(Fw(t, "face", 0)), this } }, { key: "setOrientation", value: function(t) { return "string" == typeof t && (t = Gw[t]), this.orientation = t, this } }, { key: "face", get: function() { return this._face }, set: function(t) { "string" == typeof t && (t = Vw[t]), 0 === (this._face = t) && this.frontFaceCallback ? this.frontFaceCallback(this.parent) : 1 === t && this.backFaceCallback && this.backFaceCallback(this.parent) } }, { key: "setFace", value: function(t) { return this.face = t, this } }, { key: "toggleFace", value: function() { var t = 0 === this.face ? 1 : 0; return this.setFace(t), this } }, { key: "setFrontFace", value: function(t, e) { return this.frontFaceCallback = jw(t, e, this.parent), this } }, { key: "setBackFace", value: function(t, e) { return this.backFaceCallback = jw(t, e, this.parent), this } }, { key: "start", value: function() { if (this.timer.isRunning) return this; var t = this.parent; return 0 === this.orientation ? this.scale0 = t.scaleX : this.scale0 = t.scaleY, this.timer.setDelay(this.delay).setDuration(this.duration / 2).setRepeat(1), O(C(s.prototype), "start", this).call(this), this } }, { key: "flip", value: function(t) { return this.isRunning || (void 0 !== t && this.setDuration(t), this.start()), this } }, { key: "updateGameObject", value: function(t, e) { e.justRestart && this.toggleFace(); var i = e.t;
                    e.isOddIteration && (i = 1 - i), i = this.easeFn(i); var n = Xw(this.scale0, 0, i);
                    0 === this.orientation ? t.scaleX = n : t.scaleY = n } }]), s }(),
        Gw = { x: 0, horizontal: 0, y: 1, vertical: 1 },
        Vw = { front: 0, back: 1 };
    p.register("flip", function(t, e) { return new Ww(t, e) }), j(window, "RexPlugins.UI.Flip", Ww), p.register("shake", function(t, e) { return new yf(t, e) }), j(window, "RexPlugins.UI.Shake", yf), p.register("touchEventStop", function(t, e) { return new Dg(t, e) }), j(window, "RexPlugins.UI.TouchEventStop", Dg), p.register("perspective", function(t, e) { return new bC(t, e) }), j(window, "RexPlugins.UI.Perspective", bC);

    function Uw(t, e, i) { var n = t.width / 2,
            s = t.height / 2; return Nw.x = e - n, Nw.y = i - s, Hw(Nw, 0, 0, t.rotation), Nw.x *= t.scaleX, Nw.y *= t.scaleY, Nw.x += t.x, Nw.y += t.y, Nw } var Hw = Phaser.Math.RotateAround,
        Nw = { x: 0, y: 0 },
        Jw = function() {
            function i(t, e) { X(this, i), this.parent = t, this.vertex = e, this._localX = void 0, this._localY = void 0 } return k(i, [{ key: "destroy", value: function() { this.parent = void 0, this.vertex = void 0 } }, { key: "updateVertexPosition", value: function(t, e) { var i = this.parent,
                        n = i.height,
                        s = t / n - i.frame.cutWidth / n / 2,
                        r = e / n - i.frame.cutHeight / n / 2,
                        o = this.vertex; return o.x = s, o.y = -r, i.forceUpdate(), this } }, { key: "localX", get: function() { return this._localX }, set: function(t) { this.setLocalXY(t, this._localY) } }, { key: "localY", get: function() { return this._localY }, set: function(t) { this.setLocalXY(this._localX, t) } }, { key: "localXOrigin", get: function() { return this._localXOrigin } }, { key: "localYOrigin", get: function() { return this._localYOrigin } }, { key: "resetLocalXY", value: function(t, e) { return this._localXOrigin = t, this._localYOrigin = e, this._localX = t, this._localY = e, this } }, { key: "setLocalXY", value: function(t, e, i) { return this._localX === t && this._localY === e || (this._localX = t, this._localY = e, i || this.updateVertexPosition(t, e)), this } }, { key: "setWorldXY", value: function(t, e) { if (this._worldX === t && this._worldY === e) return this; var i, n, s, r, o, a = (i = this.parent, n = t, s = e, r = i.width / 2, o = i.height / 2, Nw.x = n - i.x, Nw.y = s - i.y, Nw.x /= i.scaleX, Nw.y /= i.scaleY, Hw(Nw, 0, 0, -i.rotation), Nw.x += r, Nw.y += o, Nw); return this.setLocalXY(a.x, a.y), this } }, { key: "setPosition", value: function(t, e) { return this.setWorldXY(t, e), this } }, { key: "getWorldXY", value: function() { return Uw(this.parent, this._localX, this._localY) } }, { key: "x", get: function() { return Uw(this.parent, this._localX, this._localY).x }, set: function(t) { this.setWorldXY(t, this.y) } }, { key: "y", get: function() { return Uw(this.parent, this._localX, this._localY).y }, set: function(t) { this.setWorldXY(this.x, t) } }]), i }(),
        Kw = Phaser.Geom.Mesh.Vertex,
        Zw = Phaser.Geom.Mesh.Face,
        qw = [0, 2, 3, 0, 3, 1],
        $w = [0, 3, 4, 0, 4, 1, 1, 4, 2, 4, 5, 2, 3, 6, 4, 6, 7, 4, 4, 7, 8, 4, 8, 5],
        Qw = Phaser.GameObjects.Mesh,
        tS = Phaser.Utils.Objects.IsPlainObject,
        eS = Phaser.Utils.Objects.GetValue,
        iS = function() { w(h, Qw); var a = T(h);

            function h(t, e, i, n, s, r) { var o; return X(this, h), tS(e) && (e = eS(r = e, "x", 0), i = eS(r, "y", 0), n = eS(r, "key", null), s = eS(r, "frame", null)), (o = a.call(this, t, e, i, n, s)).type = "rexQuadImage", o.isNinePointMode = eS(r, "ninePointMode", !1), o.controlPoints = [],
                    function(t) { for (var e = t.isNinePointMode, i = e ? 9 : 4, n = t.vertices, s = t.faces, r = t.controlPoints, o = 0; o < i; o++) { var a = new Kw();
                            n.push(a), r.push(new Jw(t, a)) } for (var h = e ? $w : qw, l = (o = 0, h.length); o < l; o += 3) { var u = n[h[o + 0]],
                                c = n[h[o + 1]],
                                d = n[h[o + 2]];
                            s.push(new Zw(u, c, d)) }
                        e ? (t.topLeft = r[0], t.topCenter = r[1], t.topRight = r[2], t.centerLeft = r[3], t.center = r[4], t.centerRight = r[5], t.bottomLeft = r[6], t.bottomCenter = r[7], t.bottomRight = r[8]) : (t.topLeft = r[0], t.topRight = r[1], t.bottomLeft = r[2], t.bottomRight = r[3]) }(W(o)), o.hideCCW = !1, o.syncSize(), o } return k(h, [{ key: "preDestroy", value: function() { for (var t = 0, e = this.controlPoints.length; t < e; t++) this.controlPoints[t].destroy();
                    this.controlPoints = void 0, O(C(h.prototype), "preDestroy", this).call(this) } }, { key: "resetVerts", value: function() { this.dirtyCache[9] = -1; for (var t = function(t) { var e, i = t.height,
                                n = t.width; if (t.isNinePointMode) { var s = (0 + n) / 2,
                                    r = (0 + i) / 2;
                                e = [0, 0, s, 0, n, 0, 0, r, s, r, n, r, 0, i, s, i, n, i] } else e = [0, 0, n, 0, 0, i, n, i]; return e }(this), e = this.width, i = this.height, n = this.frame.cutWidth / i / 2, s = this.frame.cutHeight / i / 2, r = this.frame.source.isRenderTexture, o = this.frame.u0, a = this.frame.u1, h = r ? this.frame.v1 : this.frame.v0, l = a - o, u = (r ? this.frame.v0 : this.frame.v1) - h, c = this.controlPoints, d = 0, f = t.length; d < f; d += 2) { var p = t[d + 0],
                            v = t[d + 1],
                            g = d / 2,
                            y = p / i - n,
                            m = v / i - s,
                            k = o + p / e * l,
                            b = h + v / i * u;
                        this.vertices[g].set(y, -m, 0).setUVs(k, b), c[g].resetLocalXY(p, v) } return this } }, { key: "syncSize", value: function() { return this.setSizeToFrame(), this.setOrtho(this.width / this.height, 1), this.resetVerts(), this } }, { key: "forceUpdate", value: function() { return this.dirtyCache[10] = 1, this } }, { key: "tint", get: function() { return 0 === this.vertices.length ? 16777215 : this.vertices[0].color }, set: function(t) { for (var e = this.vertices, i = 0, n = e.length; i < n; i++) e[i].color = t } }, { key: "setTint", value: function(t) { return this.tint = t, this } }]), h }();
    Phaser.GameObjects.RenderTexture, Phaser.Utils.Objects.IsPlainObject, Phaser.Utils.Objects.GetValue;

    function nS(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); for (var n = .5 * t.width, s = .5 * t.height, r = Math.tan(e) * s, o = Math.tan(i) * n, a = t.controlPoints, h = 0, l = a.length; h < l; h++) { var u = a[h],
                c = u.localXOrigin,
                d = u.localYOrigin;
            u.localX = c + (s < d ? r : -r), u.localY = d + (n < c ? o : -o) } } var sS = Phaser.Utils.Objects.IsPlainObject,
        rS = Phaser.Utils.Objects.GetValue,
        oS = Phaser.Math.DegToRad,
        aS = Phaser.Math.RadToDeg,
        hS = function() { w(h, iS); var a = T(h);

            function h(t, e, i, n, s) { var r; if (X(this, h), sS(e)) { var o = e;
                    e = rS(o, "x", 0), i = rS(o, "y", 0), n = rS(o, "key", null), s = rS(o, "frame", null) } return (r = a.call(this, t, e, i, n, s)).type = "rexSkewmage", r._skewX = 0, r._skewY = 0, r } return k(h, [{ key: "skewX", get: function() { return this._skewX }, set: function(t) { this._skewX = t, nS(this, this._skewX, this._skewY) } }, { key: "skewXDeg", get: function() { return aS(this._skewX) }, set: function(t) { this.skewX = oS(t) } }, { key: "skewY", get: function() { return this._skewY }, set: function(t) { this._skewY = t, nS(this, this._skewX, this._skewY) } }, { key: "skewYDeg", get: function() { return aS(this._skewY) }, set: function(t) { this.skewY = oS(t) } }, { key: "setSkewX", value: function(t) { return this.skewX = t, this } }, { key: "setSkewY", value: function(t) { return this.skewY = t, this } }, { key: "setSkew", value: function(t, e) { return void 0 === e && (e = t), this.skewX = t, this.skewY = e, this } }, { key: "setSkewXDeg", value: function(t) { return this.skewXDeg = t, this } }, { key: "setSkewYDeg", value: function(t) { return this.skewYDeg = t, this } }, { key: "setSkewDeg", value: function(t, e) { return void 0 === e && (e = t), this.skewXDeg = t, this.skewYDeg = e, this } }]), h }(),
        lS = Phaser.GameObjects.RenderTexture,
        uS = Phaser.Utils.Objects.IsPlainObject,
        cS = Phaser.Utils.Objects.GetValue,
        dS = function() { w(l, hS); var h = T(l);

            function l(t, e, i, n, s) { var r; if (X(this, l), uS(e)) { var o = e;
                    e = cS(o, "x", 0), i = cS(o, "y", 0), n = cS(o, "width", 32), s = cS(o, "height", 32) } var a = new lS(t, e, i, n, s).setOrigin(.5); return (r = h.call(this, t, e, i, a.texture.key, null)).type = "rexSkewRenderTexture", r.rt = a, r } return k(l, [{ key: "destroy", value: function(t) { O(C(l.prototype), "destroy", this).call(this, t), this.rt.destroy(), this.rt = null } }]), l }(),
        fS = function() { w(e, mC(dS)); var t = T(e);

            function e() { return X(this, e), t.apply(this, arguments) } return k(e, [{ key: "skewState", get: function() { return this.isRunning } }]), e }();
    p.register("skew", function(t, e) { return new fS(t, e) }), j(window, "RexPlugins.UI.Skew", fS), p.register("anchor", function(t, e) { return new Ud(t, e) }), j(window, "RexPlugins.UI.Anchor", Ud);

    function pS(i, t, n) {
        function e(e) { t.addEventListener(e, function(t) { i.emit(n[e], i, t) }) } for (var s in n) e(s) } var vS = void 0,
        gS = { id: ["id", void 0], text: ["value", void 0], maxLength: ["maxLength", void 0], minLength: ["minLength", void 0], placeholder: ["placeholder", void 0], tooltip: ["title", void 0], readOnly: ["readOnly", !1], spellCheck: ["spellcheck", !1], autoComplete: ["autocomplete", "off"] },
        yS = { align: ["textAlign", void 0], paddingLeft: ["padding-left", void 0], paddingRight: ["padding-right", void 0], paddingTop: ["padding-top", void 0], paddingBottom: ["padding-bottom", void 0], fontFamily: ["fontFamily", void 0], fontSize: ["font-size", void 0], color: ["color", "#ffffff"], backgroundColor: ["backgroundColor", "transparent"], border: ["border", 0], borderColor: ["borderColor", "transparent"], outline: ["outline", "none"], direction: ["direction", void 0] },
        mS = { input: "textchange", click: "click", dblclick: "dblclick", mousedown: "pointerdown", mousemove: "pointermove", mouseup: "pointerup", touchstart: "pointerdown", touchmove: "pointermove", touchend: "pointerup", keydown: "keydown", keyup: "keyup", keypress: "keypress", compositionstart: "compositionStart", compositionend: "compositionEnd", compositionupdate: "compositionUpdate", focus: "focus", blur: "blur", select: "select" },
        kS = Phaser.GameObjects.DOMElement,
        bS = Phaser.Utils.Objects.IsPlainObject,
        xS = Phaser.Utils.Objects.GetValue,
        CS = function() { w(f, kS); var d = T(f);

            function f(t, e, i, n, s, r) { var o, a;
                X(this, f), bS(e) ? (e = xS(r = e, "x", 0), i = xS(r, "y", 0), n = xS(r, "width", 0), s = xS(r, "height", 0)) : bS(n) && (n = xS(r = n, "width", 0), s = xS(r, "height", 0)), void 0 === r && (r = {}); var h = xS(r, "type", "text"); "textarea" === h ? (a = document.createElement("textarea")).style.resize = "none" : (a = document.createElement("input")).type = h, vs(gS, r, a); var l = xS(r, "style", void 0);
                l = vs(yS, r, l); var u = a.style; for (var c in r) c in gS || c in yS || c in u && (l[c] = r[c]); return l["box-sizing"] = "border-box", (o = d.call(this, t, e, i, a, l)).type = "rexInputText", o.resize(n, s), pS(W(o), a, mS), gs(a), xS(r, "selectAll", !1) && o.selectAll(), o._isFocused = !1, o.on("focus", function() { this._isFocused = !0 }, W(o)).on("blur", function() { this._isFocused = !1 }, W(o)), o } return k(f, [{ key: "text", get: function() { return this.node.value }, set: function(t) { this.node.value = t } }, { key: "setText", value: function(t) { return this.text = t, this } }, { key: "maxLength", get: function() { return this.node.maxLength }, set: function(t) { this.node.maxLength = t } }, { key: "setMaxLength", value: function(t) { return this.maxLength = t, this } }, { key: "minLength", get: function() { return this.node.minLength }, set: function(t) { this.node.minLength = t } }, { key: "setMinLength", value: function(t) { return this.minLength = t, this } }, { key: "placeholder", get: function() { return this.node.placeholder }, set: function(t) { this.node.placeholder = t } }, { key: "setPlaceholder", value: function(t) { return this.placeholder = t, this } }, { key: "selectText", value: function(t, e) { return void 0 === t ? this.node.select() : this.node.setSelectionRange(t, e), this } }, { key: "selectAll", value: function() { return this.selectText(), this } }, { key: "selectionStart", get: function() { return this.node.selectionStart } }, { key: "selectionEnd", get: function() { return this.node.selectionEnd } }, { key: "selectedText", get: function() { var t = this.node; return t.value.substring(t.selectionStart, t.selectionEnd) } }, { key: "cursorPosition", get: function() { return this.node.selectionStart }, set: function(t) { this.node.setSelectionRange(t, t) } }, { key: "setCursorPosition", value: function(t) { return void 0 === t ? t = this.text.length : t < 0 && (t = this.text.length + t), this.cursorPosition = t, this } }, { key: "tooltip", get: function() { return this.node.title }, set: function(t) { this.node.title = t } }, { key: "setTooltip", value: function(t) { return this.tooltip = t, this } }, { key: "setTextChangedCallback", value: function(t) { return this.onTextChanged = t, this } }, { key: "readOnly", get: function() { return this.node.readOnly }, set: function(t) { this.node.readOnly = t } }, { key: "setReadOnly", value: function(t) { return void 0 === t && (t = !0), this.readOnly = t, this } }, { key: "spellCheck", get: function() { return this.node.spellcheck }, set: function(t) { this.node.spellcheck = t } }, { key: "setSpellCheck", value: function(t) { return this.spellCheck = t, this } }, { key: "fontColor", get: function() { return this.node.style.color }, set: function(t) { this.node.style.color = t } }, { key: "setFontColor", value: function(t) { return this.fontColor = t, this } }, { key: "setStyle", value: function(t, e) { return this.node.style[t] = e, this } }, { key: "getStyle", value: function(t) { return this.node.style[t] } }, { key: "scrollToBottom", value: function() { return this.node.scrollTop = this.node.scrollHeight, this } }, { key: "setEnabled", value: function(t) { return void 0 === t && (t = !0), this.node.disabled = !t, this } }, { key: "setBlur", value: function() { return this.node.blur(), this } }, { key: "setFocus", value: function() { return this.node.focus(), this } }, { key: "isFocused", get: function() { return this._isFocused } }]), f }(),
        wS = { resize: function(t, e) { if (this.scene.sys.scale.autoRound && (t = Math.floor(t), e = Math.floor(e)), this.width === t && this.height === e) return this; var i = this.node.style; return i.width = "".concat(t, "px"), i.height = "".concat(e, "px"), this.updateSize(), this } };
    Object.assign(CS.prototype, wS); var SS = Phaser.Utils.Objects.GetValue,
        PS = function(t) { return t.hasOwnProperty("align") ? t.align : t.hasOwnProperty("halign") ? t.halign : "left" },
        TS = Phaser.Utils.Objects.GetValue,
        OS = Phaser.Utils.Objects.Merge,
        MS = { open: function(t, e) { var i;
                void 0 === t && (t = {}), OS(t, this.openConfig), (i = this) !== vS && (void 0 !== vS && vS.close(), vS = i), Od(t) && (e = t, t = void 0), void 0 === e && (e = TS(t, "onClose", void 0)); var n = TS(t, "onOpen", void 0),
                    s = TS(t, "onTextChanged", void 0); return this.inputText = function(t, e) { void 0 === e && (e = {}); var i = t.scene,
                        n = t.style,
                        s = SS(e, "backgroundColor", n.backgroundColor);
                    null === s && (s = "transparent"), e.text = SS(e, "text", t.text), e.fontFamily = SS(e, "fontFamily", n.fontFamily), e.fontSize = SS(e, "fontSize", n.fontSize), e.color = SS(e, "color", n.color), e.backgroundColor = s, e.direction = SS(e, "rtl", n.rtl) ? "rtl" : "ltr", e.align = SS(e, "align", PS(n)), "rtl" === e.direction && $b(t) && (e.align = "right"); var r = new CS(i, t.x, t.y, SS(e, "width", t.width), SS(e, "height", t.height), e); return r.setOrigin(t.originX, t.originY), i.add.existing(r), r }(this.parent, t).on("textchange", function(t) { var e = t.text;
                    s ? s(this.parent, e) : this.parent.text = e }, this).setFocus(), this.parent.setVisible(!1), this.onClose = e, TS(t, "enterClose", !0) && this.scene.input.keyboard.once("keydown-ENTER", this.close, this), this.delayCall = this.scene.time.delayedCall(0, function() { this.scene.input.once("pointerdown", this.close, this), n && n(this.parent), this.emit("open", this.parent) }, [], this), this }, close: function() { return this === vS && (vS = void 0), this.parent.setVisible(!0), this.inputText && (this.inputText.destroy(), this.inputText = void 0), this.delayCall && (this.delayCall.remove(), this.delayCall = void 0), this.scene.input.keyboard.off("keydown-ENTER", this.close, this), this.scene.input.off("pointerdown", this.close, this), this.onClose && this.onClose(this.parent), this.emit("close", this.parent), this } },
        ES = Phaser.Utils.Objects.GetValue,
        _S = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t)).inputText = void 0, i.onClose = void 0, i.delayCall = void 0, i.setOpenConfig(e), ES(e, "clickEnable", !0) && t.on("pointerdown", function() { this.open() }, W(i)).setInteractive(), i } return k(s, [{ key: "shutdown", value: function(t) { this.isShutdown || (this.close(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "setOpenConfig", value: function(t) { return void 0 === t && (t = {}), this.openConfig = t, this } }, { key: "isOpened", get: function() { return void 0 !== this.inputText } }, { key: "text", get: function() { return this.isOpened ? this.inputText.text : this.parent.text } }]), s }();
    Object.assign(_S.prototype, MS);

    function RS(t) { return null == t }
    p.register("textEdit", function(t, e) { return new _S(t, e) }), j(window, "RexPlugins.UI.TextEdit", _S); var BS = { isNothing: RS, isObject: function(t) { return "object" == typeof t && null !== t }, toArray: function(t) { return Array.isArray(t) ? t : RS(t) ? [] : [t] }, repeat: function(t, e) { var i, n = ""; for (i = 0; i < e; i += 1) n += t; return n }, isNegativeZero: function(t) { return 0 === t && Number.NEGATIVE_INFINITY === 1 / t }, extend: function(t, e) { var i, n, s, r; if (e)
                for (i = 0, n = (r = Object.keys(e)).length; i < n; i += 1) t[s = r[i]] = e[s]; return t } };

    function IS(t, e) { var i = "",
            n = t.reason || "(unknown reason)"; return t.mark ? (t.mark.name && (i += 'in "' + t.mark.name + '" '), i += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")", !e && t.mark.snippet && (i += "\n\n" + t.mark.snippet), n + " " + i) : n }

    function LS(t, e) { Error.call(this), this.name = "YAMLException", this.reason = t, this.mark = e, this.message = IS(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error()).stack || "" }((LS.prototype = Object.create(Error.prototype)).constructor = LS).prototype.toString = function(t) { return this.name + ": " + IS(this, t) }; var AS = LS;

    function jS(t, e, i, n, s) { var r = "",
            o = "",
            a = Math.floor(s / 2) - 1; return a < n - e && (e = n - a + (r = " ... ").length), a < i - n && (i = n + a - (o = " ...").length), { str: r + t.slice(e, i).replace(/\t/g, "→") + o, pos: n - e + r.length } }

    function DS(t, e) { return BS.repeat(" ", e - t.length) + t } var zS = function(t, e) { if (e = Object.create(e || null), !t.buffer) return null;
            e.maxLength || (e.maxLength = 79), "number" != typeof e.indent && (e.indent = 1), "number" != typeof e.linesBefore && (e.linesBefore = 3), "number" != typeof e.linesAfter && (e.linesAfter = 2); for (var i, n = /\r?\n|\r|\0/g, s = [0], r = [], o = -1; i = n.exec(t.buffer);) r.push(i.index), s.push(i.index + i[0].length), t.position <= i.index && o < 0 && (o = s.length - 2);
            o < 0 && (o = s.length - 1); var a, h, l = "",
                u = Math.min(t.line + e.linesAfter, r.length).toString().length,
                c = e.maxLength - (e.indent + u + 3); for (a = 1; a <= e.linesBefore && !(o - a < 0); a++) h = jS(t.buffer, s[o - a], r[o - a], t.position - (s[o] - s[o - a]), c), l = BS.repeat(" ", e.indent) + DS((t.line - a + 1).toString(), u) + " | " + h.str + "\n" + l; for (h = jS(t.buffer, s[o], r[o], t.position, c), l += BS.repeat(" ", e.indent) + DS((t.line + 1).toString(), u) + " | " + h.str + "\n", l += BS.repeat("-", e.indent + u + 3 + h.pos) + "^\n", a = 1; a <= e.linesAfter && !(o + a >= r.length); a++) h = jS(t.buffer, s[o + a], r[o + a], t.position - (s[o] - s[o + a]), c), l += BS.repeat(" ", e.indent) + DS((t.line + a + 1).toString(), u) + " | " + h.str + "\n"; return l.replace(/\n$/, "") },
        FS = ["kind", "multi", "resolve", "construct", "instanceOf", "predicate", "represent", "representName", "defaultStyle", "styleAliases"],
        YS = ["scalar", "sequence", "mapping"]; var XS = function(e, t) { var i, n; if (t = t || {}, Object.keys(t).forEach(function(t) { if (-1 === FS.indexOf(t)) throw new AS('Unknown option "' + t + '" is met in definition of "' + e + '" YAML type.') }), this.options = t, this.tag = e, this.kind = t.kind || null, this.resolve = t.resolve || function() { return !0 }, this.construct = t.construct || function(t) { return t }, this.instanceOf = t.instanceOf || null, this.predicate = t.predicate || null, this.represent = t.represent || null, this.representName = t.representName || null, this.defaultStyle = t.defaultStyle || null, this.multi = t.multi || !1, this.styleAliases = (i = t.styleAliases || null, n = {}, null !== i && Object.keys(i).forEach(function(e) { i[e].forEach(function(t) { n[String(t)] = e }) }), n), -1 === YS.indexOf(this.kind)) throw new AS('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.') };

    function WS(t, e) { var s = []; return t[e].forEach(function(i) { var n = s.length;
            s.forEach(function(t, e) { t.tag === i.tag && t.kind === i.kind && t.multi === i.multi && (n = e) }), s[n] = i }), s }

    function GS(t) { return this.extend(t) }
    GS.prototype.extend = function(t) { var e = [],
            i = []; if (t instanceof XS) i.push(t);
        else if (Array.isArray(t)) i = i.concat(t);
        else { if (!t || !Array.isArray(t.implicit) && !Array.isArray(t.explicit)) throw new AS("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
            t.implicit && (e = e.concat(t.implicit)), t.explicit && (i = i.concat(t.explicit)) }
        e.forEach(function(t) { if (!(t instanceof XS)) throw new AS("Specified list of YAML types (or a single Type object) contains a non-Type object."); if (t.loadKind && "scalar" !== t.loadKind) throw new AS("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."); if (t.multi) throw new AS("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.") }), i.forEach(function(t) { if (!(t instanceof XS)) throw new AS("Specified list of YAML types (or a single Type object) contains a non-Type object.") }); var n = Object.create(GS.prototype); return n.implicit = (this.implicit || []).concat(e), n.explicit = (this.explicit || []).concat(i), n.compiledImplicit = WS(n, "implicit"), n.compiledExplicit = WS(n, "explicit"), n.compiledTypeMap = function() { var t, e, i = { scalar: {}, sequence: {}, mapping: {}, fallback: {}, multi: { scalar: [], sequence: [], mapping: [], fallback: [] } };

            function n(t) { t.multi ? (i.multi[t.kind].push(t), i.multi.fallback.push(t)) : i[t.kind][t.tag] = i.fallback[t.tag] = t } for (t = 0, e = arguments.length; t < e; t += 1) arguments[t].forEach(n); return i }(n.compiledImplicit, n.compiledExplicit), n }; var VS = GS,
        US = new XS("tag:yaml.org,2002:str", { kind: "scalar", construct: function(t) { return null !== t ? t : "" } }),
        HS = new XS("tag:yaml.org,2002:seq", { kind: "sequence", construct: function(t) { return null !== t ? t : [] } }),
        NS = new XS("tag:yaml.org,2002:map", { kind: "mapping", construct: function(t) { return null !== t ? t : {} } }),
        JS = new VS({ explicit: [US, HS, NS] }); var KS = new XS("tag:yaml.org,2002:null", { kind: "scalar", resolve: function(t) { if (null === t) return !0; var e = t.length; return 1 === e && "~" === t || 4 === e && ("null" === t || "Null" === t || "NULL" === t) }, construct: function() { return null }, predicate: function(t) { return null === t }, represent: { canonical: function() { return "~" }, lowercase: function() { return "null" }, uppercase: function() { return "NULL" }, camelcase: function() { return "Null" }, empty: function() { return "" } }, defaultStyle: "lowercase" }); var ZS = new XS("tag:yaml.org,2002:bool", { kind: "scalar", resolve: function(t) { if (null === t) return !1; var e = t.length; return 4 === e && ("true" === t || "True" === t || "TRUE" === t) || 5 === e && ("false" === t || "False" === t || "FALSE" === t) }, construct: function(t) { return "true" === t || "True" === t || "TRUE" === t }, predicate: function(t) { return "[object Boolean]" === Object.prototype.toString.call(t) }, represent: { lowercase: function(t) { return t ? "true" : "false" }, uppercase: function(t) { return t ? "TRUE" : "FALSE" }, camelcase: function(t) { return t ? "True" : "False" } }, defaultStyle: "lowercase" }); var qS = new XS("tag:yaml.org,2002:int", { kind: "scalar", resolve: function(t) { if (null === t) return !1; var e, i, n, s, r = t.length,
                    o = 0,
                    a = !1; if (!r) return !1; if ("-" !== (e = t[o]) && "+" !== e || (e = t[++o]), "0" === e) { if (o + 1 === r) return !0; if ("b" === (e = t[++o])) { for (o++; o < r; o++)
                            if ("_" !== (e = t[o])) { if ("0" !== e && "1" !== e) return !1;
                                a = !0 }
                        return a && "_" !== e } if ("x" === e) { for (o++; o < r; o++)
                            if ("_" !== (e = t[o])) { if (!(48 <= (n = t.charCodeAt(o)) && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102)) return !1;
                                a = !0 }
                        return a && "_" !== e } if ("o" === e) { for (o++; o < r; o++)
                            if ("_" !== (e = t[o])) { if (!(48 <= (i = t.charCodeAt(o)) && i <= 55)) return !1;
                                a = !0 }
                        return a && "_" !== e } } if ("_" === e) return !1; for (; o < r; o++)
                    if ("_" !== (e = t[o])) { if (!(48 <= (s = t.charCodeAt(o)) && s <= 57)) return !1;
                        a = !0 }
                return !(!a || "_" === e) }, construct: function(t) { var e, i = t,
                    n = 1; if (-1 !== i.indexOf("_") && (i = i.replace(/_/g, "")), "-" !== (e = i[0]) && "+" !== e || ("-" === e && (n = -1), e = (i = i.slice(1))[0]), "0" === i) return 0; if ("0" === e) { if ("b" === i[1]) return n * parseInt(i.slice(2), 2); if ("x" === i[1]) return n * parseInt(i.slice(2), 16); if ("o" === i[1]) return n * parseInt(i.slice(2), 8) } return n * parseInt(i, 10) }, predicate: function(t) { return "[object Number]" === Object.prototype.toString.call(t) && t % 1 == 0 && !BS.isNegativeZero(t) }, represent: { binary: function(t) { return 0 <= t ? "0b" + t.toString(2) : "-0b" + t.toString(2).slice(1) }, octal: function(t) { return 0 <= t ? "0o" + t.toString(8) : "-0o" + t.toString(8).slice(1) }, decimal: function(t) { return t.toString(10) }, hexadecimal: function(t) { return 0 <= t ? "0x" + t.toString(16).toUpperCase() : "-0x" + t.toString(16).toUpperCase().slice(1) } }, defaultStyle: "decimal", styleAliases: { binary: [2, "bin"], octal: [8, "oct"], decimal: [10, "dec"], hexadecimal: [16, "hex"] } }),
        $S = new RegExp("^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"); var QS = /^[-+]?[0-9]+e/; var tP = new XS("tag:yaml.org,2002:float", { kind: "scalar", resolve: function(t) { return null !== t && !(!$S.test(t) || "_" === t[t.length - 1]) }, construct: function(t) { var e, i; return i = "-" === (e = t.replace(/_/g, "").toLowerCase())[0] ? -1 : 1, 0 <= "+-".indexOf(e[0]) && (e = e.slice(1)), ".inf" === e ? 1 == i ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : ".nan" === e ? NaN : i * parseFloat(e, 10) }, predicate: function(t) { return "[object Number]" === Object.prototype.toString.call(t) && (t % 1 != 0 || BS.isNegativeZero(t)) }, represent: function(t, e) { var i; if (isNaN(t)) switch (e) {
                    case "lowercase":
                        return ".nan";
                    case "uppercase":
                        return ".NAN";
                    case "camelcase":
                        return ".NaN" } else if (Number.POSITIVE_INFINITY === t) switch (e) {
                    case "lowercase":
                        return ".inf";
                    case "uppercase":
                        return ".INF";
                    case "camelcase":
                        return ".Inf" } else if (Number.NEGATIVE_INFINITY === t) switch (e) {
                    case "lowercase":
                        return "-.inf";
                    case "uppercase":
                        return "-.INF";
                    case "camelcase":
                        return "-.Inf" } else if (BS.isNegativeZero(t)) return "-0.0";
                return i = t.toString(10), QS.test(i) ? i.replace("e", ".e") : i }, defaultStyle: "lowercase" }),
        eP = JS.extend({ implicit: [KS, ZS, qS, tP] }),
        iP = eP,
        nP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
        sP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"); var rP = new XS("tag:yaml.org,2002:timestamp", { kind: "scalar", resolve: function(t) { return null !== t && (null !== nP.exec(t) || null !== sP.exec(t)) }, construct: function(t) { var e, i, n, s, r, o, a, h, l = 0,
                u = null; if (null === (e = nP.exec(t)) && (e = sP.exec(t)), null === e) throw new Error("Date resolve error"); if (i = +e[1], n = e[2] - 1, s = +e[3], !e[4]) return new Date(Date.UTC(i, n, s)); if (r = +e[4], o = +e[5], a = +e[6], e[7]) { for (l = e[7].slice(0, 3); l.length < 3;) l += "0";
                l = +l } return e[9] && (u = 6e4 * (60 * +e[10] + +(e[11] || 0)), "-" === e[9] && (u = -u)), h = new Date(Date.UTC(i, n, s, r, o, a, l)), u && h.setTime(h.getTime() - u), h }, instanceOf: Date, represent: function(t) { return t.toISOString() } }); var oP = new XS("tag:yaml.org,2002:merge", { kind: "scalar", resolve: function(t) { return "<<" === t || null === t } }),
        aP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r"; var hP = new XS("tag:yaml.org,2002:binary", { kind: "scalar", resolve: function(t) { if (null === t) return !1; var e, i, n = 0,
                    s = t.length,
                    r = aP; for (i = 0; i < s; i++)
                    if (!(64 < (e = r.indexOf(t.charAt(i))))) { if (e < 0) return !1;
                        n += 6 }
                return n % 8 == 0 }, construct: function(t) { var e, i, n = t.replace(/[\r\n=]/g, ""),
                    s = n.length,
                    r = aP,
                    o = 0,
                    a = []; for (e = 0; e < s; e++) e % 4 == 0 && e && (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(255 & o)), o = o << 6 | r.indexOf(n.charAt(e)); return 0 == (i = s % 4 * 6) ? (a.push(o >> 16 & 255), a.push(o >> 8 & 255), a.push(255 & o)) : 18 == i ? (a.push(o >> 10 & 255), a.push(o >> 2 & 255)) : 12 == i && a.push(o >> 4 & 255), new Uint8Array(a) }, predicate: function(t) { return "[object Uint8Array]" === Object.prototype.toString.call(t) }, represent: function(t) { var e, i, n = "",
                    s = 0,
                    r = t.length,
                    o = aP; for (e = 0; e < r; e++) e % 3 == 0 && e && (n += o[s >> 18 & 63], n += o[s >> 12 & 63], n += o[s >> 6 & 63], n += o[63 & s]), s = (s << 8) + t[e]; return 0 == (i = r % 3) ? (n += o[s >> 18 & 63], n += o[s >> 12 & 63], n += o[s >> 6 & 63], n += o[63 & s]) : 2 == i ? (n += o[s >> 10 & 63], n += o[s >> 4 & 63], n += o[s << 2 & 63], n += o[64]) : 1 == i && (n += o[s >> 2 & 63], n += o[s << 4 & 63], n += o[64], n += o[64]), n } }),
        lP = Object.prototype.hasOwnProperty,
        uP = Object.prototype.toString; var cP = new XS("tag:yaml.org,2002:omap", { kind: "sequence", resolve: function(t) { if (null === t) return !0; var e, i, n, s, r, o = [],
                    a = t; for (e = 0, i = a.length; e < i; e += 1) { if (n = a[e], r = !1, "[object Object]" !== uP.call(n)) return !1; for (s in n)
                        if (lP.call(n, s)) { if (r) return !1;
                            r = !0 }
                    if (!r) return !1; if (-1 !== o.indexOf(s)) return !1;
                    o.push(s) } return !0 }, construct: function(t) { return null !== t ? t : [] } }),
        dP = Object.prototype.toString; var fP = new XS("tag:yaml.org,2002:pairs", { kind: "sequence", resolve: function(t) { if (null === t) return !0; var e, i, n, s, r, o = t; for (r = new Array(o.length), e = 0, i = o.length; e < i; e += 1) { if (n = o[e], "[object Object]" !== dP.call(n)) return !1; if (1 !== (s = Object.keys(n)).length) return !1;
                    r[e] = [s[0], n[s[0]]] } return !0 }, construct: function(t) { if (null === t) return []; var e, i, n, s, r, o = t; for (r = new Array(o.length), e = 0, i = o.length; e < i; e += 1) n = o[e], s = Object.keys(n), r[e] = [s[0], n[s[0]]]; return r } }),
        pP = Object.prototype.hasOwnProperty; var vP = new XS("tag:yaml.org,2002:set", { kind: "mapping", resolve: function(t) { if (null === t) return !0; var e, i = t; for (e in i)
                    if (pP.call(i, e) && null !== i[e]) return !1;
                return !0 }, construct: function(t) { return null !== t ? t : {} } }),
        gP = iP.extend({ implicit: [rP, oP], explicit: [hP, cP, fP, vP] }),
        yP = Object.prototype.hasOwnProperty,
        mP = 1,
        kP = 2,
        bP = 3,
        xP = 4,
        CP = 1,
        wP = 2,
        SP = 3,
        PP = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
        TP = /[\x85\u2028\u2029]/,
        OP = /[,\[\]\{\}]/,
        MP = /^(?:!|!!|![a-z\-]+!)$/i,
        EP = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

    function _P(t) { return Object.prototype.toString.call(t) }

    function RP(t) { return 10 === t || 13 === t }

    function BP(t) { return 9 === t || 32 === t }

    function IP(t) { return 9 === t || 32 === t || 10 === t || 13 === t }

    function LP(t) { return 44 === t || 91 === t || 93 === t || 123 === t || 125 === t }

    function AP(t) { return 48 === t ? "\0" : 97 === t ? "" : 98 === t ? "\b" : 116 === t || 9 === t ? "\t" : 110 === t ? "\n" : 118 === t ? "\v" : 102 === t ? "\f" : 114 === t ? "\r" : 101 === t ? "" : 32 === t ? " " : 34 === t ? '"' : 47 === t ? "/" : 92 === t ? "\\" : 78 === t ? "" : 95 === t ? " " : 76 === t ? "\u2028" : 80 === t ? "\u2029" : "" } for (var jP = new Array(256), DP = new Array(256), zP = 0; zP < 256; zP++) jP[zP] = AP(zP) ? 1 : 0, DP[zP] = AP(zP);

    function FP(t, e) { this.input = t, this.filename = e.filename || null, this.schema = e.schema || gP, this.onWarning = e.onWarning || null, this.legacy = e.legacy || !1, this.json = e.json || !1, this.listener = e.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = t.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [] }

    function YP(t, e) { var i = { name: t.filename, buffer: t.input.slice(0, -1), position: t.position, line: t.line, column: t.position - t.lineStart }; return i.snippet = zS(i), new AS(e, i) }

    function XP(t, e) { throw YP(t, e) }

    function WP(t, e) { t.onWarning && t.onWarning.call(null, YP(t, e)) } var GP = { YAML: function(t, e, i) { var n, s, r;
            null !== t.version && XP(t, "duplication of %YAML directive"), 1 !== i.length && XP(t, "YAML directive accepts exactly one argument"), null === (n = /^([0-9]+)\.([0-9]+)$/.exec(i[0])) && XP(t, "ill-formed argument of the YAML directive"), s = parseInt(n[1], 10), r = parseInt(n[2], 10), 1 !== s && XP(t, "unacceptable YAML version of the document"), t.version = i[0], t.checkLineBreaks = r < 2, 1 !== r && 2 !== r && WP(t, "unsupported YAML version of the document") }, TAG: function(e, t, i) { var n, s;
            2 !== i.length && XP(e, "TAG directive accepts exactly two arguments"), n = i[0], s = i[1], MP.test(n) || XP(e, "ill-formed tag handle (first argument) of the TAG directive"), yP.call(e.tagMap, n) && XP(e, 'there is a previously declared suffix for "' + n + '" tag handle'), EP.test(s) || XP(e, "ill-formed tag prefix (second argument) of the TAG directive"); try { s = decodeURIComponent(s) } catch (t) { XP(e, "tag prefix is malformed: " + s) }
            e.tagMap[n] = s } };

    function VP(t, e, i, n) { var s, r, o, a; if (e < i) { if (a = t.input.slice(e, i), n)
                for (s = 0, r = a.length; s < r; s += 1) 9 === (o = a.charCodeAt(s)) || 32 <= o && o <= 1114111 || XP(t, "expected valid JSON character");
            else PP.test(a) && XP(t, "the stream contains non-printable characters");
            t.result += a } }

    function UP(t, e, i, n) { var s, r, o, a; for (BS.isObject(i) || XP(t, "cannot merge mappings; the provided source object is unacceptable"), o = 0, a = (s = Object.keys(i)).length; o < a; o += 1) r = s[o], yP.call(e, r) || (e[r] = i[r], n[r] = !0) }

    function HP(t, e, i, n, s, r, o, a, h) { var l, u; if (Array.isArray(s))
            for (l = 0, u = (s = Array.prototype.slice.call(s)).length; l < u; l += 1) Array.isArray(s[l]) && XP(t, "nested arrays are not supported inside keys"), "object" == typeof s && "[object Object]" === _P(s[l]) && (s[l] = "[object Object]"); if ("object" == typeof s && "[object Object]" === _P(s) && (s = "[object Object]"), s = String(s), null === e && (e = {}), "tag:yaml.org,2002:merge" === n)
            if (Array.isArray(r))
                for (l = 0, u = r.length; l < u; l += 1) UP(t, e, r[l], i);
            else UP(t, e, r, i);
        else t.json || yP.call(i, s) || !yP.call(e, s) || (t.line = o || t.line, t.lineStart = a || t.lineStart, t.position = h || t.position, XP(t, "duplicated mapping key")), "__proto__" === s ? Object.defineProperty(e, s, { configurable: !0, enumerable: !0, writable: !0, value: r }) : e[s] = r, delete i[s]; return e }

    function NP(t) { var e;
        10 === (e = t.input.charCodeAt(t.position)) ? t.position++ : 13 === e ? (t.position++, 10 === t.input.charCodeAt(t.position) && t.position++) : XP(t, "a line break is expected"), t.line += 1, t.lineStart = t.position, t.firstTabInLine = -1 }

    function JP(t, e, i) { for (var n = 0, s = t.input.charCodeAt(t.position); 0 !== s;) { for (; BP(s);) 9 === s && -1 === t.firstTabInLine && (t.firstTabInLine = t.position), s = t.input.charCodeAt(++t.position); if (e && 35 === s)
                for (; 10 !== (s = t.input.charCodeAt(++t.position)) && 13 !== s && 0 !== s;); if (!RP(s)) break; for (NP(t), s = t.input.charCodeAt(t.position), n++, t.lineIndent = 0; 32 === s;) t.lineIndent++, s = t.input.charCodeAt(++t.position) } return -1 !== i && 0 !== n && t.lineIndent < i && WP(t, "deficient indentation"), n }

    function KP(t) { var e, i = t.position; return 45 !== (e = t.input.charCodeAt(i)) && 46 !== e || e !== t.input.charCodeAt(i + 1) || e !== t.input.charCodeAt(i + 2) || (i += 3, 0 !== (e = t.input.charCodeAt(i)) && !IP(e)) ? void 0 : 1 }

    function ZP(t, e) { 1 === e ? t.result += " " : 1 < e && (t.result += BS.repeat("\n", e - 1)) }

    function qP(t, e) { var i, n, s = t.tag,
            r = t.anchor,
            o = [],
            a = !1; if (-1 !== t.firstTabInLine) return !1; for (null !== t.anchor && (t.anchorMap[t.anchor] = o), n = t.input.charCodeAt(t.position); 0 !== n && (-1 !== t.firstTabInLine && (t.position = t.firstTabInLine, XP(t, "tab characters must not be used in indentation")), 45 === n) && IP(t.input.charCodeAt(t.position + 1));)
            if (a = !0, t.position++, JP(t, !0, -1) && t.lineIndent <= e) o.push(null), n = t.input.charCodeAt(t.position);
            else if (i = t.line, tT(t, e, bP, !1, !0), o.push(t.result), JP(t, !0, -1), n = t.input.charCodeAt(t.position), (t.line === i || t.lineIndent > e) && 0 !== n) XP(t, "bad indentation of a sequence entry");
        else if (t.lineIndent < e) break; return !!a && (t.tag = s, t.anchor = r, t.kind = "sequence", t.result = o, !0) }

    function $P(e) { var t, i, n, s, r = !1,
            o = !1; if (33 === (s = e.input.charCodeAt(e.position))) { if (null !== e.tag && XP(e, "duplication of a tag property"), 60 === (s = e.input.charCodeAt(++e.position)) ? (r = !0, s = e.input.charCodeAt(++e.position)) : 33 === s ? (o = !0, i = "!!", s = e.input.charCodeAt(++e.position)) : i = "!", t = e.position, r) { for (; 0 !== (s = e.input.charCodeAt(++e.position)) && 62 !== s;);
                e.position < e.length ? (n = e.input.slice(t, e.position), s = e.input.charCodeAt(++e.position)) : XP(e, "unexpected end of the stream within a verbatim tag") } else { for (; 0 !== s && !IP(s);) 33 === s && (o ? XP(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(t - 1, e.position + 1), MP.test(i) || XP(e, "named tag handle cannot contain such characters"), o = !0, t = e.position + 1)), s = e.input.charCodeAt(++e.position);
                n = e.input.slice(t, e.position), OP.test(n) && XP(e, "tag suffix cannot contain flow indicator characters") }
            n && !EP.test(n) && XP(e, "tag name cannot contain such characters: " + n); try { n = decodeURIComponent(n) } catch (t) { XP(e, "tag name is malformed: " + n) } return r ? e.tag = n : yP.call(e.tagMap, i) ? e.tag = e.tagMap[i] + n : "!" === i ? e.tag = "!" + n : "!!" === i ? e.tag = "tag:yaml.org,2002:" + n : XP(e, 'undeclared tag handle "' + i + '"'), 1 } }

    function QP(t) { var e, i; if (38 === (i = t.input.charCodeAt(t.position))) { for (null !== t.anchor && XP(t, "duplication of an anchor property"), i = t.input.charCodeAt(++t.position), e = t.position; 0 !== i && !IP(i) && !LP(i);) i = t.input.charCodeAt(++t.position); return t.position === e && XP(t, "name of an anchor node must contain at least one character"), t.anchor = t.input.slice(e, t.position), 1 } }

    function tT(t, e, i, n, s) { var r, o, a, h, l, u, c, d, f, p = 1,
            v = !1,
            g = !1; if (null !== t.listener && t.listener("open", t), t.tag = null, t.anchor = null, t.kind = null, t.result = null, r = o = a = xP === i || bP === i, n && JP(t, !0, -1) && (v = !0, t.lineIndent > e ? p = 1 : t.lineIndent === e ? p = 0 : t.lineIndent < e && (p = -1)), 1 === p)
            for (; $P(t) || QP(t);) JP(t, !0, -1) ? (v = !0, a = r, t.lineIndent > e ? p = 1 : t.lineIndent === e ? p = 0 : t.lineIndent < e && (p = -1)) : a = !1; if (a = a && (v || s), 1 !== p && xP !== i || (d = mP === i || kP === i ? e : e + 1, f = t.position - t.lineStart, 1 === p ? a && (qP(t, f) || function(t, e, i) { var n, s, r, o, a, h, l, u = t.tag,
                    c = t.anchor,
                    d = {},
                    f = Object.create(null),
                    p = null,
                    v = null,
                    g = null,
                    y = !1,
                    m = !1; if (-1 === t.firstTabInLine) { for (null !== t.anchor && (t.anchorMap[t.anchor] = d), l = t.input.charCodeAt(t.position); 0 !== l;) { if (y || -1 === t.firstTabInLine || (t.position = t.firstTabInLine, XP(t, "tab characters must not be used in indentation")), n = t.input.charCodeAt(t.position + 1), r = t.line, 63 !== l && 58 !== l || !IP(n)) { if (o = t.line, a = t.lineStart, h = t.position, !tT(t, i, kP, !1, !0)) break; if (t.line === r) { for (l = t.input.charCodeAt(t.position); BP(l);) l = t.input.charCodeAt(++t.position); if (58 === l) IP(l = t.input.charCodeAt(++t.position)) || XP(t, "a whitespace character is expected after the key-value separator within a block mapping"), y && (HP(t, d, f, p, v, null, o, a, h), p = v = g = null), s = y = !(m = !0), p = t.tag, v = t.result;
                                else { if (!m) return t.tag = u, t.anchor = c, 1;
                                    XP(t, "can not read an implicit mapping pair; a colon is missed") } } else { if (!m) return t.tag = u, t.anchor = c, 1;
                                XP(t, "can not read a block mapping entry; a multiline key may not be an implicit key") } } else 63 === l ? (y && (HP(t, d, f, p, v, null, o, a, h), p = v = g = null), s = y = m = !0) : y ? s = !(y = !1) : XP(t, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), t.position += 1, l = n; if ((t.line === r || t.lineIndent > e) && (y && (o = t.line, a = t.lineStart, h = t.position), tT(t, e, xP, !0, s) && (y ? v = t.result : g = t.result), y || (HP(t, d, f, p, v, g, o, a, h), p = v = g = null), JP(t, !0, -1), l = t.input.charCodeAt(t.position)), (t.line === r || t.lineIndent > e) && 0 !== l) XP(t, "bad indentation of a mapping entry");
                        else if (t.lineIndent < e) break } return y && HP(t, d, f, p, v, null, o, a, h), m && (t.tag = u, t.anchor = c, t.kind = "mapping", t.result = d), m } }(t, f, d)) || function(t, e) { var i, n, s, r, o, a, h, l, u, c, d, f, p = !0,
                    v = t.tag,
                    g = t.anchor,
                    y = Object.create(null); if (91 === (f = t.input.charCodeAt(t.position))) l = !(o = 93), r = [];
                else { if (123 !== f) return;
                    o = 125, l = !0, r = {} } for (null !== t.anchor && (t.anchorMap[t.anchor] = r), f = t.input.charCodeAt(++t.position); 0 !== f;) { if (JP(t, !0, e), (f = t.input.charCodeAt(t.position)) === o) return t.position++, t.tag = v, t.anchor = g, t.kind = l ? "mapping" : "sequence", t.result = r, 1;
                    p ? 44 === f && XP(t, "expected the node content, but found ','") : XP(t, "missed comma between flow collection entries"), d = null, a = h = !1, 63 === f && IP(t.input.charCodeAt(t.position + 1)) && (a = h = !0, t.position++, JP(t, !0, e)), i = t.line, n = t.lineStart, s = t.position, tT(t, e, mP, !1, !0), c = t.tag, u = t.result, JP(t, !0, e), f = t.input.charCodeAt(t.position), !h && t.line !== i || 58 !== f || (a = !0, f = t.input.charCodeAt(++t.position), JP(t, !0, e), tT(t, e, mP, !1, !0), d = t.result), l ? HP(t, r, y, c, u, d, i, n, s) : a ? r.push(HP(t, null, y, c, u, d, i, n, s)) : r.push(u), JP(t, !0, e), 44 === (f = t.input.charCodeAt(t.position)) ? (p = !0, f = t.input.charCodeAt(++t.position)) : p = !1 }
                XP(t, "unexpected end of the stream within a flow collection") }(t, d) ? g = !0 : (o && function(t, e) { var i, n, s, r, o, a = CP,
                    h = !1,
                    l = !1,
                    u = e,
                    c = 0,
                    d = !1; if (124 === (r = t.input.charCodeAt(t.position))) n = !1;
                else { if (62 !== r) return;
                    n = !0 } for (t.kind = "scalar", t.result = ""; 0 !== r;)
                    if (43 === (r = t.input.charCodeAt(++t.position)) || 45 === r) CP === a ? a = 43 === r ? SP : wP : XP(t, "repeat of a chomping mode identifier");
                    else { if (!(0 <= (s = 48 <= (o = r) && o <= 57 ? o - 48 : -1))) break;
                        0 == s ? XP(t, "bad explicit indentation width of a block scalar; it cannot be less than one") : l ? XP(t, "repeat of an indentation width identifier") : (u = e + s - 1, l = !0) }
                if (BP(r)) { for (; BP(r = t.input.charCodeAt(++t.position));); if (35 === r)
                        for (; !RP(r = t.input.charCodeAt(++t.position)) && 0 !== r;); } for (; 0 !== r;) { for (NP(t), t.lineIndent = 0, r = t.input.charCodeAt(t.position);
                        (!l || t.lineIndent < u) && 32 === r;) t.lineIndent++, r = t.input.charCodeAt(++t.position); if (!l && t.lineIndent > u && (u = t.lineIndent), RP(r)) c++;
                    else { if (t.lineIndent < u) { a === SP ? t.result += BS.repeat("\n", h ? 1 + c : c) : a === CP && h && (t.result += "\n"); break } for (n ? BP(r) ? (d = !0, t.result += BS.repeat("\n", h ? 1 + c : c)) : d ? (d = !1, t.result += BS.repeat("\n", c + 1)) : 0 === c ? h && (t.result += " ") : t.result += BS.repeat("\n", c) : t.result += BS.repeat("\n", h ? 1 + c : c), l = h = !0, c = 0, i = t.position; !RP(r) && 0 !== r;) r = t.input.charCodeAt(++t.position);
                        VP(t, i, t.position, !1) } } return 1 }(t, d) || function(t, e) { var i, n, s; if (39 === (i = t.input.charCodeAt(t.position))) { for (t.kind = "scalar", t.result = "", t.position++, n = s = t.position; 0 !== (i = t.input.charCodeAt(t.position));)
                        if (39 === i) { if (VP(t, n, t.position, !0), 39 !== (i = t.input.charCodeAt(++t.position))) return 1;
                            n = t.position, t.position++, s = t.position } else RP(i) ? (VP(t, n, s, !0), ZP(t, JP(t, !1, e)), n = s = t.position) : t.position === t.lineStart && KP(t) ? XP(t, "unexpected end of the document within a single quoted scalar") : (t.position++, s = t.position);
                    XP(t, "unexpected end of the stream within a single quoted scalar") } }(t, d) || function(t, e) { var i, n, s, r, o, a; if (34 === (a = t.input.charCodeAt(t.position))) { for (t.kind = "scalar", t.result = "", t.position++, i = n = t.position; 0 !== (a = t.input.charCodeAt(t.position));) { if (34 === a) return VP(t, i, t.position, !0), t.position++, 1; if (92 === a) { if (VP(t, i, t.position, !0), RP(a = t.input.charCodeAt(++t.position))) JP(t, !1, e);
                            else if (a < 256 && jP[a]) t.result += DP[a], t.position++;
                            else if (0 < (o = 120 === (c = a) ? 2 : 117 === c ? 4 : 85 === c ? 8 : 0)) { for (s = o, r = 0; 0 < s; s--) a = t.input.charCodeAt(++t.position), u = void 0, 0 <= (o = 48 <= (l = a) && l <= 57 ? l - 48 : 97 <= (u = 32 | l) && u <= 102 ? u - 97 + 10 : -1) ? r = (r << 4) + o : XP(t, "expected hexadecimal character");
                                t.result += (h = r) <= 65535 ? String.fromCharCode(h) : String.fromCharCode(55296 + (h - 65536 >> 10), 56320 + (h - 65536 & 1023)), t.position++ } else XP(t, "unknown escape sequence");
                            i = n = t.position } else RP(a) ? (VP(t, i, n, !0), ZP(t, JP(t, !1, e)), i = n = t.position) : t.position === t.lineStart && KP(t) ? XP(t, "unexpected end of the document within a double quoted scalar") : (t.position++, n = t.position) } var h, l, u, c;
                    XP(t, "unexpected end of the stream within a double quoted scalar") } }(t, d) ? g = !0 : ! function(t) { var e, i, n; if (42 === (n = t.input.charCodeAt(t.position))) { for (n = t.input.charCodeAt(++t.position), e = t.position; 0 !== n && !IP(n) && !LP(n);) n = t.input.charCodeAt(++t.position); return t.position === e && XP(t, "name of an alias node must contain at least one character"), i = t.input.slice(e, t.position), yP.call(t.anchorMap, i) || XP(t, 'unidentified alias "' + i + '"'), t.result = t.anchorMap[i], JP(t, !0, -1), 1 } }(t) ? function(t, e, i) { var n, s, r, o, a, h, l, u, c = t.kind,
                    d = t.result; if (!IP(u = t.input.charCodeAt(t.position)) && !LP(u) && 35 !== u && 38 !== u && 42 !== u && 33 !== u && 124 !== u && 62 !== u && 39 !== u && 34 !== u && 37 !== u && 64 !== u && 96 !== u && (63 !== u && 45 !== u || !(IP(n = t.input.charCodeAt(t.position + 1)) || i && LP(n)))) { for (t.kind = "scalar", t.result = "", s = r = t.position, o = !1; 0 !== u;) { if (58 === u) { if (IP(n = t.input.charCodeAt(t.position + 1)) || i && LP(n)) break } else if (35 === u) { if (IP(t.input.charCodeAt(t.position - 1))) break } else { if (t.position === t.lineStart && KP(t) || i && LP(u)) break; if (RP(u)) { if (a = t.line, h = t.lineStart, l = t.lineIndent, JP(t, !1, -1), t.lineIndent >= e) { o = !0, u = t.input.charCodeAt(t.position); continue }
                                t.position = r, t.line = a, t.lineStart = h, t.lineIndent = l; break } }
                        o && (VP(t, s, r, !1), ZP(t, t.line - a), s = r = t.position, o = !1), BP(u) || (r = t.position + 1), u = t.input.charCodeAt(++t.position) } if (VP(t, s, r, !1), t.result) return 1;
                    t.kind = c, t.result = d } }(t, d, mP === i) && (g = !0, null === t.tag && (t.tag = "?")) : (g = !0, null === t.tag && null === t.anchor || XP(t, "alias node should not have any properties")), null !== t.anchor && (t.anchorMap[t.anchor] = t.result)) : 0 === p && (g = a && qP(t, f))), null === t.tag) null !== t.anchor && (t.anchorMap[t.anchor] = t.result);
        else if ("?" === t.tag) { for (null !== t.result && "scalar" !== t.kind && XP(t, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + t.kind + '"'), h = 0, l = t.implicitTypes.length; h < l; h += 1)
                if ((c = t.implicitTypes[h]).resolve(t.result)) { t.result = c.construct(t.result), t.tag = c.tag, null !== t.anchor && (t.anchorMap[t.anchor] = t.result); break } } else if ("!" !== t.tag) { if (yP.call(t.typeMap[t.kind || "fallback"], t.tag)) c = t.typeMap[t.kind || "fallback"][t.tag];
            else
                for (c = null, h = 0, l = (u = t.typeMap.multi[t.kind || "fallback"]).length; h < l; h += 1)
                    if (t.tag.slice(0, u[h].tag.length) === u[h].tag) { c = u[h]; break }
            c || XP(t, "unknown tag !<" + t.tag + ">"), null !== t.result && c.kind !== t.kind && XP(t, "unacceptable node kind for !<" + t.tag + '> tag; it should be "' + c.kind + '", not "' + t.kind + '"'), c.resolve(t.result, t.tag) ? (t.result = c.construct(t.result, t.tag), null !== t.anchor && (t.anchorMap[t.anchor] = t.result)) : XP(t, "cannot resolve a node with !<" + t.tag + "> explicit tag") } return null !== t.listener && t.listener("close", t), null !== t.tag || null !== t.anchor || g }

    function eT(t) { var e, i, n, s, r = t.position,
            o = !1; for (t.version = null, t.checkLineBreaks = t.legacy, t.tagMap = Object.create(null), t.anchorMap = Object.create(null); 0 !== (s = t.input.charCodeAt(t.position)) && (JP(t, !0, -1), s = t.input.charCodeAt(t.position), !(0 < t.lineIndent || 37 !== s));) { for (o = !0, s = t.input.charCodeAt(++t.position), e = t.position; 0 !== s && !IP(s);) s = t.input.charCodeAt(++t.position); for (n = [], (i = t.input.slice(e, t.position)).length < 1 && XP(t, "directive name must not be less than one character in length"); 0 !== s;) { for (; BP(s);) s = t.input.charCodeAt(++t.position); if (35 === s) { for (; 0 !== (s = t.input.charCodeAt(++t.position)) && !RP(s);); break } if (RP(s)) break; for (e = t.position; 0 !== s && !IP(s);) s = t.input.charCodeAt(++t.position);
                n.push(t.input.slice(e, t.position)) }
            0 !== s && NP(t), yP.call(GP, i) ? GP[i](t, i, n) : WP(t, 'unknown document directive "' + i + '"') }
        JP(t, !0, -1), 0 === t.lineIndent && 45 === t.input.charCodeAt(t.position) && 45 === t.input.charCodeAt(t.position + 1) && 45 === t.input.charCodeAt(t.position + 2) ? (t.position += 3, JP(t, !0, -1)) : o && XP(t, "directives end mark is expected"), tT(t, t.lineIndent - 1, xP, !1, !0), JP(t, !0, -1), t.checkLineBreaks && TP.test(t.input.slice(r, t.position)) && WP(t, "non-ASCII line breaks are interpreted as content"), t.documents.push(t.result), t.position === t.lineStart && KP(t) ? 46 === t.input.charCodeAt(t.position) && (t.position += 3, JP(t, !0, -1)) : t.position < t.length - 1 && XP(t, "end of the stream or a document separator is expected") }

    function iT(t, e) { e = e || {}, 0 !== (t = String(t)).length && (10 !== t.charCodeAt(t.length - 1) && 13 !== t.charCodeAt(t.length - 1) && (t += "\n"), 65279 === t.charCodeAt(0) && (t = t.slice(1))); var i = new FP(t, e),
            n = t.indexOf("\0"); for (-1 !== n && (i.position = n, XP(i, "null byte is not allowed in input")), i.input += "\0"; 32 === i.input.charCodeAt(i.position);) i.lineIndent += 1, i.position += 1; for (; i.position < i.length - 1;) eT(i); return i.documents } var nT = { loadAll: function(t, e, i) { null !== e && "object" == typeof e && void 0 === i && (i = e, e = null); var n = iT(t, i); if ("function" != typeof e) return n; for (var s = 0, r = n.length; s < r; s += 1) e(n[s]) }, load: function(t, e) { var i = iT(t, e); if (0 !== i.length) { if (1 === i.length) return i[0]; throw new AS("expected a single document in the stream, but found more") } } },
        sT = Object.prototype.toString,
        rT = Object.prototype.hasOwnProperty,
        oT = 65279,
        aT = 9,
        hT = 10,
        lT = 13,
        uT = 32,
        cT = 33,
        dT = 34,
        fT = 35,
        pT = 37,
        vT = 38,
        gT = 39,
        yT = 42,
        mT = 44,
        kT = 45,
        bT = 58,
        xT = 61,
        CT = 62,
        wT = 63,
        ST = 64,
        PT = 91,
        TT = 93,
        OT = 96,
        MT = 123,
        ET = 124,
        _T = 125,
        RT = { 0: "\\0", 7: "\\a", 8: "\\b", 9: "\\t", 10: "\\n", 11: "\\v", 12: "\\f", 13: "\\r", 27: "\\e", 34: '\\"', 92: "\\\\", 133: "\\N", 160: "\\_", 8232: "\\L", 8233: "\\P" },
        BT = ["y", "Y", "yes", "Yes", "YES", "on", "On", "ON", "n", "N", "no", "No", "NO", "off", "Off", "OFF"],
        IT = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

    function LT(t) { var e, i, n; if (e = t.toString(16).toUpperCase(), t <= 255) i = "x", n = 2;
        else if (t <= 65535) i = "u", n = 4;
        else { if (!(t <= 4294967295)) throw new AS("code point within a string may not be greater than 0xFFFFFFFF");
            i = "U", n = 8 } return "\\" + i + BS.repeat("0", n - e.length) + e } var AT = 1,
        jT = 2;

    function DT(t) { this.schema = t.schema || gP, this.indent = Math.max(1, t.indent || 2), this.noArrayIndent = t.noArrayIndent || !1, this.skipInvalid = t.skipInvalid || !1, this.flowLevel = BS.isNothing(t.flowLevel) ? -1 : t.flowLevel, this.styleMap = function(t, e) { var i, n, s, r, o, a, h; if (null === e) return {}; for (i = {}, s = 0, r = (n = Object.keys(e)).length; s < r; s += 1) o = n[s], a = String(e[o]), "!!" === o.slice(0, 2) && (o = "tag:yaml.org,2002:" + o.slice(2)), (h = t.compiledTypeMap.fallback[o]) && rT.call(h.styleAliases, a) && (a = h.styleAliases[a]), i[o] = a; return i }(this.schema, t.styles || null), this.sortKeys = t.sortKeys || !1, this.lineWidth = t.lineWidth || 80, this.noRefs = t.noRefs || !1, this.noCompatMode = t.noCompatMode || !1, this.condenseFlow = t.condenseFlow || !1, this.quotingType = '"' === t.quotingType ? jT : AT, this.forceQuotes = t.forceQuotes || !1, this.replacer = "function" == typeof t.replacer ? t.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null }

    function zT(t, e) { for (var i, n = BS.repeat(" ", e), s = 0, r = -1, o = "", a = t.length; s < a;) s = -1 === (r = t.indexOf("\n", s)) ? (i = t.slice(s), a) : (i = t.slice(s, r + 1), r + 1), i.length && "\n" !== i && (o += n), o += i; return o }

    function FT(t, e) { return "\n" + BS.repeat(" ", t.indent * e) }

    function YT(t) { return t === uT || t === aT }

    function XT(t) { return 32 <= t && t <= 126 || 161 <= t && t <= 55295 && 8232 !== t && 8233 !== t || 57344 <= t && t <= 65533 && t !== oT || 65536 <= t && t <= 1114111 }

    function WT(t) { return XT(t) && t !== oT && t !== lT && t !== hT }

    function GT(t, e, i) { var n = WT(t),
            s = n && !YT(t); return (i ? n : n && t !== mT && t !== PT && t !== TT && t !== MT && t !== _T) && t !== fT && !(e === bT && !s) || WT(e) && !YT(e) && t === fT || e === bT && s }

    function VT(t, e) { var i, n = t.charCodeAt(e); return 55296 <= n && n <= 56319 && e + 1 < t.length && 56320 <= (i = t.charCodeAt(e + 1)) && i <= 57343 ? 1024 * (n - 55296) + i - 56320 + 65536 : n }

    function UT(t) { return /^\n* /.test(t) } var HT = 1,
        NT = 2,
        JT = 3,
        KT = 4,
        ZT = 5;

    function qT(t, e, i, n, s, r, o, a) { var h, l, u, c = 0,
            d = null,
            f = !1,
            p = !1,
            v = -1 !== n,
            g = -1,
            y = XT(u = VT(t, 0)) && u !== oT && !YT(u) && u !== kT && u !== wT && u !== bT && u !== mT && u !== PT && u !== TT && u !== MT && u !== _T && u !== fT && u !== vT && u !== yT && u !== cT && u !== ET && u !== xT && u !== CT && u !== gT && u !== dT && u !== pT && u !== ST && u !== OT && (!YT(l = VT(t, t.length - 1)) && l !== bT); if (e || o)
            for (h = 0; h < t.length; 65536 <= c ? h += 2 : h++) { if (!XT(c = VT(t, h))) return ZT;
                y = y && GT(c, d, a), d = c } else { for (h = 0; h < t.length; 65536 <= c ? h += 2 : h++) { if ((c = VT(t, h)) === hT) f = !0, v && (p = p || n < h - g - 1 && " " !== t[g + 1], g = h);
                    else if (!XT(c)) return ZT;
                    y = y && GT(c, d, a), d = c }
                p = p || v && n < h - g - 1 && " " !== t[g + 1] }
        return f || p ? 9 < i && UT(t) ? ZT : o ? r === jT ? ZT : NT : p ? KT : JT : !y || o || s(t) ? r === jT ? ZT : NT : HT }

    function $T(n, s, r, o, a) { n.dump = function() { if (0 === s.length) return n.quotingType === jT ? '""' : "''"; if (!n.noCompatMode && (-1 !== BT.indexOf(s) || IT.test(s))) return n.quotingType === jT ? '"' + s + '"' : "'" + s + "'"; var t = n.indent * Math.max(1, r),
                e = -1 === n.lineWidth ? -1 : Math.max(Math.min(n.lineWidth, 40), n.lineWidth - t),
                i = o || -1 < n.flowLevel && r >= n.flowLevel; switch (qT(s, i, n.indent, e, function(t) { return function(t, e) { var i, n; for (i = 0, n = t.implicitTypes.length; i < n; i += 1)
                        if (t.implicitTypes[i].resolve(e)) return !0;
                    return !1 }(n, t) }, n.quotingType, n.forceQuotes && !o, a)) {
                case HT:
                    return s;
                case NT:
                    return "'" + s.replace(/'/g, "''") + "'";
                case JT:
                    return "|" + QT(s, n.indent) + tO(zT(s, t));
                case KT:
                    return ">" + QT(s, n.indent) + tO(zT(function(e, i) { var t, n, s = /(\n+)([^\n]*)/g,
                            r = function() { var t = e.indexOf("\n"); return t = -1 !== t ? t : e.length, s.lastIndex = t, eO(e.slice(0, t), i) }(),
                            o = "\n" === e[0] || " " === e[0]; for (; n = s.exec(e);) { var a = n[1],
                                h = n[2];
                            t = " " === h[0], r += a + (o || t || "" === h ? "" : "\n") + eO(h, i), o = t } return r }(s, e), t));
                case ZT:
                    return '"' + function(t) { for (var e, i = "", n = 0, s = 0; s < t.length; 65536 <= n ? s += 2 : s++) n = VT(t, s), !(e = RT[n]) && XT(n) ? (i += t[s], 65536 <= n && (i += t[s + 1])) : i += e || LT(n); return i }(s) + '"';
                default:
                    throw new AS("impossible error: invalid scalar style") } }() }

    function QT(t, e) { var i = UT(t) ? String(e) : "",
            n = "\n" === t[t.length - 1]; return i + (n && ("\n" === t[t.length - 2] || "\n" === t) ? "+" : n ? "" : "-") + "\n" }

    function tO(t) { return "\n" === t[t.length - 1] ? t.slice(0, -1) : t }

    function eO(t, e) { if ("" === t || " " === t[0]) return t; for (var i, n, s = / [^ ]/g, r = 0, o = 0, a = 0, h = ""; i = s.exec(t);) e < (a = i.index) - r && (n = r < o ? o : a, h += "\n" + t.slice(r, n), r = n + 1), o = a; return h += "\n", t.length - r > e && r < o ? h += t.slice(r, o) + "\n" + t.slice(o + 1) : h += t.slice(r), h.slice(1) }

    function iO(t, e, i, n) { var s, r, o, a = "",
            h = t.tag; for (s = 0, r = i.length; s < r; s += 1) o = i[s], t.replacer && (o = t.replacer.call(i, String(s), o)), (sO(t, e + 1, o, !0, !0, !1, !0) || void 0 === o && sO(t, e + 1, null, !0, !0, !1, !0)) && (n && "" === a || (a += FT(t, e)), t.dump && hT === t.dump.charCodeAt(0) ? a += "-" : a += "- ", a += t.dump);
        t.tag = h, t.dump = a || "[]" }

    function nO(t, e, i) { var n, s, r, o, a, h; for (r = 0, o = (s = i ? t.explicitTypes : t.implicitTypes).length; r < o; r += 1)
            if (((a = s[r]).instanceOf || a.predicate) && (!a.instanceOf || "object" == typeof e && e instanceof a.instanceOf) && (!a.predicate || a.predicate(e))) { if (i ? a.multi && a.representName ? t.tag = a.representName(e) : t.tag = a.tag : t.tag = "?", a.represent) { if (h = t.styleMap[a.tag] || a.defaultStyle, "[object Function]" === sT.call(a.represent)) n = a.represent(e, h);
                    else { if (!rT.call(a.represent, h)) throw new AS("!<" + a.tag + '> tag resolver accepts not "' + h + '" style');
                        n = a.represent[h](e, h) }
                    t.dump = n } return 1 } }

    function sO(t, e, i, n, s, r, o) { t.tag = null, t.dump = i, nO(t, i, !1) || nO(t, i, !0); var a, h = sT.call(t.dump),
            l = n;
        n = n && (t.flowLevel < 0 || t.flowLevel > e); var u, c, d = "[object Object]" === h || "[object Array]" === h; if (d && (c = -1 !== (u = t.duplicates.indexOf(i))), (null !== t.tag && "?" !== t.tag || c || 2 !== t.indent && 0 < e) && (s = !1), c && t.usedDuplicates[u]) t.dump = "*ref_" + u;
        else { if (d && c && !t.usedDuplicates[u] && (t.usedDuplicates[u] = !0), "[object Object]" === h) n && 0 !== Object.keys(t.dump).length ? (function(t, e, i, n) { var s, r, o, a, h, l, u = "",
                    c = t.tag,
                    d = Object.keys(i); if (!0 === t.sortKeys) d.sort();
                else if ("function" == typeof t.sortKeys) d.sort(t.sortKeys);
                else if (t.sortKeys) throw new AS("sortKeys must be a boolean or a function"); for (s = 0, r = d.length; s < r; s += 1) l = "", n && "" === u || (l += FT(t, e)), a = i[o = d[s]], t.replacer && (a = t.replacer.call(i, o, a)), sO(t, e + 1, o, !0, !0, !0) && ((h = null !== t.tag && "?" !== t.tag || t.dump && 1024 < t.dump.length) && (t.dump && hT === t.dump.charCodeAt(0) ? l += "?" : l += "? "), l += t.dump, h && (l += FT(t, e)), sO(t, e + 1, a, !0, h) && (t.dump && hT === t.dump.charCodeAt(0) ? l += ":" : l += ": ", u += l += t.dump));
                t.tag = c, t.dump = u || "{}" }(t, e, t.dump, s), c && (t.dump = "&ref_" + u + t.dump)) : (function(t, e, i) { var n, s, r, o, a, h = "",
                    l = t.tag,
                    u = Object.keys(i); for (n = 0, s = u.length; n < s; n += 1)(a = "") !== h && (a += ", "), t.condenseFlow && (a += '"'), o = i[r = u[n]], t.replacer && (o = t.replacer.call(i, r, o)), sO(t, e, r, !1, !1) && (1024 < t.dump.length && (a += "? "), a += t.dump + (t.condenseFlow ? '"' : "") + ":" + (t.condenseFlow ? "" : " "), sO(t, e, o, !1, !1) && (h += a += t.dump));
                t.tag = l, t.dump = "{" + h + "}" }(t, e, t.dump), c && (t.dump = "&ref_" + u + " " + t.dump));
            else if ("[object Array]" === h) n && 0 !== t.dump.length ? (t.noArrayIndent && !o && 0 < e ? iO(t, e - 1, t.dump, s) : iO(t, e, t.dump, s), c && (t.dump = "&ref_" + u + t.dump)) : (function(t, e, i) { var n, s, r, o = "",
                    a = t.tag; for (n = 0, s = i.length; n < s; n += 1) r = i[n], t.replacer && (r = t.replacer.call(i, String(n), r)), (sO(t, e, r, !1, !1) || void 0 === r && sO(t, e, null, !1, !1)) && ("" !== o && (o += "," + (t.condenseFlow ? "" : " ")), o += t.dump);
                t.tag = a, t.dump = "[" + o + "]" }(t, e, t.dump), c && (t.dump = "&ref_" + u + " " + t.dump));
            else { if ("[object String]" !== h) { if ("[object Undefined]" === h) return; if (t.skipInvalid) return; throw new AS("unacceptable kind of an object to dump " + h) } "?" !== t.tag && $T(t, t.dump, e, r, l) }
            null !== t.tag && "?" !== t.tag && (a = encodeURI("!" === t.tag[0] ? t.tag.slice(1) : t.tag).replace(/!/g, "%21"), a = "!" === t.tag[0] ? "!" + a : "tag:yaml.org,2002:" === a.slice(0, 18) ? "!!" + a.slice(18) : "!<" + a + ">", t.dump = a + " " + t.dump) } return 1 }

    function rO(t, e) { var i, n, s = [],
            r = []; for (! function t(e, i, n) { var s, r, o; if (null !== e && "object" == typeof e)
                    if (-1 !== (r = i.indexOf(e))) - 1 === n.indexOf(r) && n.push(r);
                    else if (i.push(e), Array.isArray(e))
                    for (r = 0, o = e.length; r < o; r += 1) t(e[r], i, n);
                else
                    for (s = Object.keys(e), r = 0, o = s.length; r < o; r += 1) t(e[s[r]], i, n) }(t, s, r), i = 0, n = r.length; i < n; i += 1) e.duplicates.push(s[r[i]]);
        e.usedDuplicates = new Array(n) }

    function oO(t, e) { return function() { throw new Error("Function yaml." + t + " is removed in js-yaml 4. Use yaml." + e + " instead, which is now safe by default.") } }

    function aO(t) { if ("string" == typeof t) try { return mO.load(t) } catch (t) { return void console.log(t) }
        return t }

    function hO(t, e) { if (void 0 === e) return t; if (t.hasOwnProperty("name") && kO(t, e["#".concat(t.name)]), t.hasOwnProperty("$class"))
            for (var i = t.$class.split(" "), n = 0, s = i.length; n < s; n++) kO(t, e[".".concat(i[n])]); return t.hasOwnProperty("$type") && kO(t, e[t.$type]), t }

    function lO(i, t) { for (var e = 0, n = bO.length; e < n; e++) { var s = bO[e],
                r = t[s];
            void 0 !== r && (i[s] = r) } return t.cropResize && !i.resize && (i.resize = function(t, e) { return i.setCrop(0, 0, t, e), i }), i }

    function uO(t, e, i, n, s, r) { var o = new r(t, 0, 0, (e = hO(e, n)).key, e.frame); return void 0 !== e.width && o.setDisplayWidth(e.width), void 0 !== e.height && o.setDisplayHeight(e.height), lO(o, e), t.add.existing(o), o }

    function cO(t, e, i, n, s, r) { var o, a = e[i]; return a && (o = TO(t, a, n, s, r), e[i] = o) }

    function dO(t, e, i, n, s) { if (e) { Array.isArray(e) || (e = [e]); for (var r = 0, o = e.length; r < o; r++) { var a = e[r];
                a.$child || (a = { $child: a }, e[r] = a), cO(t, a, "$child", i, n, s) } } return e }

    function fO(t, e, i, n, s, r) { e = hO(e, n); var o = dO(t, e.background, i, n, s),
            a = dO(t, e.children, i, n, s),
            h = new r(t, e); if (t.add.existing(h), o)
            for (var l = 0, u = o.length; l < u; l++) { var c = o[l];
                h.addBackground(c.$child, c.padding) }
        if (a)
            for (l = 0, u = a.length; l < u; l++) { c = a[l];
                h.add(c.$child, c) }
        return h }

    function pO(t, e, i, n, s, r) { var o = e[i]; if (o) { if (Array.isArray(o))
                for (var a = 0, h = o.length; a < h; a++)(Array.isArray(o[a]) ? pO : cO)(t, o, a, n, s, r);
            else
                for (var l in o) cO(t, o, l, n, s, r); return o } }

    function vO(t, e, i, n, s, r) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "icon", i, n, s), cO(t, e, "text", i, n, s), cO(t, e, "action", i, n, s); var o = new r(t, e); return t.add.existing(o), o }

    function gO(t, e, i, n, s) { return e && (cO(t, e, "background", i, n, s), cO(t, e, "track", i, n, s), cO(t, e, "indicator", i, n, s), cO(t, e, "thumb", i, n, s)), e }

    function yO(t, e, i, n, s) { if (e = aO(e), Array.isArray(e)) e = e[e.length - 1];
        else if (e.$root) { var r = e; if (e = e.$root, delete r.$root, void 0 === n) n = r;
            else
                for (var o in r) n[o] || (n[o] = r[o]) } return n = aO(n), TO(t, e, i, n, s) } var mO = { Type: XS, Schema: VS, FAILSAFE_SCHEMA: JS, JSON_SCHEMA: eP, CORE_SCHEMA: iP, DEFAULT_SCHEMA: gP, load: nT.load, loadAll: nT.loadAll, dump: { dump: function(t, e) { var i = new DT(e = e || {});
                    i.noRefs || rO(t, i); var n = t; return i.replacer && (n = i.replacer.call({ "": n }, "", n)), sO(i, 0, n, !0, !0) ? i.dump + "\n" : "" } }.dump, YAMLException: AS, types: { binary: hP, float: tP, map: NS, null: KS, pairs: fP, set: vP, timestamp: rP, bool: ZS, int: qS, merge: oP, omap: cP, seq: HS, str: US }, safeLoad: oO("safeLoad", "load"), safeLoadAll: oO("safeLoadAll", "loadAll"), safeDump: oO("safeDump", "dump") },
        kO = function t(e, i) { if (void 0 === i) return e; for (var n in i)
                if (e.hasOwnProperty(n)) { var s = e[n];
                    s && "object" === P(s) && t(s, i[n]) } else e[n] = E(i[n]);
            return e },
        bO = ["tint", "alpha", "visible", "flipX", "flipY"],
        xO = Phaser.GameObjects.Image,
        CO = Phaser.GameObjects.Sprite,
        wO = Phaser.GameObjects.Video,
        SO = Phaser.GameObjects.Text,
        PO = { Image: function(t, e, i, n) { return uO(t, e, 0, n, 0, xO) }, Sprite: function(t, e, i, n) { return uO(t, e, 0, n, 0, CO) }, Video: function(t, e, i, n) { e = hO(e, n); var s = new wO(t, 0, 0, e.key); return void 0 !== e.width && s.setDisplayWidth(e.width), void 0 !== e.height && s.setDisplayHeight(e.height), lO(s, e), t.add.existing(s), s }, Text: function(t, e, i, n) { e = hO(e, n); var s = new SO(t, 0, 0, e.text, e); return lO(s, e), t.add.existing(s), s }, BBCodeText: function(t, e, i, n) { e = hO(e, n); var s = new Nn(t, 0, 0, e.text, e); return lO(s, e), t.add.existing(s), s }, RoundRectangle: function(t, e, i, n) { e = hO(e, n); var s = new Gt(t, e); return t.add.existing(s), s }, Ninepatch: function(t, e, i, n) { e = hO(e, n); var s = new L(t, e); return lO(s, e), t.add.existing(s), s }, Ninepatch2: function(t, e, i, n) { e = hO(e, n); var s = new Ct(t, e); return t.add.existing(s), s }, Canvas: function(t, e, i, n) { var s = (e = hO(e, n)).width || 1,
                    r = e.height || 1,
                    o = new Qt(t, 0, 0, s, r); return void 0 !== e.fill && o.fill(e.fill), lO(o, e), t.add.existing(o), o }, CircleMaskImage: function(t, e, i, n) { e = hO(e, n); var s = new qr(t, 0, 0, e.key, e.frame, e); return void 0 !== e.width && s.setDisplayWidth(e.width), void 0 !== e.height && s.setDisplayHeight(e.height), lO(s, e), t.add.existing(s), s }, Space: function(t) { return new Ng(t) }, Sizer: function(t, e, i, n, s) { return fO(t, e, i, n, s, oy) }, FixWidthSizer: function(t, e, i, n, s) { return fO(t, e, i, n, s, Dy) }, GridSizer: function(t, e, o, a, h) { var l = e.createCellContainerCallback; if (l) { var u = l.$child;
                    delete l.$child, e.createCellContainerCallback = function(t, e, i, n) { var s = TO(t, u, o, a, h); for (var r in l) n[r] = l[r]; return s } } return fO(t, e, o, a, h, Cy) }, OverlapSizer: function(t, e, i, n, s) { return fO(t, e, i, n, s, Rv) }, Buttons: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), pO(t, e, "buttons", i, n, s); var r = new ym(t, e); return t.add.existing(r), r }, FixWidthButtons: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), pO(t, e, "buttons", i, n, s); var r = new Lm(t, e); return t.add.existing(r), r }, GridButtons: function(t, e, o, a, h) { e = hO(e, a), cO(t, e, "background", o, a, h); var i = e.buttons; if (i)
                    for (var n = 0, s = i.length; n < s; n++) pO(t, i, n, o, a, h); var l = e.createCellContainerCallback; if (l) { var u = l.$child;
                    delete l.$child, e.createCellContainerCallback = function(t, e, i, n) { var s = TO(t, u, o, a, h); for (var r in l) n[r] = l[r]; return s } } var r = new Pm(t, e); return t.add.existing(r), r }, Label: function(t, e, i, n, s) { return vO(t, e, i, n, s, Xy) }, BadgeLabel: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "main", i, n, s), cO(t, e, "leftTop", i, n, s), cO(t, e, "centerTop", i, n, s), cO(t, e, "rightTop", i, n, s), cO(t, e, "leftCenter", i, n, s), cO(t, e, "center", i, n, s), cO(t, e, "rightCenter", i, n, s), cO(t, e, "leftBottom", i, n, s), cO(t, e, "centerBottom", i, n, s), cO(t, e, "rightBottom", i, n, s); var r = new Tx(t, e); return t.add.existing(r), r }, Dialog: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "toolbarBackground", i, n, s), cO(t, e, "leftToolbarBackground", i, n, s), cO(t, e, "choicesBackground", i, n, s), cO(t, e, "actionsBackground", i, n, s), cO(t, e, "title", i, n, s), pO(t, e, "toolbar", i, n, s), pO(t, e, "leftToolbar", i, n, s), cO(t, e, "content", i, n, s), cO(t, e, "description", i, n, s), pO(t, e, "choices", i, n, s), pO(t, e, "actions", i, n, s); var r = new Dm(t, e); return t.add.existing(r), r }, TextBox: function(t, e, i, n, s) { return vO(t, e, i, n, s, bx) }, Slider: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "track", i, n, s), cO(t, e, "indicator", i, n, s), cO(t, e, "thumb", i, n, s); var r = new gk(t, e); return t.add.existing(r), r }, NumberBar: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "icon", i, n, s), gO(t, e.slider, i, n, s), cO(t, e, "text", i, n, s); var r = new wx(t, e); return t.add.existing(r), r }, ScrollBar: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), gO(t, e.slider, i, n, s); var r = e.buttons;
                r && (cO(t, r, "top", i, n, s), cO(t, r, "bottom", i, n, s), cO(t, r, "left", i, n, s), cO(t, r, "right", i, n, s)); var o = new wk(t, e); return t.add.existing(o), o }, TextArea: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "text", i, n, s), gO(t, e.slider, i, n, s), cO(t, e, "header", i, n, s), cO(t, e, "footer", i, n, s); var r = new HC(t, e); return t.add.existing(r), r }, Pages: function(t, e, i, n, s) { return fO(t, e, i, n, s, Ix) }, Toast: function(t, e, i, n, s) { return vO(t, e, i, n, s, gw) }, Knob: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "text", i, n, s); var r = new qv(t, e); return t.add.existing(r), r }, HolyGrail: function(t, e, i, n, s) { e = hO(e, n), cO(t, e, "background", i, n, s), cO(t, e, "content", i, n, s), cO(t, e, "leftSide", i, n, s), cO(t, e, "rightSide", i, n, s), cO(t, e, "header", i, n, s), cO(t, e, "footer", i, n, s); var r = new Gm(t, e); return t.add.existing(r), r }, Menu: function(t, e, o, a, h) { var i = (e = hO(e, a)).background;
                delete e.background, i && (e.createBackgroundCallback = function(t) { var e = t.scene; return TO(e, E(i), o, a, h) }), e.createButtonCallback = function(t, e, i) { var n = t.scene,
                        s = t.$next;
                    delete t.scene, delete t.$next; var r = TO(n, E(t), o, a, h); return t.scene = n, t.$next = s, r }, e.childrenKey = "$next"; var n = new zb(t, e); return t.add.existing(n), n } },
        TO = function(t, e, i, n, s) { var r = function(t, e) { if (t.hasOwnProperty("$type")) return t.$type; if (t.hasOwnProperty("name") && ((r = e["#".concat(t.name)]) && r.hasOwnProperty("$type"))) return r.$type; if (t.hasOwnProperty("$class"))
                    for (var i = t.$class.split(" "), n = 0, s = i.length; n < s; n++) { var r; if ((r = e[".".concat(i[n])]) && r.hasOwnProperty("$type")) return r.$type } }(e, n); if (r) { var o; if (s && (o = s[r]), o = o || PO[r]) { var a = o(t, e, i, n, s); return e.name && a.setName(e.name), a }
                console.warn("rexUI.Make: Can't create ".concat(r, " game object.")) } else console.warn("rexUI.Make: Can't get type name in ".concat(JSON.stringify(e))) },
        OO = Phaser.Utils.Objects.IsPlainObject,
        MO = function() {
            function n(t, e, i) { X(this, n), this.setScene(t), this.setStyles(e), this.setBuilders(i) } return k(n, [{ key: "setScene", value: function(t) { return this.scene = t, this } }, { key: "setStyles", value: function(t) { return this.styles = aO(t), this } }, { key: "addStyle", value: function(t, e) { if (void 0 === this.styles && (this.styles = {}), "string" == typeof t && void 0 === e && (t = aO(t)), OO(t)) { var i = t; for (t in i) this.styles[t] = i[t] } else this.styles[t] = aO(e); return this } }, { key: "clearStyles", value: function() { return this.setStyles(), this } }, { key: "setBuilders", value: function(t) { return this.customBuilders = t, this } }, { key: "addBuilder", value: function(t, e) { if (void 0 === this.customBuilders && (this.customBuilders = {}), OO(t)) { var i = t; for (t in i) this.customBuilders[t] = i[t] } else this.customBuilders[t] = e; return this } }, { key: "clearBuilder", value: function() { return this.setBuilders(), this } }, { key: "make", value: function(t, e) { return yO(this.scene, t, e, this.styles, this.customBuilders) } }]), n }();
    p.register("maker", function(t, e) { return new MO(this.scene, t, e) }), j(window, "RexPlugins.UI.Maker", MO);

    function EO(t, e, i) { if (null == e) return t; if (0 === e) return AO(t, 0, i), t; var n = t.text.length; if (0 === n) return AO(t, e, i), t; for (var s = Math.floor(1.5 * e / n), r = {}, o = LO(t, s, e, i, r), a = 0; a <= 65535 && 0 !== o; a++) { if ((s += o) < 0) { s = 0; break }
            o = LO(t, s, e, i, r) } return 65535 === a && console.warn("SetFontSizeToFitWidth: Test count exceeds ".concat(65535)), t.setFontSize(s), AO(t, e, i), t }

    function _O(t, e, i) { return void 0 === i[e] && (t.setFontSize(e), i[e] = { width: t.width, height: t.height }), i[e] }

    function RO(t, e) { vd(t, e, t.alpha) }

    function BO(t, e) { gd(t, e, !1) }

    function IO(e, t) { var i = new VO(e, t); return i.on("open", function() { e.emit("modal.open", i) }), i.on("close", function(t) { e.emit("modal.close", t, i) }), e.on("modal.requestClose", i.requestClose, i), i.on("close", function() { e.off("modal.requestClose", i.requestClose, i) }), i } var LO = function(t, e, i, n, s) { var r = _O(t, e, s),
                o = _O(t, e + 1, s); if (void 0 !== n) { if (r.height <= n && o.height > n) return 0; if (r.height > n) return -1 } return r.width <= i && o.width > i ? 0 : r.width > i ? -1 : Math.floor(i - r.width) },
        AO = function(t, e, i) { var n = t.style;
            n.fixedWidth = e, n.parent.width = e, void 0 !== i && (n.fixedHeight = i, n.parent.height = i), n.update(!1) },
        jO = function() { w(s, Yf); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, e)).parent = t, i.init(), i } return k(s, [{ key: "init", value: function() { this.start("IDLE") } }, { key: "next_IDLE", value: function() { return "TRANS_OPNE" } }, { key: "next_TRANS_OPNE", value: function() { return "OPEN" } }, { key: "enter_TRANS_OPNE", value: function() { var t = this.parent;
                    t.transitionIn(), t.delayCall(t.transitInTime, this.next, this) } }, { key: "exit_TRANS_OPNE", value: function() { this.parent.removeDelayCall() } }, { key: "next_OPEN", value: function() { return "TRANS_CLOSE" } }, { key: "enter_OPEN", value: function() { this.parent.onOpen() } }, { key: "exit_OPEN", value: function() { this.parent.removeDelayCall() } }, { key: "next_TRANS_CLOSE", value: function() { return "CLOSE" } }, { key: "enter_TRANS_CLOSE", value: function() { var t = this.parent;
                    t.transitionOut(), t.delayCall(t.transitOutTime, this.next, this) } }, { key: "exit_TRANS_CLOSE", value: function() { this.parent.removeDelayCall() } }, { key: "next_CLOSE", value: function() {} }, { key: "enter_CLOSE", value: function() { this.parent.onClose() } }, { key: "exit_CLOSE", value: function() {} }]), s }(),
        DO = Phaser.Utils.Objects.GetValue,
        zO = function() { w(s, ds); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).setTransitInTime(DO(e, "duration.in", 200)), i.setTransitOutTime(DO(e, "duration.out", 200)), i.setTransitInCallback(DO(e, "transitIn")), i.setTransitOutCallback(DO(e, "transitOut")), i.destroyParent = DO(e, "destroy", !0), i.timer = void 0, i._state = new jO(W(i), { eventEmitter: !1 }), i.closeEventData = void 0, i } return k(s, [{ key: "start", value: function() { this._state.next() } }, { key: "state", get: function() { return this._state.state } }, { key: "shutdown", value: function(t) { this.isShutdown || (this.transitInCallback = void 0, this.transitOutCallback = void 0, this.closeEventData = void 0, this.removeDelayCall(), O(C(s.prototype), "shutdown", this).call(this, t)) } }, { key: "transitionIn", value: function() { var t = this.transitInTime; return this.transitInCallback(this.parent, t), this } }, { key: "transitionOut", value: function() { var t = this.transitOutTime; return this.transitOutCallback(this.parent, t), this } }, { key: "onOpen", value: function() {} }, { key: "onClose", value: function() { this.destroyParent ? this.parent.destroy() : this.destroy() } }, { key: "delayCall", value: function(t, e, i) { return this.timer = Bb(this, t, e, i), this } }, { key: "removeDelayCall", value: function() { return this.timer && (this.timer.remove(!1), this.timer = void 0), this } }, { key: "setTransitInTime", value: function(t) { return this.transitInTime = t, this } }, { key: "setTransitOutTime", value: function(t) { return this.transitOutTime = t, this } }, { key: "setTransitInCallback", value: function(t) { return t = t || _, this.transitInCallback = t, this } }, { key: "setTransitOutCallback", value: function(t) { return t = t || _, this.transitOutCallback = t, this } }, { key: "requestClose", value: function(t) { return "OPEN" === this._state.state && (this.closeEventData = 0 < arguments.length ? t : this.parent, this._state.next()), this } }]), s }(),
        FO = dd,
        YO = function(t, e) { fd(t, e, void 0, void 0, !1) },
        XO = vd,
        WO = function(t, e) { gd(t, e, !1) },
        GO = Phaser.Utils.Objects.GetValue,
        VO = function() { w(l, zO); var h = T(l);

            function l(t, e) { var i;
                X(this, l), void 0 === e && (e = {}), e.hasOwnProperty("transitIn") || (e.transitIn = UO.popUp), e.hasOwnProperty("transitOut") || (e.transitOut = UO.scaleDown), i = h.call(this, t, e); var n, s, r, o, a = GO(e, "cover");
                (i.cover = !1 !== a ? (s = a, r = (n = t).scene, o = new Yg(r, s), r.add.existing(o), n.isRexContainerLite ? n.moveDepthBelow(o) : r.children.moveBelow(o, n), o) : void 0, i.cover && (i.setCoverTransitInCallback(GO(a, "transitIn", RO)), i.setCoverTransitOutCallback(GO(a, "transitOut", BO))), GO(e, "manualClose", !0)) ? i.setDisplayTime(-1): (i.setDisplayTime(GO(e, "duration.hold", 2e3)), GO(e, "anyTouchClose", !0) && i.anyTouchClose()); return i.start(), i } return k(l, [{ key: "shutdown", value: function(t) { this.isShutdown || (this.cover || this.scene.input.off("pointerup", this.requestClose, this), this.cover && !t && (this.cover.destroy(), this.cover = void 0), O(C(l.prototype), "shutdown", this).call(this, t)) } }, { key: "anyTouchClose", value: function() { return this.cover ? this.cover.once("pointerup", this.requestClose, this) : this.scene.input.once("pointerup", this.requestClose, this), this } }, { key: "transitionIn", value: function() { O(C(l.prototype), "transitionIn", this).call(this); var t = this.transitInTime,
                        e = this.cover; return e && this.coverTransitInCallback && this.coverTransitInCallback(e, t), this } }, { key: "transitionOut", value: function() { O(C(l.prototype), "transitionOut", this).call(this); var t = this.transitOutTime,
                        e = this.cover; return e && this.coverTransitOutCallback && this.coverTransitOutCallback(e, t), this } }, { key: "onOpen", value: function() { var t = this.displayTime;
                    0 <= t && this.delayCall(t, this.requestClose, this), this.emit("open", this.parent, this), O(C(l.prototype), "onOpen", this).call(this) } }, { key: "onClose", value: function() { this.emit("close", this.closeEventData), O(C(l.prototype), "onClose", this).call(this) } }, { key: "setDisplayTime", value: function(t) { return this.displayTime = t, this } }, { key: "setTransitInCallback", value: function(t) { switch ("string" == typeof t && (t = UO[t]), t) {
                        case UO.popUp:
                            t = FO; break;
                        case UO.fadeIn:
                            t = XO } return O(C(l.prototype), "setTransitInCallback", this).call(this, t), this } }, { key: "setTransitOutCallback", value: function(t) { switch ("string" == typeof t && (t = UO[t]), t) {
                        case UO.scaleDown:
                            t = YO; break;
                        case UO.fadeOut:
                            t = WO } return O(C(l.prototype), "setTransitOutCallback", this).call(this, t), this } }, { key: "setCoverTransitInCallback", value: function(t) { return this.coverTransitInCallback = t, this } }, { key: "setCoverTransitOutCallback", value: function(t) { return this.coverTransitOutCallback = t, this } }]), l }(),
        UO = { popUp: 0, fadeIn: 1, scaleDown: 0, fadeOut: 1 },
        HO = function() { w(s, Phaser.Plugins.ScenePlugin); var n = T(s);

            function s(t, e) { var i; return X(this, s), (i = n.call(this, t, e)).add = new p(t), i } return k(s, [{ key: "start", value: function() { this.scene.events.on("destroy", this.destroy, this) } }, { key: "isInTouching", value: function(t, e, i, n) { return !!t.visible && Td(t, e, i, n) } }, { key: "viewport", get: function() { return xh(this.scene, this.scene.cameras.main, !0) } }, { key: "make", value: function(t, e, i, n) { return yO(this.scene, t, e, i, n) } }, { key: "maker", get: function() { return this._maker || (this._maker = new MO(this.scene)), this._maker } }]), s }(),
        NO = { getParentSizer: Fs, getTopmostSizer: Ys, hide: wd, show: Cd, isShown: Sd, edit: function(t, e, i) { return t._edit || (t._edit = new _S(t, { clickEnable: !1 })), t._edit.open(e, i), t._edit }, wrapExpandText: function(t, e) { var s, i, n; return void 0 === e && (e = 0), t._minWidth = e, t.runWidthWrap = t instanceof ya ? (n = t, function(t) { return n.setFixedSize(t, 0).runWordWrap(), n.minHeight = n.height, n }) : Qb(t) ? (i = t, function(t) { return i.setMaxWidth(t), i.minHeight = i.height, i }) : (s = t, function(t) { var e = s.padding,
                        i = t - e.left - e.right,
                        n = s.style; return $b(s) ? n.wordWrapWidth = i : (0 === n.wrapMode && (n.wrapMode = 1), n.wrapWidth = i), n.maxLines = 0, s.setFixedSize(t, 0), s.minHeight = s.height, s }), t }, fontSizeExpandText: function(i, t) { return void 0 === t && (t = 0), i._minWidth = t, i.runWidthWrap = function(t, e) { return EO(i, t, e), i }, i.resize = function(t, e) { return i.width === t && i.height === e || i.setFixedSize(t, e), i }, i }, fontSizeResize: EO, setFontSizeToFitWidth: EO, waitEvent: il, waitComplete: nl, delayPromise: function(i, n) { return void 0 === i && (i = 0), new Promise(function(t, e) { setTimeout(function() { t(n) }, i) }) }, setChildrenInteractive: sv, fadeIn: vd, fadeOutDestroy: gd, easeMoveTo: kd, easeMoveFrom: bd, modal: IO, modalPromise: function(t, e) { var i = IO(t, e); return new Promise(function(e, t) { i.once("close", function(t) { e(t) }) }) }, modalClose: function(t, e) { t.emit("modal.requestClose", e) }, requestDrag: _w, yaml: mO }; return Object.assign(HO.prototype, NO), HO })